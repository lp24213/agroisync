[{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\cloudflare-worker.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\auth.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":25,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":25,"endColumn":42},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":128,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":128,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":139,"column":52,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":139,"endColumn":54},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":155,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":155,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":169,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":169,"endColumn":35},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":185,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":185,"endColumn":13},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":199,"column":60,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":199,"endColumn":62},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":215,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":215,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { config } from './config.js';\n\nimport logger from '../utils/logger.js';\n// ===== CONFIGURAÃ‡ÃƒO JWT =====\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN || '7d';\n\n// ===== FUNÃ‡Ã•ES DE AUTENTICAÃ‡ÃƒO =====\n\n// Gerar token JWT\nexport const generateToken = payload => {\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n};\n\n// Gerar refresh token\nexport const generateRefreshToken = payload => {\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: REFRESH_TOKEN_EXPIRES_IN });\n};\n\n// Verificar token JWT\nexport const verifyToken = async token => {\n  try {\n    const payload = jwt.verify(token, JWT_SECRET);\n    return {\n      valid: true,\n      payload,\n      userId: payload.userId,\n      email: payload.email,\n      userType: payload.userType || 'buyer',\n      groups: payload.groups || []\n    };\n  } catch (error) {\n    // Console log removido (dados sensÃ­veis)\n    return {\n      valid: false,\n      error: error.message\n    };\n  }\n};\n\n// Hash de senha\nexport const hashPassword = async password => {\n  const saltRounds = 12;\n  return await bcrypt.hash(password, saltRounds);\n};\n\n// Verificar senha\nexport const verifyPassword = async (password, hashedPassword) => {\n  return await bcrypt.compare(password, hashedPassword);\n};\n\n// Verificar se usuÃ¡rio Ã© admin\nexport const isAdmin = groups => {\n  return groups && groups.includes('admin');\n};\n\n// Verificar se usuÃ¡rio tem plano ativo\nexport const hasActivePlan = (user, module) => {\n  if (!user || !user.subscriptions) {\n    return false;\n  }\n\n  const subscription = user.subscriptions[module];\n  if (!subscription) {\n    return false;\n  }\n\n  return (\n    subscription.status === 'active' &&\n    subscription.endDate &&\n    new Date(subscription.endDate) > new Date()\n  );\n};\n\n// Verificar permissÃµes para mensagens privadas\nexport const canAccessPrivateMessages = user => {\n  // UsuÃ¡rios com plano ativo podem acessar mensagens privadas\n  return hasActivePlan(user, 'store') || hasActivePlan(user, 'freight');\n};\n\n// Verificar permissÃµes para criar anÃºncios\nexport const canCreateAds = user => {\n  return (\n    hasActivePlan(user, 'store') &&\n    user.subscriptions.store.currentAds < user.subscriptions.store.maxAds\n  );\n};\n\n// Verificar permissÃµes para criar fretes\nexport const canCreateFreights = user => {\n  return (\n    hasActivePlan(user, 'freight') &&\n    user.subscriptions.freight.currentFreights < user.subscriptions.freight.maxFreights\n  );\n};\n\n// ===== MIDDLEWARE DE AUTENTICAÃ‡ÃƒO =====\n\nexport const authenticateToken = async (req, res, next) => {\n  try {\n    const authHeader = req.headers.authorization;\n\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token de autenticaÃ§Ã£o nÃ£o fornecido'\n      });\n    }\n\n    const token = authHeader.substring(7);\n    const verification = await verifyToken(token);\n\n    if (!verification.valid) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token invÃ¡lido ou expirado'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes do usuÃ¡rio ao request\n    req.user = verification;\n    req.userId = verification.userId;\n\n    next();\n  } catch (error) {\n    // Console log removido (dados sensÃ­veis)\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno de autenticaÃ§Ã£o'\n    });\n  }\n};\n\n// Middleware para verificar se usuÃ¡rio Ã© admin\nexport const requireAdmin = async (req, res, next) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'AutenticaÃ§Ã£o necessÃ¡ria'\n      });\n    }\n\n    if (!isAdmin(req.user.groups)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado: apenas administradores'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error in admin verification:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno de verificaÃ§Ã£o'\n    });\n  }\n};\n\n// Middleware para verificar plano ativo\nexport const requireActivePlan = module => {\n  return async (req, res, next) => {\n    try {\n      if (!req.user) {\n        return res.status(401).json({\n          success: false,\n          message: 'AutenticaÃ§Ã£o necessÃ¡ria'\n        });\n      }\n\n      if (!hasActivePlan(req.user, module)) {\n        return res.status(403).json({\n          success: false,\n          message: `Plano ${module} ativo necessÃ¡rio para esta funcionalidade`\n        });\n      }\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Error in plan verification:', error);\n      }\n      return res.status(500).json({\n        success: false,\n        message: 'Erro interno de verificaÃ§Ã£o'\n      });\n    }\n  };\n};\n\n// Middleware para verificar acesso a mensagens privadas\nexport const requireMessageAccess = async (req, res, next) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'AutenticaÃ§Ã£o necessÃ¡ria'\n      });\n    }\n\n    if (!canAccessPrivateMessages(req.user)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano ativo necessÃ¡rio para acessar mensagens privadas'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error in message access verification:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno de verificaÃ§Ã£o'\n    });\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE UTILIDADE =====\n\n// Gerar cÃ³digo de verificaÃ§Ã£o\nexport const generateVerificationCode = (length = 6) => {\n  const digits = '0123456789';\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += digits.charAt(Math.floor(Math.random() * digits.length));\n  }\n  return result;\n};\n\n// Gerar token de reset de senha\nexport const generatePasswordResetToken = userId => {\n  const payload = {\n    userId,\n    type: 'password_reset',\n    timestamp: Date.now()\n  };\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: '15m' });\n};\n\n// Verificar token de reset de senha\nexport const verifyPasswordResetToken = token => {\n  try {\n    const payload = jwt.verify(token, JWT_SECRET);\n    if (payload.type !== 'password_reset') {\n      throw new Error('Invalid token type');\n    }\n    return {\n      valid: true,\n      userId: payload.userId,\n      timestamp: payload.timestamp\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error.message\n    };\n  }\n};\n\n// Gerar token de verificaÃ§Ã£o de email\nexport const generateEmailVerificationToken = (userId, email) => {\n  const payload = {\n    userId,\n    email,\n    type: 'email_verification',\n    timestamp: Date.now()\n  };\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: '24h' });\n};\n\n// Verificar token de verificaÃ§Ã£o de email\nexport const verifyEmailVerificationToken = token => {\n  try {\n    const payload = jwt.verify(token, JWT_SECRET);\n    if (payload.type !== 'email_verification') {\n      throw new Error('Invalid token type');\n    }\n    return {\n      valid: true,\n      userId: payload.userId,\n      email: payload.email,\n      timestamp: payload.timestamp\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error.message\n    };\n  }\n};\n\nexport default {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  hashPassword,\n  verifyPassword,\n  isAdmin,\n  hasActivePlan,\n  canAccessPrivateMessages,\n  canCreateAds,\n  canCreateFreights,\n  authenticateToken,\n  requireAdmin,\n  requireActivePlan,\n  requireMessageAccess,\n  generateVerificationCode,\n  generatePasswordResetToken,\n  verifyPasswordResetToken,\n  generateEmailVerificationToken,\n  verifyEmailVerificationToken\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\constants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\environment.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\security.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\stripe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\swagger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\handler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\admin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'jwt' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":36,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":36,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":67,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":67,"endColumn":13},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":82,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":82,"endColumn":35},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":116,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":116,"endColumn":13},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":121,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":121,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import jwt from 'jsonwebtoken';\nimport User from '../models/User.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para verificar se o usuÃ¡rio Ã© admin\nexport const requireAdmin = async (req, res, next) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar o usuÃ¡rio no banco\n    const user = await User.findById(userId);\n\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se Ã© admin\n    if (!user.isAdmin) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. Apenas administradores podem acessar esta Ã¡rea.'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes do admin ao req\n    req.admin = {\n      id: user._id,\n      email: user.email,\n      name: user.name,\n      permissions: user.adminPermissions || []\n    };\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na verificaÃ§Ã£o de admin:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n};\n\n// Middleware para verificar permissÃµes especÃ­ficas de admin\nexport const requireAdminPermission = permission => {\n  return (req, res, next) => {\n    try {\n      if (!req.admin) {\n        return res.status(401).json({\n          success: false,\n          message: 'UsuÃ¡rio nÃ£o autenticado como admin'\n        });\n      }\n\n      // Verificar se tem a permissÃ£o especÃ­fica\n      if (!req.admin.permissions.includes(permission) && !req.admin.permissions.includes('*')) {\n        return res.status(403).json({\n          success: false,\n          message: `PermissÃ£o '${permission}' necessÃ¡ria para esta aÃ§Ã£o`\n        });\n      }\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro na verificaÃ§Ã£o de permissÃ£o:', error);\n      }\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  };\n};\n\n// Middleware para log de auditoria automÃ¡tico\nexport const auditLog = (action, resource) => {\n  return async (req, res, next) => {\n    try {\n      // Interceptar a resposta para logar apÃ³s sucesso\n      const originalSend = res.send;\n\n      res.send = function (data) {\n        // SÃ³ logar se a resposta foi bem-sucedida\n        if (res.statusCode >= 200 && res.statusCode < 300) {\n          // Log assÃ­ncrono sem bloquear a resposta\n          setImmediate(async () => {\n            try {\n              const AuditLog = (await import('../models/AuditLog.js')).default;\n              await AuditLog.logAction({\n                userId: req.user?.userId,\n                userEmail: req.user?.email,\n                action,\n                resource,\n                resourceId: req.params?.id,\n                details: `Admin action: ${action} on ${resource}`,\n                ip: req.ip,\n                userAgent: req.get('User-Agent')\n              });\n            } catch (logError) {\n              if (process.env.NODE_ENV !== 'production') {\n                logger.error('Erro ao registrar log de auditoria:', logError);\n              }\n            }\n          });\n        }\n\n        // Chamar o mÃ©todo original\n        originalSend.call(this, data);\n      };\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro no middleware de auditoria:', error);\n      }\n      next(error);\n    }\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\adminAuth.js","messages":[{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":56,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":56,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":118,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":118,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import jwt from 'jsonwebtoken';\nimport auditService from '../services/auditService.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para verificar se o usuÃ¡rio Ã© admin\nconst requireAdmin = async (req, res, next) => {\n  try {\n    // Verificar se o token foi fornecido\n    const token = req.headers.authorization?.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token de acesso nÃ£o fornecido'\n      });\n    }\n\n    // Verificar se o token Ã© vÃ¡lido\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n\n    // Verificar se o usuÃ¡rio existe e Ã© admin\n    if (!decoded.email || !decoded.role || decoded.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. Apenas administradores podem acessar este recurso.'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes do usuÃ¡rio ao request\n    req.user = {\n      id: decoded.id,\n      email: decoded.email,\n      role: decoded.role\n    };\n\n    // Log da aÃ§Ã£o\n    await auditService.logAdminAccess({\n      userId: decoded.id,\n      resource: req.originalUrl,\n      resourceId: null,\n      sessionInfo: {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        country: req.get('CF-IPCountry') || 'unknown',\n        city: req.get('CF-IPCity') || 'unknown',\n        isp: req.get('CF-IPISP') || 'unknown'\n      },\n      metadata: {\n        endpoint: req.originalUrl,\n        method: req.method,\n        statusCode: 200,\n        responseTime: 0\n      }\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na verificaÃ§Ã£o de admin:', error);\n    }\n    if (error.name === 'JsonWebTokenError') {\n      return res.status(401).json({\n        success: false,\n        message: 'Token invÃ¡lido'\n      });\n    }\n\n    if (error.name === 'TokenExpiredError') {\n      return res.status(401).json({\n        success: false,\n        message: 'Token expirado'\n      });\n    }\n\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n};\n\n// Middleware para validar aÃ§Ãµes administrativas\nconst validateAdminAction = async (req, res, next) => {\n  try {\n    const { action, resourceId, details } = req.body;\n\n    if (!action || !resourceId) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o e ID do recurso sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Log da aÃ§Ã£o administrativa\n    await auditService.logAction({\n      userId: req.user.id,\n      action: `admin_${action.toLowerCase()}`,\n      resource: req.originalUrl,\n      resourceId,\n      afterData: { details: details || `Admin action: ${action}` },\n      sessionInfo: {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        country: req.get('CF-IPCountry') || 'unknown',\n        city: req.get('CF-IPCity') || 'unknown',\n        isp: req.get('CF-IPISP') || 'unknown'\n      },\n      metadata: {\n        endpoint: req.originalUrl,\n        method: req.method,\n        statusCode: 200,\n        responseTime: 0\n      },\n      sensitivityLevel: 'high',\n      containsPII: false\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o da aÃ§Ã£o administrativa:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n};\n\nexport { requireAdmin, validateAdminAction };\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\adminValidation.js","messages":[{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":45,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":45,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import AuditLog from '../models/AuditLog.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para validar aÃ§Ãµes administrativas\nexport const validateAdminAction = async (req, res, next) => {\n  try {\n    const { action, reason } = req.body;\n\n    // Validar se aÃ§Ã£o e motivo foram fornecidos\n    if (!action || !reason) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o e motivo sÃ£o obrigatÃ³rios para operaÃ§Ãµes administrativas'\n      });\n    }\n\n    // Validar se o motivo tem pelo menos 10 caracteres\n    if (reason.trim().length < 10) {\n      return res.status(400).json({\n        success: false,\n        message: 'Motivo deve ter pelo menos 10 caracteres'\n      });\n    }\n\n    // Validar se a aÃ§Ã£o Ã© vÃ¡lida\n    const validActions = ['ban', 'activate', 'update', 'delete', 'export'];\n    if (!validActions.includes(action)) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o administrativa invÃ¡lida'\n      });\n    }\n\n    // Log da validaÃ§Ã£o da aÃ§Ã£o administrativa\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'ADMIN_ACTION_VALIDATED',\n      resource: 'admin_validation',\n      details: `Admin action validated: ${action} - ${reason}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o da aÃ§Ã£o administrativa:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'ADMIN_ACTION_VALIDATION_ERROR',\n      resource: 'admin_validation',\n      details: `Validation error: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'VALIDATION_ERROR',\n      errorMessage: error.message\n    });\n\n    return res.status(500).json({\n      success: false,\n      message: 'Erro na validaÃ§Ã£o da aÃ§Ã£o administrativa'\n    });\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\audit.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\cors.js","messages":[{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":45,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":45,"endColumn":27},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":48,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":48,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿// =============================================================\n// AGROISYNC â€¢ Middleware CORS Otimizado\n// =============================================================\n\n/**\n * ConfiguraÃ§Ã£o CORS para mÃºltiplas origens\n */\nimport logger from '../utils/logger.js';\n\nconst isProduction =\n  typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production';\n\nfunction getAllowedOriginsForEnv() {\n  if (isProduction) {\n    return ['https://agroisync.com', 'https://www.agroisync.com'];\n  }\n  return [\n    'http://localhost:3000',\n    'http://localhost:3001',\n    'http://127.0.0.1:3000',\n    'http://127.0.0.1:3001'\n  ];\n}\n\nexport const corsOptions = {\n  origin(origin, callback) {\n    const allowedOrigins = getAllowedOriginsForEnv();\n\n    // Permitir requisiÃ§Ãµes sem origin (mobile apps, Postman, etc.)\n    if (!origin) {\n      return callback(null, true);\n    }\n\n    // Verificar se a origem estÃ¡ na lista\n    const isAllowed = allowedOrigins.some(allowedOrigin => {\n      if (typeof allowedOrigin === 'string') {\n        return allowedOrigin === origin;\n      } else if (allowedOrigin instanceof RegExp) {\n        return allowedOrigin.test(origin);\n      }\n      return false;\n    });\n\n    if (isAllowed) {\n      callback(null, true);\n    } else {\n      logger.warn(`CORS: Origem bloqueada: ${origin}`);\n      callback(new Error('Não permitido pelo CORS'), false);\n    }\n  },\n\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'],\n\n  allowedHeaders: [\n    'Origin',\n    'X-Requested-With',\n    'Content-Type',\n    'Accept',\n    'Authorization',\n    'X-CSRF-Token',\n    'X-API-Key',\n    'X-Client-Version',\n    'X-Platform',\n    'Cache-Control',\n    'Pragma'\n  ],\n\n  exposedHeaders: [\n    'X-Total-Count',\n    'X-Page-Count',\n    'X-Current-Page',\n    'X-Per-Page',\n    'X-Rate-Limit-Limit',\n    'X-Rate-Limit-Remaining',\n    'X-Rate-Limit-Reset'\n  ],\n\n  credentials: true, // Permitir cookies\n  maxAge: 86400, // Cache preflight por 24 horas\n  optionsSuccessStatus: 200 // Para browsers legados\n};\n\n/**\n * Middleware CORS customizado para Cloudflare Workers\n */\nexport const corsMiddleware = request => {\n  const origin = request.headers.get('Origin');\n\n  const allowedOrigins = getAllowedOriginsForEnv();\n\n  const isAllowed = !origin || allowedOrigins.includes(origin);\n\n  // Headers CORS\n  const corsHeaders = {\n    'Access-Control-Allow-Origin': isAllowed ? origin : 'https://agroisync.com',\n    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With, X-CSRF-Token',\n    'Access-Control-Allow-Credentials': 'true',\n    'Access-Control-Max-Age': '86400'\n  };\n\n  // Responder a OPTIONS preflight\n  if (request.method === 'OPTIONS') {\n    return new Response(null, {\n      status: 200,\n      headers: corsHeaders\n    });\n  }\n\n  return { corsHeaders, isAllowed };\n};\n\n/**\n * Middleware para adicionar headers de seguranÃ§a\n */\nexport const securityHeaders = (req, res, next) => {\n  // Headers de seguranÃ§a\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n\n  // Content Security Policy\n  res.setHeader(\n    'Content-Security-Policy',\n    [\n      \"default-src 'self'\",\n      \"script-src 'self' 'unsafe-inline' 'unsafe-eval' https://js.stripe.com https://challenges.cloudflare.com\",\n      \"style-src 'self' 'unsafe-inline' https://fonts.googleapis.com\",\n      \"font-src 'self' https://fonts.gstatic.com\",\n      \"img-src 'self' data: https: blob:\",\n      \"connect-src 'self' https://api.stripe.com https://api.cloudflare.com wss: ws:\",\n      'frame-src https://js.stripe.com https://challenges.cloudflare.com',\n      \"object-src 'none'\",\n      \"base-uri 'self'\",\n      \"form-action 'self'\",\n      \"frame-ancestors 'none'\"\n    ].join('; ')\n  );\n\n  next();\n};\n\nexport default {\n  corsOptions,\n  corsMiddleware,\n  securityHeaders\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\csp.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\csrf.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\d1Validation.js","messages":[{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":39,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":39,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":82,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":82,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿// =============================================================\n// AGROISYNC â€¢ Middleware de ValidaÃ§Ã£o D1 Database\n// =============================================================\n\nimport logger from '../utils/logger.js';\n\n/**\n * Middleware para validar conexÃ£o com D1 Database\n */\nexport const validateD1Connection = (req, res, next) => {\n  try {\n    // Verificar se req.db estÃ¡ disponÃ­vel\n    if (!req.db) {\n      logger.error('D1 Database nÃ£o disponÃ­vel no request');\n      return res.status(503).json({\n        success: false,\n        error: 'Database nÃ£o disponÃ­vel',\n        code: 'DB_UNAVAILABLE'\n      });\n    }\n\n    // Verificar se req.db tem mÃ©todos necessÃ¡rios\n    const requiredMethods = ['prepare', 'batch', 'exec'];\n    const missingMethods = requiredMethods.filter(method => typeof req.db[method] !== 'function');\n\n    if (missingMethods.length > 0) {\n      logger.error(`MÃ©todos D1 ausentes: ${missingMethods.join(', ')}`);\n      return res.status(503).json({\n        success: false,\n        error: 'Database interface incompleta',\n        code: 'DB_INTERFACE_ERROR',\n        missingMethods\n      });\n    }\n\n    // Adicionar timestamp para debug\n    req.dbTimestamp = Date.now();\n\n    next();\n  } catch (error) {\n    logger.error('Erro na validaÃ§Ã£o D1:', error);\n    return res.status(500).json({\n      success: false,\n      error: 'Erro interno na validaÃ§Ã£o do database',\n      code: 'DB_VALIDATION_ERROR'\n    });\n  }\n};\n\n/**\n * Middleware para testar conexÃ£o D1 com query simples\n */\nexport const testD1Connection = async (req, res, next) => {\n  try {\n    if (!req.db) {\n      return res.status(503).json({\n        success: false,\n        error: 'Database nÃ£o disponÃ­vel',\n        code: 'DB_UNAVAILABLE'\n      });\n    }\n\n    // Executar query de teste simples\n    const result = await req.db.prepare('SELECT 1 as test').first();\n\n    if (!result || result.test !== 1) {\n      logger.error('Teste D1 falhou - resultado invÃ¡lido');\n      return res.status(503).json({\n        success: false,\n        error: 'Database nÃ£o responde corretamente',\n        code: 'DB_TEST_FAILED'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes de performance\n    req.dbInfo = {\n      connected: true,\n      timestamp: Date.now()\n    };\n\n    logger.info('D1 Database conectado');\n    next();\n  } catch (error) {\n    logger.error('Erro no teste D1:', error);\n    return res.status(503).json({\n      success: false,\n      error: 'Database nÃ£o acessÃ­vel',\n      code: 'DB_CONNECTION_ERROR',\n      details: error.message\n    });\n  }\n};\n\n/**\n * Health check especÃ­fico para D1\n */\nexport const d1HealthCheck = async (req, res) => {\n  try {\n    if (!req.db) {\n      return res.status(503).json({\n        success: false,\n        status: 'unhealthy',\n        error: 'Database nÃ£o disponÃ­vel',\n        timestamp: Date.now()\n      });\n    }\n\n    // Teste bÃ¡sico de conectividade\n    await req.db.prepare('SELECT 1').first();\n\n    // Teste de tabelas crÃ­ticas\n    const tables = await req.db\n      .prepare(\n        `\n      SELECT name FROM sqlite_master \n      WHERE type='table' AND name NOT LIKE 'sqlite_%'\n    `\n      )\n      .all();\n\n    const criticalTables = ['users', 'products', 'freights'];\n    const availableTables = tables.map(t => t.name);\n    const missingTables = criticalTables.filter(t => !availableTables.includes(t));\n\n    const status = missingTables.length === 0 ? 'healthy' : 'degraded';\n\n    return res.status(200).json({\n      success: true,\n      status,\n      tables: {\n        total: tables.length,\n        available: availableTables,\n        missing: missingTables\n      },\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    logger.error('Health check D1 falhou:', error);\n    return res.status(503).json({\n      success: false,\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: Date.now()\n    });\n  }\n};\n\nexport default {\n  validateD1Connection,\n  testD1Connection,\n  d1HealthCheck\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\database.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\documentValidation.js","messages":[],"suppressedMessages":[{"ruleId":"require-await","severity":1,"message":"Async function 'validateWithReceitaFederal' has no 'await' expression.","line":157,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":157,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\logging.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\metamaskAuth.js","messages":[{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":50,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":50,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":92,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":92,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":95,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":95,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿const logger = require('../utils/logger');\n\n/**\n * Middleware para validar a ID da Metamask nas requisiÃ§Ãµes\n * Este middleware verifica se o header 'x-metamask-id' estÃ¡ presente\n * e se corresponde ao ID autorizado\n */\nconst validateMetamaskId = (req, res, next) => {\n  try {\n    // Obter a ID da Metamask do header\n    const metamaskId = req.headers['x-metamask-id'];\n\n    // ID da Metamask autorizada (deve ser configurada via variÃ¡vel de ambiente)\n    const authorizedMetamaskId =\n      process.env.METAMASK_ID || '0x5Ea5C5970e8AE23A5336d631707CF31C5916E8b1';\n\n    // Verificar se o header estÃ¡ presente\n    if (!metamaskId) {\n      logger.warn(`RequisiÃ§Ã£o sem Metamask ID: ${req.method} ${req.originalUrl} - IP: ${req.ip}`);\n\n      return res.status(401).json({\n        success: false,\n        error: 'Metamask ID nÃ£o fornecido',\n        message: 'Header x-metamask-id Ã© obrigatÃ³rio para autenticaÃ§Ã£o'\n      });\n    }\n\n    // Verificar se a ID corresponde Ã  autorizada\n    if (metamaskId !== authorizedMetamaskId) {\n      logger.warn(\n        `Tentativa de acesso com Metamask ID invÃ¡lido: ${metamaskId} - IP: ${req.ip} - URL: ${req.originalUrl}`\n      );\n\n      return res.status(403).json({\n        success: false,\n        error: 'Metamask ID invÃ¡lido',\n        message: 'ID da Metamask nÃ£o autorizado para acessar este recurso'\n      });\n    }\n\n    // ID vÃ¡lida, continuar\n    logger.info(\n      `RequisiÃ§Ã£o autenticada com Metamask ID: ${metamaskId} - ${req.method} ${req.originalUrl}`\n    );\n\n    // Adicionar informaÃ§Ãµes da Metamask ao request para uso posterior\n    req.metamaskId = metamaskId;\n    req.isAuthenticated = true;\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de validaÃ§Ã£o da Metamask ID:', error);\n\n    return res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor durante validaÃ§Ã£o da Metamask ID'\n    });\n  }\n};\n\n/**\n * Middleware opcional para validar a ID da Metamask\n * NÃ£o falha se a ID nÃ£o estiver presente, mas valida se estiver\n */\nconst optionalMetamaskAuth = (req, res, next) => {\n  try {\n    const metamaskId = req.headers['x-metamask-id'];\n    const authorizedMetamaskId =\n      process.env.METAMASK_ID || '0x5Ea5C5970e8AE23A5336d631707CF31C5916E8b1';\n\n    if (metamaskId) {\n      if (metamaskId !== authorizedMetamaskId) {\n        logger.warn(\n          `Metamask ID invÃ¡lido em requisiÃ§Ã£o opcional: ${metamaskId} - IP: ${req.ip}`\n        );\n\n        return res.status(403).json({\n          success: false,\n          error: 'Metamask ID invÃ¡lido',\n          message: 'ID da Metamask nÃ£o autorizado'\n        });\n      }\n\n      req.metamaskId = metamaskId;\n      req.isAuthenticated = true;\n      logger.info(`RequisiÃ§Ã£o opcional autenticada com Metamask ID: ${metamaskId}`);\n    } else {\n      req.isAuthenticated = false;\n      logger.info('RequisiÃ§Ã£o sem autenticaÃ§Ã£o Metamask (opcional)');\n    }\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware opcional de validaÃ§Ã£o da Metamask ID:', error);\n    next();\n  }\n};\n\n/**\n * Middleware para registrar tentativas de acesso\n */\nconst logMetamaskAccess = (req, res, next) => {\n  const metamaskId = req.headers['x-metamask-id'];\n  const ip = req.ip || req.connection.remoteAddress;\n  const userAgent = req.get('User-Agent');\n  const timestamp = new Date().toISOString();\n\n  logger.info(\n    `Tentativa de acesso - Metamask ID: ${metamaskId || 'N/A'} - IP: ${ip} - User-Agent: ${userAgent} - Timestamp: ${timestamp}`\n  );\n\n  next();\n};\n\nmodule.exports = {\n  validateMetamaskId,\n  optionalMetamaskAuth,\n  logMetamaskAccess\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\notFound.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\notificationTriggers.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":10,"column":60,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":10,"endColumn":62},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":34,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":34,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":37,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":37,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":42,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":42,"endColumn":58},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":61,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":61,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":64,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":64,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":69,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":69,"endColumn":60},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":92,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":92,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":95,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":95,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":100,"column":61,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":100,"endColumn":63},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":119,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":119,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":122,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":122,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":127,"column":59,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":127,"endColumn":61},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":146,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":146,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":149,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":149,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":154,"column":53,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":154,"endColumn":55},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":178,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":178,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":181,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":181,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":186,"column":66,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":186,"endColumn":68},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":205,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":205,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":208,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":208,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":213,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":213,"endColumn":60},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":217,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":217,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":220,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":220,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":225,"column":47,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":225,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import notificationService from '../services/notificationService.js';\nimport logger from '../utils/logger.js';\n\n/**\n * Middleware para disparar notificaÃ§Ãµes automÃ¡ticas\n * Este middleware deve ser usado apÃ³s operaÃ§Ãµes que geram eventos\n */\n\n// Middleware para notificar nova transaÃ§Ã£o\nexport const notifyNewTransaction = async (req, res, next) => {\n  try {\n    // Salvar a resposta original\n    const originalJson = res.json;\n\n    // Sobrescrever o mÃ©todo json para interceptar a resposta\n    res.json = function (data) {\n      // Se a transaÃ§Ã£o foi criada com sucesso, disparar notificaÃ§Ã£o\n      if (data.success && data.data && data.data._id) {\n        // Disparar notificaÃ§Ã£o de forma assÃ­ncrona (nÃ£o bloquear a resposta)\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyNewTransaction(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de nova transaÃ§Ã£o:', error);\n          }\n        });\n      }\n\n      // Restaurar o mÃ©todo original e chamar\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de transaÃ§Ã£o:', error);\n    next();\n  }\n};\n\n// Middleware para notificar nova mensagem\nexport const notifyNewMessage = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data._id) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyNewMessage(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de nova mensagem:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de mensagem:', error);\n    next();\n  }\n};\n\n// Middleware para notificar mudanÃ§a de status\nexport const notifyStatusChange = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.oldStatus && data.data.newStatus) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyStatusChange(\n              data.data.transaction,\n              data.data.oldStatus,\n              data.data.newStatus\n            );\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de mudanÃ§a de status:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de mudanÃ§a de status:', error);\n    next();\n  }\n};\n\n// Middleware para notificar pagamento recebido\nexport const notifyPaymentReceived = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.status === 'COMPLETED') {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyPaymentReceived(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de pagamento recebido:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de pagamento:', error);\n    next();\n  }\n};\n\n// Middleware para notificar falha no pagamento\nexport const notifyPaymentFailed = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.status === 'FAILED') {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyPaymentFailed(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de falha no pagamento:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de falha no pagamento:', error);\n    next();\n  }\n};\n\n// Middleware para notificar boas-vindas (apÃ³s registro)\nexport const notifyWelcome = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (\n        data.success &&\n        data.data &&\n        data.data.user &&\n        data.data.requiresEmailVerification === false\n      ) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyWelcome(data.data.user);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de boas-vindas:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de boas-vindas:', error);\n    next();\n  }\n};\n\n// Middleware para notificar verificaÃ§Ã£o necessÃ¡ria\nexport const notifyVerificationRequired = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.requiresEmailVerification === true) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyVerificationRequired(data.data.user, 'email');\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de verificaÃ§Ã£o necessÃ¡ria:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de verificaÃ§Ã£o necessÃ¡ria:', error);\n    next();\n  }\n};\n\n// Middleware para verificar planos expirando (executar periodicamente)\nexport const checkExpiringPlans = async (req, res, next) => {\n  try {\n    // Este middleware pode ser usado para verificar planos expirando\n    // em rotas especÃ­ficas ou executado periodicamente\n    next();\n  } catch (error) {\n    logger.error('Erro ao verificar planos expirando:', error);\n    next();\n  }\n};\n\n// FunÃ§Ã£o para verificar planos expirando (executar via cron job)\nexport const checkExpiringPlansJob = async () => {\n  try {\n    // Esta funÃ§Ã£o deve ser executada diariamente via cron job\n    // para verificar usuÃ¡rios com planos expirando\n    if (process.env.NODE_ENV !== 'production') {\n      logger.info('Verificando planos expirando...');\n    }\n    // Implementar lÃ³gica para buscar usuÃ¡rios com planos expirando\n    // e disparar notificaÃ§Ãµes apropriadas\n  } catch (error) {\n    logger.error('Erro ao verificar planos expirando:', error);\n  }\n};\n\nexport default {\n  notifyNewTransaction,\n  notifyNewMessage,\n  notifyStatusChange,\n  notifyPaymentReceived,\n  notifyPaymentFailed,\n  notifyWelcome,\n  notifyVerificationRequired,\n  checkExpiringPlans,\n  checkExpiringPlansJob\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\privacyMiddleware.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":15,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":15,"endColumn":58},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":41,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":41,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":46,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":46,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":88,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":88,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":125,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":125,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import { createAuditLog } from '../utils/securityLogger.js';\nimport User from '../models/User.js';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport Message from '../models/Message.js';\nimport Transaction from '../models/Transaction.js';\nimport Payment from '../models/Payment.js';\n\nimport logger from '../utils/logger.js';\n// ===== MIDDLEWARE DE PRIVACIDADE LGPD =====\n\n/**\n * Middleware para verificar consentimento LGPD\n */\nexport const checkGDPRConsent = async (req, res, next) => {\n  try {\n    if (!req.user) {\n      return next();\n    }\n\n    // Verificar se usuÃ¡rio deu consentimento LGPD\n    if (!req.user.gdprConsent) {\n      return res.status(403).json({\n        success: false,\n        message: 'Consentimento LGPD necessÃ¡rio para continuar',\n        requiresConsent: true,\n        consentUrl: '/privacy/consent'\n      });\n    }\n\n    // Verificar se consentimento nÃ£o expirou\n    if (req.user.gdprConsentExpiry && new Date() > new Date(req.user.gdprConsentExpiry)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Consentimento LGPD expirado. Renove seu consentimento.',\n        requiresConsent: true,\n        consentUrl: '/privacy/consent'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na verificaÃ§Ã£o LGPD:', error);\n    }\n    next();\n  }\n};\n\n/**\n * Middleware para registrar consentimento LGPD\n */\nexport const recordGDPRConsent = async (req, res, next) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o autenticado'\n      });\n    }\n\n    const { consent, preferences } = req.body;\n\n    if (!consent) {\n      return res.status(400).json({\n        success: false,\n        message: 'Consentimento Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Atualizar usuÃ¡rio com consentimento\n    const user = await User.findById(req.user.userId);\n    user.gdprConsent = consent;\n    user.gdprConsentDate = new Date();\n    user.gdprConsentExpiry = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // 1 ano\n    user.gdprPreferences = preferences || {};\n\n    await user.save();\n\n    // Log do consentimento\n    await createAuditLog('GDPR_CONSENT_GIVEN', 'user_privacy', req, req.user.userId, {\n      consent,\n      preferences,\n      ipAddress: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao registrar consentimento LGPD:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao registrar consentimento'\n    });\n  }\n};\n\n/**\n * Middleware para verificar se dados podem ser processados\n */\nexport const canProcessData = dataType => {\n  return async (req, res, next) => {\n    try {\n      if (!req.user) {\n        return res.status(401).json({\n          success: false,\n          message: 'UsuÃ¡rio nÃ£o autenticado'\n        });\n      }\n\n      const user = await User.findById(req.user.userId);\n\n      // Verificar se usuÃ¡rio deu consentimento para o tipo de dado\n      if (!user.gdprConsent || !user.gdprPreferences[dataType]) {\n        return res.status(403).json({\n          success: false,\n          message: `Consentimento necessÃ¡rio para processamento de ${dataType}`,\n          requiresConsent: true,\n          dataType\n        });\n      }\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro na verificaÃ§Ã£o de processamento de dados:', error);\n      }\n      return res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  };\n};\n\n// ===== FUNÃ‡Ã•ES DE EXPORTAÃ‡ÃƒO DE DADOS =====\n\n/**\n * Exportar dados do usuÃ¡rio (Direito de Portabilidade)\n */\nexport const exportUserData = async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar todos os dados do usuÃ¡rio\n    const user = await User.findById(userId).select('-password -resetToken -resetTokenExpiry');\n    const products = await Product.find({ seller: userId });\n    const freights = await Freight.find({ carrier: userId });\n    const messages = await Message.find({\n      $or: [{ sender: userId }, { recipient: userId }]\n    });\n    const transactions = await Transaction.find({\n      $or: [{ buyer: userId }, { seller: userId }]\n    });\n    const payments = await Payment.find({ userId });\n\n    // Estruturar dados para exportaÃ§Ã£o\n    const exportData = {\n      user: {\n        profile: {\n          email: user.email,\n          name: user.name,\n          phone: user.phone,\n          cpf: user.cpf,\n          cnpj: user.cnpj,\n          role: user.role,\n          createdAt: user.createdAt,\n          lastLogin: user.lastLogin\n        },\n        preferences: user.preferences,\n        gdprConsent: {\n          consent: user.gdprConsent,\n          date: user.gdprConsentDate,\n          preferences: user.gdprPreferences\n        }\n      },\n      products: products.map(p => ({\n        id: p._id,\n        name: p.name,\n        description: p.description,\n        price: p.price,\n        category: p.category,\n        location: p.location,\n        createdAt: p.createdAt,\n        status: p.status\n      })),\n      freights: freights.map(f => ({\n        id: f._id,\n        origin: f.origin,\n        destination: f.destination,\n        price: f.price,\n        vehicle: f.vehicle,\n        createdAt: f.createdAt,\n        status: f.status\n      })),\n      messages: messages.map(m => ({\n        id: m._id,\n        content: m.content,\n        sender: m.sender,\n        recipient: m.recipient,\n        timestamp: m.timestamp,\n        read: m.read\n      })),\n      transactions: transactions.map(t => ({\n        id: t._id,\n        product: t.product,\n        buyer: t.buyer,\n        seller: t.seller,\n        amount: t.amount,\n        status: t.status,\n        createdAt: t.createdAt\n      })),\n      payments: payments.map(p => ({\n        id: p._id,\n        amount: p.amount,\n        method: p.method,\n        status: p.status,\n        createdAt: p.createdAt\n      })),\n      exportInfo: {\n        exportedAt: new Date(),\n        dataTypes: ['profile', 'products', 'freights', 'messages', 'transactions', 'payments'],\n        format: 'JSON',\n        version: '1.0'\n      }\n    };\n\n    // Log da exportaÃ§Ã£o\n    await createAuditLog('DATA_EXPORT_REQUESTED', 'user_data', req, userId, {\n      dataTypes: exportData.exportInfo.dataTypes,\n      exportFormat: 'JSON'\n    });\n\n    res.json({\n      success: true,\n      message: 'Dados exportados com sucesso',\n      data: exportData\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na exportaÃ§Ã£o de dados:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao exportar dados'\n    });\n  }\n};\n\n/**\n * Excluir dados do usuÃ¡rio (Direito ao Esquecimento)\n */\nexport const deleteUserData = async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { dataTypes, reason } = req.body;\n\n    if (!dataTypes || !Array.isArray(dataTypes)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipos de dados para exclusÃ£o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    if (!reason || reason.trim().length < 10) {\n      return res.status(400).json({\n        success: false,\n        message: 'Motivo da exclusÃ£o deve ter pelo menos 10 caracteres'\n      });\n    }\n\n    const deletionResults = {};\n\n    // Excluir produtos\n    if (dataTypes.includes('products')) {\n      const result = await Product.deleteMany({ seller: userId });\n      deletionResults.products = result.deletedCount;\n    }\n\n    // Excluir fretes\n    if (dataTypes.includes('freights')) {\n      const result = await Freight.deleteMany({ carrier: userId });\n      deletionResults.freights = result.deletedCount;\n    }\n\n    // Excluir mensagens\n    if (dataTypes.includes('messages')) {\n      const result = await Message.deleteMany({\n        $or: [{ sender: userId }, { recipient: userId }]\n      });\n      deletionResults.messages = result.deletedCount;\n    }\n\n    // Excluir transaÃ§Ãµes\n    if (dataTypes.includes('transactions')) {\n      const result = await Transaction.deleteMany({\n        $or: [{ buyer: userId }, { seller: userId }]\n      });\n      deletionResults.transactions = result.deletedCount;\n    }\n\n    // Excluir pagamentos\n    if (dataTypes.includes('payments')) {\n      const result = await Payment.deleteMany({ userId });\n      deletionResults.payments = result.deletedCount;\n    }\n\n    // Anonimizar perfil se solicitado\n    if (dataTypes.includes('profile')) {\n      await User.findByIdAndUpdate(userId, {\n        name: '[REMOVIDO]',\n        email: `removed_${Date.now()}@deleted.com`,\n        phone: '[REMOVIDO]',\n        cpf: '[REMOVIDO]',\n        cnpj: '[REMOVIDO]',\n        isActive: false,\n        gdprConsent: false,\n        dataDeletedAt: new Date(),\n        deletionReason: reason\n      });\n      deletionResults.profile = 'anonymized';\n    }\n\n    // Log da exclusÃ£o\n    await createAuditLog('DATA_DELETION_REQUESTED', 'user_data', req, userId, {\n      dataTypes,\n      reason,\n      deletionResults,\n      ipAddress: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'Dados excluÃ­dos com sucesso',\n      deletionResults,\n      dataTypes\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na exclusÃ£o de dados:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao excluir dados'\n    });\n  }\n};\n\n/**\n * Obter status de privacidade do usuÃ¡rio\n */\nexport const getPrivacyStatus = async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const user = await User.findById(userId).select(\n      'gdprConsent gdprConsentDate gdprConsentExpiry gdprPreferences dataDeletedAt'\n    );\n\n    const privacyStatus = {\n      hasConsent: !!user.gdprConsent,\n      consentDate: user.gdprConsentDate,\n      consentExpiry: user.gdprConsentExpiry,\n      preferences: user.gdprPreferences || {},\n      isDataDeleted: !!user.dataDeletedAt,\n      dataDeletedAt: user.dataDeletedAt,\n      rights: {\n        rightToAccess: true,\n        rightToPortability: true,\n        rightToRectification: true,\n        rightToErasure: true,\n        rightToRestriction: true,\n        rightToObject: true\n      }\n    };\n\n    res.json({\n      success: true,\n      privacyStatus\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter status de privacidade:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao obter status de privacidade'\n    });\n  }\n};\n\n/**\n * Atualizar preferÃªncias de privacidade\n */\nexport const updatePrivacyPreferences = async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { preferences } = req.body;\n\n    if (!preferences || typeof preferences !== 'object') {\n      return res.status(400).json({\n        success: false,\n        message: 'PreferÃªncias de privacidade sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    // Validar preferÃªncias\n    const validPreferences = [\n      'marketing_emails',\n      'push_notifications',\n      'sms_notifications',\n      'data_sharing',\n      'analytics_tracking',\n      'third_party_cookies'\n    ];\n\n    const validatedPreferences = {};\n    validPreferences.forEach(pref => {\n      if (Object.prototype.hasOwnProperty.call(preferences, pref)) {\n        validatedPreferences[pref] = !!preferences[pref];\n      }\n    });\n\n    // Atualizar usuÃ¡rio\n    await User.findByIdAndUpdate(userId, {\n      gdprPreferences: validatedPreferences,\n      gdprConsentDate: new Date()\n    });\n\n    // Log da atualizaÃ§Ã£o\n    await createAuditLog('PRIVACY_PREFERENCES_UPDATED', 'user_privacy', req, userId, {\n      preferences: validatedPreferences\n    });\n\n    res.json({\n      success: true,\n      message: 'PreferÃªncias de privacidade atualizadas',\n      preferences: validatedPreferences\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao atualizar preferÃªncias de privacidade:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao atualizar preferÃªncias'\n    });\n  }\n};\n\nexport default {\n  checkGDPRConsent,\n  recordGDPRConsent,\n  canProcessData,\n  exportUserData,\n  deleteUserData,\n  getPrivacyStatus,\n  updatePrivacyPreferences\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\rateLimit.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":186,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":186,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿const rateLimit = require('express-rate-limit');\n\n/**\n * Middleware de rate limiting configurÃ¡vel\n * @param {Object} options - OpÃ§Ãµes de configuraÃ§Ã£o\n * @param {number} options.windowMs - Janela de tempo em milissegundos\n * @param {number} options.max - MÃ¡ximo de requests por janela\n * @param {string} options.message - Mensagem de erro personalizada\n * @param {boolean} options.standardHeaders - Incluir headers padrÃ£o\n * @param {boolean} options.legacyHeaders - Incluir headers legados\n * @returns {Function} Middleware de rate limiting\n */\nconst createRateLimit = (options = {}) => {\n  const defaultOptions = {\n    windowMs: 15 * 60 * 1000, // 15 minutos por padrÃ£o\n    max: 100, // 100 requests por padrÃ£o\n    message: {\n      success: false,\n      message: 'Muitas requisiÃ§Ãµes. Tente novamente mais tarde.',\n      retryAfter: Math.ceil(options.windowMs / 1000)\n    },\n    standardHeaders: true, // Retorna `RateLimit-*` headers\n    legacyHeaders: false, // Retorna `X-RateLimit-*` headers\n    handler: (req, res) => {\n      res.status(429).json(\n        options.message || {\n          success: false,\n          message: 'Muitas requisiÃ§Ãµes. Tente novamente mais tarde.'\n        }\n      );\n    },\n    skip: req => {\n      // Pular rate limiting para IPs locais em desenvolvimento\n      if (process.env.NODE_ENV === 'development') {\n        const localIPs = ['127.0.0.1', '::1', 'localhost'];\n        return localIPs.includes(req.ip);\n      }\n      return false;\n    },\n    keyGenerator: req => {\n      // Usar IP do cliente ou user ID se autenticado\n      return req.user ? req.user.userId : req.ip;\n    }\n  };\n\n  return rateLimit({ ...defaultOptions, ...options });\n};\n\n// Rate limiters prÃ©-configurados para diferentes cenÃ¡rios\n\n/**\n * Rate limiter para APIs pÃºblicas (mais permissivo)\n */\nconst publicAPILimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 200, // 200 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes atingido para APIs pÃºblicas. Tente novamente em 15 minutos.'\n  }\n});\n\n/**\n * Rate limiter para autenticaÃ§Ã£o (mais restritivo)\n */\nconst authLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 10, // 10 tentativas de login por 15 minutos\n  message: {\n    success: false,\n    message: 'Muitas tentativas de login. Tente novamente em 15 minutos.',\n    security: 'Sua conta pode ser temporariamente bloqueada por seguranÃ§a.'\n  }\n});\n\n/**\n * Rate limiter para pagamentos (muito restritivo)\n */\nconst paymentLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 5, // 5 tentativas de pagamento por 15 minutos\n  message: {\n    success: false,\n    message: 'Muitas tentativas de pagamento. Tente novamente em 15 minutos.',\n    security: 'Por seguranÃ§a, suas tentativas de pagamento foram limitadas.'\n  }\n});\n\n/**\n * Rate limiter para uploads de arquivos\n */\nconst uploadLimiter = createRateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hora\n  max: 20, // 20 uploads por hora\n  message: {\n    success: false,\n    message: 'Limite de uploads atingido. Tente novamente em 1 hora.'\n  }\n});\n\n/**\n * Rate limiter para mensagens (moderado)\n */\nconst messagingLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 50, // 50 mensagens por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de mensagens atingido. Tente novamente em 15 minutos.'\n  }\n});\n\n/**\n * Rate limiter para busca e consultas (moderado)\n */\nconst searchLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 100, // 100 buscas por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de buscas atingido. Tente novamente em 15 minutos.'\n  }\n});\n\n/**\n * Rate limiter para webhooks (muito permissivo para serviÃ§os externos)\n */\nconst webhookLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 1000, // 1000 webhooks por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de webhooks atingido.'\n  },\n  skip: req => {\n    // Pular rate limiting para webhooks de serviÃ§os confiÃ¡veis\n    const trustedWebhooks = ['stripe.com', 'github.com', 'gitlab.com', 'bitbucket.org'];\n\n    const origin = req.get('Origin') || req.get('User-Agent') || '';\n    return trustedWebhooks.some(trusted => origin.includes(trusted));\n  }\n});\n\n/**\n * Rate limiter para admin (muito permissivo)\n */\nconst adminLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 500, // 500 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes admin atingido.'\n  },\n  skip: req => {\n    // Pular rate limiting para usuÃ¡rios admin\n    return req.user && req.user.role === 'admin';\n  }\n});\n\n/**\n * Rate limiter para usuÃ¡rios premium (mais permissivo)\n */\nconst premiumLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 300, // 300 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes atingido para usuÃ¡rios premium.'\n  },\n  skip: req => {\n    // Pular rate limiting para usuÃ¡rios premium\n    return req.user && req.user.isPaid && req.user.planActive;\n  }\n});\n\n/**\n * Rate limiter para desenvolvimento (muito permissivo)\n */\nconst devLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 1000, // 1000 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes atingido em desenvolvimento.'\n  },\n  skip: req => {\n    // Pular rate limiting em desenvolvimento\n    return process.env.NODE_ENV === 'development';\n  }\n});\n\n/**\n * Rate limiter personalizado baseado em headers especÃ­ficos\n */\nconst headerBasedLimiter = (headerName, maxRequests) => {\n  return createRateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutos\n    max: maxRequests,\n    keyGenerator: req => {\n      return req.get(headerName) || req.ip;\n    },\n    message: {\n      success: false,\n      message: `Limite de requisiÃ§Ãµes atingido para ${headerName}.`\n    }\n  });\n};\n\n/**\n * Rate limiter para diferentes tipos de usuÃ¡rio\n */\nconst userTypeLimiter = {\n  guest: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 50,\n    message: {\n      success: false,\n      message:\n        'Limite de requisiÃ§Ãµes para visitantes atingido. FaÃ§a login para aumentar o limite.'\n    }\n  }),\n\n  basic: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 150,\n    message: {\n      success: false,\n      message: 'Limite de requisiÃ§Ãµes para usuÃ¡rios bÃ¡sicos atingido.'\n    }\n  }),\n\n  premium: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 300,\n    message: {\n      success: false,\n      message: 'Limite de requisiÃ§Ãµes para usuÃ¡rios premium atingido.'\n    }\n  }),\n\n  admin: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 500,\n    message: {\n      success: false,\n      message: 'Limite de requisiÃ§Ãµes para administradores atingido.'\n    }\n  })\n};\n\n/**\n * FunÃ§Ã£o para aplicar rate limiting baseado no tipo de usuÃ¡rio\n */\nconst applyUserTypeLimiting = (req, res, next) => {\n  let limiter;\n\n  if (!req.user) {\n    limiter = userTypeLimiter.guest;\n  } else if (req.user.role === 'admin') {\n    limiter = userTypeLimiter.admin;\n  } else if (req.user.isPaid && req.user.planActive) {\n    limiter = userTypeLimiter.premium;\n  } else {\n    limiter = userTypeLimiter.basic;\n  }\n\n  limiter(req, res, next);\n};\n\nmodule.exports = {\n  createRateLimit,\n  publicAPILimiter,\n  authLimiter,\n  paymentLimiter,\n  uploadLimiter,\n  messagingLimiter,\n  searchLimiter,\n  webhookLimiter,\n  adminLimiter,\n  premiumLimiter,\n  devLimiter,\n  headerBasedLimiter,\n  userTypeLimiter,\n  applyUserTypeLimiting\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\rateLimiter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\requirePaidAccess.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'createSecurityLog' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":27},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":74,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":74,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import User from '../models/User.js';\nimport AuditLog from '../models/AuditLog.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para verificar se o usuÃ¡rio tem acesso pago\nconst requirePaidAccess = serviceType => {\n  return async (req, res, next) => {\n    try {\n      const userId = req.user.id;\n\n      // Verificar se o usuÃ¡rio existe\n      const user = await User.findById(userId);\n      if (!user) {\n        return res.status(404).json({\n          success: false,\n          message: 'UsuÃ¡rio nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se tem plano ativo\n      const hasActivePlan =\n        user.subscriptions &&\n        ((user.subscriptions.store && user.subscriptions.store.status === 'active') ||\n          (user.subscriptions.agroconecta && user.subscriptions.agroconecta.status === 'active'));\n\n      // Verificar se tem pagamento recente (Ãºltimos 30 dias)\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const recentPayment =\n        user.payments &&\n        user.payments.some(\n          payment => payment.status === 'completed' && new Date(payment.createdAt) >= thirtyDaysAgo\n        );\n\n      if (!hasActivePlan && !recentPayment) {\n        // Log da tentativa de acesso sem pagamento\n        await AuditLog.logAction({\n          userId,\n          userEmail: user.email,\n          action: 'PAID_ACCESS_DENIED',\n          resource: req.originalUrl,\n          details: `Attempted to access ${serviceType} without paid access`,\n          ip: req.ip,\n          userAgent: req.get('User-Agent'),\n          isSuspicious: false,\n          riskLevel: 'LOW'\n        });\n\n        return res.status(403).json({\n          success: false,\n          message: 'ðŸ”’ Para acessar este serviÃ§o, finalize o pagamento de sua assinatura.',\n          requiresPayment: true,\n          plans: {\n            store: 'R$25/mÃªs - Mensageria de Produtos',\n            agroconecta: 'R$50/mÃªs - Mensageria de Fretes'\n          }\n        });\n      }\n\n      // Log do acesso bem-sucedido\n      await AuditLog.logAction({\n        userId,\n        userEmail: user.email,\n        action: 'PAID_ACCESS_GRANTED',\n        resource: req.originalUrl,\n        details: `Accessed ${serviceType} with paid access`,\n        ip: req.ip,\n        userAgent: req.get('User-Agent')\n      });\n\n      req.userHasPaidAccess = true;\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao verificar acesso pago:', error);\n      }\n      // Log do erro\n      await AuditLog.logAction({\n        userId: req.user?.id || 'unknown',\n        userEmail: req.user?.email || 'unknown',\n        action: 'PAID_ACCESS_ERROR',\n        resource: req.originalUrl,\n        details: `Error checking paid access: ${error.message}`,\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        isSuspicious: false,\n        riskLevel: 'LOW'\n      });\n\n      return res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  };\n};\n\n// Middleware especÃ­fico para mensageria de produtos\nconst requireProductMessagingAccess = requirePaidAccess('product_messaging');\n\n// Middleware especÃ­fico para mensageria de fretes\nconst requireFreightMessagingAccess = requirePaidAccess('freight_messaging');\n\n// Middleware para serviÃ§os premium\nconst requireServiceAccess = requirePaidAccess('premium_service');\n\nexport {\n  requirePaidAccess,\n  requireProductMessagingAccess,\n  requireFreightMessagingAccess,\n  requireServiceAccess\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\security.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'express' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'body' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":14},{"ruleId":"no-unused-vars","severity":1,"message":"'validationResult' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":32},{"ruleId":"no-unused-vars","severity":1,"message":"'AuditLog' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":18},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":232,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":232,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":237,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":237,"endColumn":11},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":246,"column":27,"nodeType":"CallExpression","messageId":"missingRadix","endLine":246,"endColumn":73,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[6611,6611],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":283,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":283,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":314,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":314,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":319,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":319,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":351,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":351,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":356,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":356,"endColumn":11},{"ruleId":"no-unused-vars","severity":1,"message":"'payload' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":401,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":401,"endColumn":18},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":414,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":414,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":449,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":449,"endColumn":11},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":479,"column":5,"nodeType":"CallExpression","messageId":"missingReturn","endLine":479,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport rateLimit from 'express-rate-limit';\nimport helmet from 'helmet';\nimport xss from 'xss-clean';\nimport hpp from 'hpp';\nimport mongoSanitize from 'express-mongo-sanitize';\nimport cors from 'cors';\nimport { body, validationResult } from 'express-validator';\nimport { AuditLog } from '../models/AuditLog.js';\nimport { SecurityLog } from '../models/SecurityLog.js';\n\nimport logger from '../utils/logger.js';\n// ===== CONFIGURAÃ‡Ã•ES DE SEGURANÃ‡A =====\n\nconst securityConfig = {\n  // Rate Limiting\n  rateLimit: {\n    windowMs: 15 * 60 * 1000, // 15 minutos\n    max: {\n      public: 100,\n      authenticated: 500,\n      admin: 1000,\n      critical: 10\n    },\n    message: {\n      success: false,\n      message: 'Muitas tentativas. Tente novamente em 15 minutos.',\n      retryAfter: '15 minutos'\n    }\n  },\n\n  // CORS\n  cors: {\n    origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n    allowedHeaders: [\n      'Origin',\n      'X-Requested-With',\n      'Content-Type',\n      'Accept',\n      'Authorization',\n      'X-CSRF-Token',\n      'X-API-Key'\n    ]\n  },\n\n  // Helmet\n  helmet: {\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\n          \"'self'\",\n          \"'unsafe-inline'\",\n          'https://fonts.googleapis.com',\n          'https://cdn.jsdelivr.net'\n        ],\n        fontSrc: [\"'self'\", 'https://fonts.gstatic.com', 'https://cdn.jsdelivr.net'],\n        scriptSrc: [\"'self'\", \"'unsafe-inline'\", 'https://cdn.jsdelivr.net'],\n        imgSrc: [\"'self'\", 'data:', 'https:', 'blob:'],\n        connectSrc: [\"'self'\", 'https://api.github.com', 'wss:'],\n        frameSrc: [\"'none'\"],\n        objectSrc: [\"'none'\"],\n        upgradeInsecureRequests: []\n      }\n    },\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true,\n      preload: true\n    },\n    noSniff: true,\n    referrerPolicy: { policy: 'strict-origin-when-cross-origin' }\n  }\n};\n\n// ===== MIDDLEWARE DE RATE LIMITING =====\n\nexport const createRateLimiter = (max = 100, windowMs = 15 * 60 * 1000) => {\n  return rateLimit({\n    windowMs,\n    max,\n    message: securityConfig.rateLimit.message,\n    standardHeaders: true,\n    legacyHeaders: false,\n    handler: async (req, res) => {\n      // Log de rate limiting\n      await SecurityLog.create({\n        eventType: 'rate_limit_exceeded',\n        severity: 'medium',\n        description: `Rate limit exceeded: ${max} requests in ${windowMs}ms`,\n        ipAddress: req.ip,\n        userAgent: req.get('User-Agent'),\n        requestMethod: req.method,\n        requestUrl: req.originalUrl,\n        details: {\n          limit: max,\n          windowMs,\n          userAgent: req.get('User-Agent')\n        }\n      });\n\n      res.status(429).json(securityConfig.rateLimit.message);\n    }\n  });\n};\n\n// Rate limiters especÃ­ficos\nexport const publicRateLimit = createRateLimiter(securityConfig.rateLimit.max.public);\nexport const authenticatedRateLimit = createRateLimiter(securityConfig.rateLimit.max.authenticated);\nexport const adminRateLimit = createRateLimiter(securityConfig.rateLimit.max.admin);\nexport const criticalRateLimit = createRateLimiter(securityConfig.rateLimit.max.critical);\n\n// ===== MIDDLEWARE DE SEGURANÃ‡A PRINCIPAL =====\n\nexport const securityMiddleware = [\n  // CORS\n  cors(securityConfig.cors),\n\n  // Helmet para headers de seguranÃ§a\n  helmet(securityConfig.helmet),\n\n  // ProteÃ§Ã£o contra XSS\n  xss(),\n\n  // ProteÃ§Ã£o contra HTTP Parameter Pollution\n  hpp(),\n\n  // ProteÃ§Ã£o contra NoSQL Injection\n  mongoSanitize(),\n\n  // Middleware de detecÃ§Ã£o de ataques\n  detectAttackPatterns,\n\n  // Middleware de validaÃ§Ã£o de entrada\n  validateInput,\n\n  // Middleware de sanitizaÃ§Ã£o\n  sanitizeData,\n\n  // Middleware de logging de seguranÃ§a\n  securityLogging\n];\n\n// ===== DETECÃ‡ÃƒO DE PADRÃ•ES DE ATAQUE =====\n\nexport const detectAttackPatterns = async (req, res, next) => {\n  try {\n    const attackPatterns = [\n      // SQL Injection\n      /(\\b(union|select|insert|update|delete|drop|create|alter|exec|execute|script|javascript|vbscript|onload|onerror|onclick)\\b)/i,\n\n      // XSS\n      /<script|javascript:|vbscript:|onload|onerror|onclick|onmouseover/i,\n\n      // Command Injection\n      /(\\b(cmd|command|exec|system|eval|setTimeout|setInterval)\\b)/i,\n\n      // Path Traversal\n      /\\.\\.\\/|\\.\\.\\\\|\\.\\.%2f|\\.\\.%5c/i,\n\n      // LDAP Injection\n      /(\\b(\\(|\\)|\\*|\\||&)\\b)/i,\n\n      // NoSQL Injection\n      /(\\$where|\\$ne|\\$gt|\\$lt|\\$regex)/i,\n\n      // Template Injection\n      /(\\{\\{.*\\}\\}|\\{%.*%\\})/i,\n\n      // Code Injection\n      /(\\beval\\s*\\(|\\bFunction\\s*\\(|\\bnew\\s+Function)/i\n    ];\n\n    const requestData = JSON.stringify({\n      url: req.originalUrl,\n      method: req.method,\n      body: req.body,\n      query: req.query,\n      params: req.params,\n      headers: req.headers\n    });\n\n    let attackDetected = false;\n    let attackType = '';\n\n    attackPatterns.forEach((pattern, index) => {\n      if (pattern.test(requestData)) {\n        attackDetected = true;\n        const attackTypes = [\n          'SQL_INJECTION',\n          'XSS',\n          'COMMAND_INJECTION',\n          'PATH_TRAVERSAL',\n          'LDAP_INJECTION',\n          'NOSQL_INJECTION',\n          'TEMPLATE_INJECTION',\n          'CODE_INJECTION'\n        ];\n        attackType = attackTypes[index] || 'UNKNOWN_ATTACK';\n      }\n    });\n\n    if (attackDetected) {\n      // Log do ataque detectado\n      await SecurityLog.create({\n        eventType: 'suspicious_activity',\n        severity: 'high',\n        description: `Ataque detectado: ${attackType}`,\n        ipAddress: req.ip,\n        userAgent: req.get('User-Agent'),\n        requestMethod: req.method,\n        requestUrl: req.originalUrl,\n        requestHeaders: req.headers,\n        requestBody: requestData.substring(0, 1000),\n        details: {\n          attackType,\n          requestData: requestData.substring(0, 500),\n          userAgent: req.get('User-Agent')\n        }\n      });\n\n      // Bloquear requisiÃ§Ã£o\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado: padrÃ£o suspeito detectado',\n        code: 'ATTACK_DETECTED'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na detecÃ§Ã£o de ataques:', error);\n    }\n    next();\n  }\n};\n\n// ===== VALIDAÃ‡ÃƒO DE ENTRADA =====\n\nexport const validateInput = (req, res, next) => {\n  try {\n    // Validar tamanho do body\n    const contentLength = parseInt(req.get('content-length', 10) || '0');\n    const maxSize = 10 * 1024 * 1024; // 10MB\n\n    if (contentLength > maxSize) {\n      return res.status(413).json({\n        success: false,\n        message: 'Payload muito grande',\n        code: 'PAYLOAD_TOO_LARGE'\n      });\n    }\n\n    // Validar Content-Type\n    const contentType = req.get('content-type');\n    if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {\n      if (!contentType || !contentType.includes('application/json')) {\n        return res.status(400).json({\n          success: false,\n          message: 'Content-Type deve ser application/json',\n          code: 'INVALID_CONTENT_TYPE'\n        });\n      }\n    }\n\n    // Sanitizar query parameters\n    if (req.query) {\n      for (const key in req.query) {\n        if (typeof req.query[key] === 'string') {\n          req.query[key] = sanitizeString(req.query[key]);\n        }\n      }\n    }\n\n    // Sanitizar body\n    if (req.body) {\n      req.body = sanitizeObject(req.body);\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o de entrada:', error);\n    }\n    res.status(400).json({\n      success: false,\n      message: 'Erro na validaÃ§Ã£o de entrada',\n      code: 'VALIDATION_ERROR'\n    });\n  }\n};\n\n// ===== SANITIZAÃ‡ÃƒO DE DADOS =====\n\nexport const sanitizeData = (req, res, next) => {\n  try {\n    // Sanitizar headers suspeitos\n    const suspiciousHeaders = ['x-forwarded-for', 'x-real-ip', 'x-cluster-client-ip'];\n\n    suspiciousHeaders.forEach(header => {\n      if (req.headers[header]) {\n        req.headers[header] = sanitizeString(req.headers[header]);\n      }\n    });\n\n    // Sanitizar User-Agent\n    if (req.headers['user-agent']) {\n      req.headers['user-agent'] = sanitizeString(req.headers['user-agent']);\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na sanitizaÃ§Ã£o:', error);\n    }\n    next();\n  }\n};\n\n// ===== LOGGING DE SEGURANÃ‡A =====\n\nexport const securityLogging = async (req, res, next) => {\n  try {\n    // Log de requisiÃ§Ã£o\n    const logEntry = {\n      eventType: 'api_request',\n      severity: 'low',\n      description: `${req.method} ${req.originalUrl}`,\n      ipAddress: req.ip,\n      userAgent: req.get('User-Agent'),\n      requestMethod: req.method,\n      requestUrl: req.originalUrl,\n      requestHeaders: req.headers,\n      details: {\n        timestamp: new Date().toISOString(),\n        userAgent: req.get('User-Agent'),\n        referer: req.get('referer')\n      }\n    };\n\n    // Adicionar informaÃ§Ãµes do usuÃ¡rio se autenticado\n    if (req.user) {\n      logEntry.userId = req.user.id;\n      logEntry.details.userEmail = req.user.email;\n    }\n\n    await SecurityLog.create(logEntry);\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no logging de seguranÃ§a:', error);\n    }\n    next();\n  }\n};\n\n// ===== FUNÃ‡Ã•ES AUXILIARES =====\n\nfunction sanitizeString(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n\n  return (\n    str\n      .replace(/[<>]/g, '') // Remover < e >\n      .replace(/javascript:/gi, '') // Remover javascript:\n      .replace(/on\\w+=/gi, '') // Remover event handlers\n      // Remover caracteres de controle, usando a classe POSIX-equivalente para maior compatibilidade\n      .replace(/[^\\x20-\\x7E\\n\\r\\t]/g, '')\n      .trim()\n  );\n}\n\nfunction sanitizeObject(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => sanitizeObject(item));\n  }\n\n  const sanitized = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const cleanKey = sanitizeString(key);\n    sanitized[cleanKey] = typeof value === 'string' ? sanitizeString(value) : sanitizeObject(value);\n  }\n\n  return sanitized;\n}\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO DE WEBHOOK =====\n\nexport const validateStripeWebhook = (req, res, next) => {\n  try {\n    const signature = req.get('stripe-signature');\n    const payload = JSON.stringify(req.body);\n\n    if (!signature) {\n      return res.status(400).json({\n        success: false,\n        message: 'Stripe signature missing',\n        code: 'MISSING_SIGNATURE'\n      });\n    }\n\n    // Aqui vocÃª implementaria a verificaÃ§Ã£o real da assinatura do Stripe\n    // Por enquanto, apenas validar se existe\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o do webhook Stripe:', error);\n    }\n    res.status(400).json({\n      success: false,\n      message: 'Webhook invÃ¡lido',\n      code: 'INVALID_WEBHOOK'\n    });\n  }\n};\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO DE CSRF =====\n\nexport const validateCSRF = (req, res, next) => {\n  try {\n    // Verificar se Ã© uma requisiÃ§Ã£o que precisa de CSRF\n    const csrfRequiredMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];\n\n    if (!csrfRequiredMethods.includes(req.method)) {\n      return next();\n    }\n\n    const csrfToken = req.get('X-CSRF-Token');\n    const sessionToken = req.session?.csrfToken;\n\n    if (!csrfToken || !sessionToken || csrfToken !== sessionToken) {\n      return res.status(403).json({\n        success: false,\n        message: 'Token CSRF invÃ¡lido',\n        code: 'INVALID_CSRF'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o CSRF:', error);\n    }\n    res.status(403).json({\n      success: false,\n      message: 'Erro na validaÃ§Ã£o CSRF',\n      code: 'CSRF_ERROR'\n    });\n  }\n};\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO DE API KEY =====\n\nexport const validateAPIKey = (req, res, next) => {\n  try {\n    const apiKey = req.get('X-API-Key');\n\n    if (!apiKey) {\n      return res.status(401).json({\n        success: false,\n        message: 'API Key obrigatÃ³ria',\n        code: 'MISSING_API_KEY'\n      });\n    }\n\n    // Aqui vocÃª implementaria a validaÃ§Ã£o real da API Key\n    // Por enquanto, apenas verificar se existe\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o da API Key:', error);\n    }\n    res.status(401).json({\n      success: false,\n      message: 'API Key invÃ¡lida',\n      code: 'INVALID_API_KEY'\n    });\n  }\n};\n\nexport default {\n  securityMiddleware,\n  createRateLimiter,\n  publicRateLimit,\n  authenticatedRateLimit,\n  adminRateLimit,\n  criticalRateLimit,\n  detectAttackPatterns,\n  validateInput,\n  sanitizeData,\n  securityLogging,\n  validateStripeWebhook,\n  validateCSRF,\n  validateAPIKey\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\sessionCapture.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\validation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\AuditLog.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Chat.js","messages":[{"ruleId":"require-await","severity":1,"message":"Static async method 'findById' has no 'await' expression.","line":7,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":7,"endColumn":24},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":27},{"ruleId":"require-await","severity":1,"message":"Static async method 'create' has no 'await' expression.","line":11,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":11,"endColumn":22},{"ruleId":"require-await","severity":1,"message":"Async method 'save' has no 'await' expression.","line":15,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":15,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿// Modelo Chat - arquivo temporÃ¡rio para deploy\nexport default class Chat {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n\n  static async findById(id) {\n    return null;\n  }\n\n  static async create(data) {\n    return new Chat(data);\n  }\n\n  async save() {\n    return this;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\ContactMessage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Conversation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Escrow.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\EscrowTransaction.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Freight.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\FreightOrder.js","messages":[{"ruleId":"require-await","severity":1,"message":"Static async method 'findById' has no 'await' expression.","line":7,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":7,"endColumn":24},{"ruleId":"no-unused-vars","severity":1,"message":"'id' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":27},{"ruleId":"require-await","severity":1,"message":"Static async method 'findByUser' has no 'await' expression.","line":11,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":11,"endColumn":26},{"ruleId":"no-unused-vars","severity":1,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":33},{"ruleId":"require-await","severity":1,"message":"Static async method 'create' has no 'await' expression.","line":15,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":15,"endColumn":22},{"ruleId":"require-await","severity":1,"message":"Async method 'save' has no 'await' expression.","line":19,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":19,"endColumn":13},{"ruleId":"require-await","severity":1,"message":"Async method 'update' has no 'await' expression.","line":23,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":23,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿// Modelo FreightOrder - arquivo temporÃ¡rio para deploy\nexport default class FreightOrder {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n\n  static async findById(id) {\n    return null;\n  }\n\n  static async findByUser(userId) {\n    return [];\n  }\n\n  static async create(data) {\n    return new FreightOrder(data);\n  }\n\n  async save() {\n    return this;\n  }\n\n  async update(data) {\n    Object.assign(this, data);\n    return this;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Message.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\News.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Notification.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Partner.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\PartnershipMessage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\PasswordResetD1.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Payment.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\PrivateMessage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Product.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\RefreshToken.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async function has no 'await' expression.","line":95,"column":50,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":95,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import mongoose from 'mongoose';\n\nconst refreshTokenSchema = new mongoose.Schema(\n  {\n    userId: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true\n    },\n    token: {\n      type: String,\n      required: true,\n      unique: true,\n      index: true\n    },\n    jwtToken: {\n      type: String,\n      required: true\n    },\n    expiresAt: {\n      type: Date,\n      required: true,\n      index: { expireAfterSeconds: 0 } // TTL index\n    },\n    userAgent: {\n      type: String,\n      default: null\n    },\n    ipAddress: {\n      type: String,\n      default: null\n    },\n    isActive: {\n      type: Boolean,\n      default: true,\n      index: true\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now\n    },\n    lastUsedAt: {\n      type: Date,\n      default: null\n    },\n    revokedAt: {\n      type: Date,\n      default: null\n    }\n  },\n  {\n    timestamps: true\n  }\n);\n\n// Ãndices compostos para performance\nrefreshTokenSchema.index({ userId: 1, isActive: 1 });\nrefreshTokenSchema.index({ token: 1, isActive: 1 });\nrefreshTokenSchema.index({ expiresAt: 1, isActive: 1 });\n\n// MÃ©todo para verificar se o token estÃ¡ vÃ¡lido\nrefreshTokenSchema.methods.isValid = function () {\n  return this.isActive && this.expiresAt > new Date();\n};\n\n// MÃ©todo para revogar o token\nrefreshTokenSchema.methods.revoke = function () {\n  this.isActive = false;\n  this.revokedAt = new Date();\n  return this.save();\n};\n\n// MÃ©todo estÃ¡tico para limpar tokens expirados\nrefreshTokenSchema.statics.cleanupExpired = async function () {\n  const result = await this.deleteMany({\n    $or: [\n      { expiresAt: { $lt: new Date() } },\n      { isActive: false, revokedAt: { $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } }\n    ]\n  });\n  return result.deletedCount;\n};\n\n// MÃ©todo estÃ¡tico para revogar todos os tokens de um usuÃ¡rio\nrefreshTokenSchema.statics.revokeUserTokens = async function (userId) {\n  const result = await this.updateMany(\n    { userId, isActive: true },\n    { isActive: false, revokedAt: new Date() }\n  );\n  return result.modifiedCount;\n};\n\n// MÃ©todo estÃ¡tico para obter tokens ativos de um usuÃ¡rio\nrefreshTokenSchema.statics.getActiveUserTokens = async function (userId) {\n  return this.find({\n    userId,\n    isActive: true,\n    expiresAt: { $gt: new Date() }\n  }).sort({ createdAt: -1 });\n};\n\n// Middleware para atualizar lastUsedAt\nrefreshTokenSchema.pre('save', function (next) {\n  if (this.isModified('lastUsedAt') && this.lastUsedAt) {\n    this.lastUsedAt = new Date();\n  }\n  next();\n});\n\nconst RefreshToken = mongoose.model('RefreshToken', refreshTokenSchema);\n\nexport default RefreshToken;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Registration.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'bcrypt' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":2,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":13},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":969,"column":12,"nodeType":"CallExpression","messageId":"missingRadix","endLine":969,"endColumn":39,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[16954,16954],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":975,"column":21,"nodeType":"CallExpression","messageId":"missingRadix","endLine":975,"endColumn":48,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[17122,17122],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":981,"column":12,"nodeType":"CallExpression","messageId":"missingRadix","endLine":981,"endColumn":39,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[17231,17231],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":987,"column":21,"nodeType":"CallExpression","messageId":"missingRadix","endLine":987,"endColumn":49,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[17396,17396],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":1005,"column":12,"nodeType":"CallExpression","messageId":"missingRadix","endLine":1005,"endColumn":40,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[17722,17722],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":1012,"column":18,"nodeType":"CallExpression","messageId":"missingRadix","endLine":1012,"endColumn":47,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[17910,17910],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":1020,"column":12,"nodeType":"CallExpression","messageId":"missingRadix","endLine":1020,"endColumn":40,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[18036,18036],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":1027,"column":21,"nodeType":"CallExpression","messageId":"missingRadix","endLine":1027,"endColumn":50,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[18223,18223],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿const mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\n\n// Schema para cadastros de AgroConecta\nconst agroConectaSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da empresa\n    companyName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cnpj: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n    ie: {\n      type: String,\n      trim: true\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Dados do veÃ­culo\n    vehicle: {\n      plate: {\n        type: String,\n        required: true,\n        unique: true,\n        trim: true\n      },\n      type: {\n        type: String,\n        required: true,\n        enum: ['truck', 'tractor', 'van', 'pickup']\n      },\n      capacity: {\n        type: Number,\n        required: true,\n        min: 0\n      },\n      license: {\n        type: String,\n        required: true,\n        enum: ['B', 'C', 'D', 'E']\n      },\n      year: {\n        type: Number,\n        min: 1900,\n        max: new Date().getFullYear() + 1\n      },\n      model: {\n        type: String,\n        trim: true\n      },\n      brand: {\n        type: String,\n        trim: true\n      }\n    },\n\n    // ServiÃ§os oferecidos\n    services: [\n      {\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        unit: {\n          type: String,\n          default: 'km',\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalJobs: {\n        type: Number,\n        default: 0\n      },\n      completedJobs: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      cnpj: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Schema para cadastros de Loja\nconst lojaSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da empresa\n    companyName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cnpj: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n    ie: {\n      type: String,\n      trim: true\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Produtos\n    products: [\n      {\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        category: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        quantity: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        unit: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        image: {\n          type: String,\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        },\n        isAvailable: {\n          type: Boolean,\n          default: true\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalSales: {\n        type: Number,\n        default: 0\n      },\n      completedOrders: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      cnpj: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Schema para cadastros de Marketplace\nconst marketplaceSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da empresa\n    companyName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cnpj: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n    ie: {\n      type: String,\n      trim: true\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Produtos/ServiÃ§os\n    offerings: [\n      {\n        type: {\n          type: String,\n          required: true,\n          enum: ['product', 'service']\n        },\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        category: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        quantity: {\n          type: Number,\n          default: 1,\n          min: 0\n        },\n        unit: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        image: {\n          type: String,\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        },\n        isAvailable: {\n          type: Boolean,\n          default: true\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalTransactions: {\n        type: Number,\n        default: 0\n      },\n      completedOrders: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      cnpj: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Schema para cadastros de Fazenda\nconst fazendaSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da fazenda\n    farmName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    farmSize: {\n      type: Number,\n      required: true,\n      min: 0\n    },\n    farmType: {\n      type: String,\n      enum: ['agriculture', 'livestock', 'mixed'],\n      default: 'agriculture'\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Produtos da fazenda\n    products: [\n      {\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        category: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        quantity: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        unit: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        harvestDate: {\n          type: Date\n        },\n        image: {\n          type: String,\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        },\n        isAvailable: {\n          type: Boolean,\n          default: true\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalHarvests: {\n        type: Number,\n        default: 0\n      },\n      totalSales: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Middleware para validaÃ§Ã£o de dados\nagroConectaSchema.pre('save', function (next) {\n  // Validar CPF\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  // Validar CNPJ\n  if (this.cnpj && !this.isValidCNPJ(this.cnpj)) {\n    return next(new Error('CNPJ invÃ¡lido'));\n  }\n\n  next();\n});\n\nlojaSchema.pre('save', function (next) {\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  if (this.cnpj && !this.isValidCNPJ(this.cnpj)) {\n    return next(new Error('CNPJ invÃ¡lido'));\n  }\n\n  next();\n});\n\nmarketplaceSchema.pre('save', function (next) {\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  if (this.cnpj && !this.isValidCNPJ(this.cnpj)) {\n    return next(new Error('CNPJ invÃ¡lido'));\n  }\n\n  next();\n});\n\nfazendaSchema.pre('save', function (next) {\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  next();\n});\n\n// MÃ©todos de validaÃ§Ã£o\nagroConectaSchema.methods.isValidCPF = function (cpf) {\n  cpf = cpf.replace(/[^\\d]/g, '');\n\n  if (cpf.length !== 11 || /^(\\d)\\1+$/.test(cpf)) {\n    return false;\n  }\n\n  let sum = 0;\n  for (let i = 0; i < 9; i++) {\n    sum += parseInt(cpf.charAt(i, 10)) * (10 - i);\n  }\n  let remainder = (sum * 10) % 11;\n  if (remainder === 10 || remainder === 11) {\n    remainder = 0;\n  }\n  if (remainder !== parseInt(cpf.charAt(9, 10))) {\n    return false;\n  }\n\n  sum = 0;\n  for (let i = 0; i < 10; i++) {\n    sum += parseInt(cpf.charAt(i, 10)) * (11 - i);\n  }\n  remainder = (sum * 10) % 11;\n  if (remainder === 10 || remainder === 11) {\n    remainder = 0;\n  }\n  if (remainder !== parseInt(cpf.charAt(10, 10))) {\n    return false;\n  }\n\n  return true;\n};\n\nagroConectaSchema.methods.isValidCNPJ = function (cnpj) {\n  cnpj = cnpj.replace(/[^\\d]/g, '');\n\n  if (cnpj.length !== 14 || /^(\\d)\\1+$/.test(cnpj)) {\n    return false;\n  }\n\n  let sum = 0;\n  let weight = 2;\n\n  for (let i = 11; i >= 0; i--) {\n    sum += parseInt(cnpj.charAt(i, 10)) * weight;\n    weight = weight === 9 ? 2 : weight + 1;\n  }\n\n  let remainder = sum % 11;\n  const digit1 = remainder < 2 ? 0 : 11 - remainder;\n\n  if (digit1 !== parseInt(cnpj.charAt(12, 10))) {\n    return false;\n  }\n\n  sum = 0;\n  weight = 2;\n\n  for (let i = 12; i >= 0; i--) {\n    sum += parseInt(cnpj.charAt(i, 10)) * weight;\n    weight = weight === 9 ? 2 : weight + 1;\n  }\n\n  remainder = sum % 11;\n  const digit2 = remainder < 2 ? 0 : 11 - remainder;\n\n  return digit2 === parseInt(cnpj.charAt(13, 10));\n};\n\n// Aplicar os mesmos mÃ©todos para os outros schemas\nlojaSchema.methods.isValidCPF = agroConectaSchema.methods.isValidCPF;\nlojaSchema.methods.isValidCNPJ = agroConectaSchema.methods.isValidCNPJ;\nmarketplaceSchema.methods.isValidCPF = agroConectaSchema.methods.isValidCPF;\nmarketplaceSchema.methods.isValidCNPJ = agroConectaSchema.methods.isValidCNPJ;\nfazendaSchema.methods.isValidCPF = agroConectaSchema.methods.isValidCPF;\n\n// Ãndices para otimizaÃ§Ã£o\nagroConectaSchema.index({ email: 1 });\nagroConectaSchema.index({ cpf: 1 });\nagroConectaSchema.index({ cnpj: 1 });\nagroConectaSchema.index({ 'address.city': 1, 'address.state': 1 });\nagroConectaSchema.index({ 'vehicle.type': 1 });\nagroConectaSchema.index({ plan: 1, isPublic: 1 });\n\nlojaSchema.index({ email: 1 });\nlojaSchema.index({ cpf: 1 });\nlojaSchema.index({ cnpj: 1 });\nlojaSchema.index({ 'address.city': 1, 'address.state': 1 });\nlojaSchema.index({ plan: 1, isPublic: 1 });\n\nmarketplaceSchema.index({ email: 1 });\nmarketplaceSchema.index({ cpf: 1 });\nmarketplaceSchema.index({ cnpj: 1 });\nmarketplaceSchema.index({ 'address.city': 1, 'address.state': 1 });\nmarketplaceSchema.index({ plan: 1, isPublic: 1 });\n\nfazendaSchema.index({ email: 1 });\nfazendaSchema.index({ cpf: 1 });\nfazendaSchema.index({ 'address.city': 1, 'address.state': 1 });\nfazendaSchema.index({ plan: 1, isPublic: 1 });\n\nconst AgroConecta = mongoose.model('AgroConecta', agroConectaSchema);\nconst Loja = mongoose.model('Loja', lojaSchema);\nconst Marketplace = mongoose.model('Marketplace', marketplaceSchema);\nconst Fazenda = mongoose.model('Fazenda', fazendaSchema);\n\nmodule.exports = {\n  AgroConecta,\n  Loja,\n  Marketplace,\n  Fazenda\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\SecurityLog.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\StakingPool.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\StakingRecord.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Transaction.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\TransactionMessage.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'reason' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":244,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":244,"endColumn":65},{"ruleId":"no-unused-vars","severity":1,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":275,"column":58,"nodeType":"Identifier","messageId":"unusedVar","endLine":275,"endColumn":64}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import mongoose from 'mongoose';\n\nconst transactionMessageSchema = new mongoose.Schema(\n  {\n    // ID da transaÃ§Ã£o relacionada\n    transactionId: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'Transaction',\n      required: true,\n      index: true\n    },\n\n    // UsuÃ¡rio que enviou a mensagem\n    from: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true\n    },\n\n    // UsuÃ¡rio que recebeu a mensagem\n    to: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true\n    },\n\n    // ConteÃºdo da mensagem\n    body: {\n      type: String,\n      required: true,\n      trim: true,\n      maxlength: [2000, 'Mensagem nÃ£o pode ter mais de 2000 caracteres']\n    },\n\n    // Tipo da mensagem\n    type: {\n      type: String,\n      enum: ['text', 'image', 'file', 'location', 'system'],\n      default: 'text'\n    },\n\n    // Anexos (opcional)\n    attachments: [\n      {\n        name: String,\n        type: String,\n        size: Number,\n        url: String,\n        thumbnail: String\n      }\n    ],\n\n    // Status da mensagem\n    status: {\n      type: String,\n      enum: ['sent', 'delivered', 'read', 'failed'],\n      default: 'sent',\n      index: true\n    },\n\n    // Metadados\n    metadata: {\n      // Coordenadas se for mensagem de localizaÃ§Ã£o\n      coordinates: {\n        lat: Number,\n        lng: Number,\n        address: String\n      },\n      // InformaÃ§Ãµes do arquivo se for anexo\n      fileInfo: {\n        originalName: String,\n        mimeType: String,\n        size: Number\n      }\n    },\n\n    // Timestamps\n    createdAt: {\n      type: Date,\n      default: Date.now,\n      index: true\n    },\n\n    // Quando foi entregue\n    deliveredAt: Date,\n\n    // Quando foi lida\n    readAt: Date,\n\n    // UsuÃ¡rios que leram a mensagem\n    readBy: [\n      {\n        userId: {\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'User'\n        },\n        readAt: {\n          type: Date,\n          default: Date.now\n        }\n      }\n    ],\n\n    // Mensagem pai (para respostas)\n    parentMessage: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'TransactionMessage'\n    },\n\n    // Mensagens filhas (respostas)\n    replies: [\n      {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'TransactionMessage'\n      }\n    ],\n\n    // Flags e moderaÃ§Ã£o\n    isFlagged: {\n      type: Boolean,\n      default: false\n    },\n\n    flaggedReason: String,\n\n    flaggedBy: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User'\n    },\n\n    flaggedAt: Date,\n\n    // Soft delete\n    isDeleted: {\n      type: Boolean,\n      default: false\n    },\n\n    deletedAt: Date,\n\n    deletedBy: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User'\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Ãndices para performance\ntransactionMessageSchema.index({ transactionId: 1, createdAt: -1 });\ntransactionMessageSchema.index({ from: 1, createdAt: -1 });\ntransactionMessageSchema.index({ to: 1, createdAt: -1 });\ntransactionMessageSchema.index({ status: 1, createdAt: -1 });\ntransactionMessageSchema.index({ 'readBy.userId': 1 });\ntransactionMessageSchema.index({ isDeleted: 1 });\n\n// Middleware para atualizar timestamps\ntransactionMessageSchema.pre('save', function (next) {\n  if (this.isModified('status')) {\n    if (this.status === 'delivered' && !this.deliveredAt) {\n      this.deliveredAt = new Date();\n    }\n    if (this.status === 'read' && !this.readAt) {\n      this.readAt = new Date();\n    }\n  }\n  next();\n});\n\n// Virtual para verificar se a mensagem foi lida\ntransactionMessageSchema.virtual('isRead').get(function () {\n  return this.status === 'read';\n});\n\n// Virtual para verificar se a mensagem foi entregue\ntransactionMessageSchema.virtual('isDelivered').get(function () {\n  return this.status === 'delivered' || this.status === 'read';\n});\n\n// Virtual para verificar se a mensagem falhou\ntransactionMessageSchema.virtual('isFailed').get(function () {\n  return this.status === 'failed';\n});\n\n// Virtual para verificar se tem anexos\ntransactionMessageSchema.virtual('hasAttachments').get(function () {\n  return this.attachments && this.attachments.length > 0;\n});\n\n// Virtual para verificar se Ã© imagem\ntransactionMessageSchema.virtual('isImage').get(function () {\n  return this.type === 'image';\n});\n\n// Virtual para verificar se Ã© arquivo\ntransactionMessageSchema.virtual('isFile').get(function () {\n  return this.type === 'file';\n});\n\n// Virtual para verificar se Ã© localizaÃ§Ã£o\ntransactionMessageSchema.virtual('isLocation').get(function () {\n  return this.type === 'location';\n});\n\n// Virtual para verificar se Ã© sistema\ntransactionMessageSchema.virtual('isSystem').get(function () {\n  return this.type === 'system';\n});\n\n// MÃ©todo para marcar como entregue\ntransactionMessageSchema.methods.markAsDelivered = function () {\n  this.status = 'delivered';\n  this.deliveredAt = new Date();\n  return this.save();\n};\n\n// MÃ©todo para marcar como lida\ntransactionMessageSchema.methods.markAsRead = function (userId) {\n  if (this.status !== 'read') {\n    this.status = 'read';\n    this.readAt = new Date();\n  }\n\n  // Adicionar usuÃ¡rio Ã  lista de leitores se nÃ£o estiver\n  const alreadyRead = this.readBy.find(reader => reader.userId.toString() === userId.toString());\n\n  if (!alreadyRead) {\n    this.readBy.push({\n      userId,\n      readAt: new Date()\n    });\n  }\n\n  return this.save();\n};\n\n// MÃ©todo para marcar como falhou\ntransactionMessageSchema.methods.markAsFailed = function (reason = 'Erro de entrega') {\n  this.status = 'failed';\n  return this.save();\n};\n\n// MÃ©todo para verificar se foi lida por um usuÃ¡rio especÃ­fico\ntransactionMessageSchema.methods.isReadBy = function (userId) {\n  return this.readBy.some(reader => reader.userId.toString() === userId.toString());\n};\n\n// MÃ©todo para obter dados pÃºblicos (sem informaÃ§Ãµes sensÃ­veis)\ntransactionMessageSchema.methods.getPublicData = function () {\n  return {\n    id: this._id,\n    transactionId: this.transactionId,\n    from: this.from,\n    to: this.to,\n    body: this.body,\n    type: this.type,\n    status: this.status,\n    hasAttachments: this.hasAttachments,\n    createdAt: this.createdAt,\n    deliveredAt: this.deliveredAt,\n    readAt: this.readAt,\n    isRead: this.isRead,\n    isDelivered: this.isDelivered,\n    isFailed: this.isFailed\n  };\n};\n\n// MÃ©todo para obter dados completos (para usuÃ¡rios autorizados)\ntransactionMessageSchema.methods.getFullData = function (userId) {\n  const baseData = this.getPublicData();\n\n  // Adicionar anexos se existirem\n  if (this.attachments && this.attachments.length > 0) {\n    baseData.attachments = this.attachments;\n  }\n\n  // Adicionar metadados se existirem\n  if (this.metadata) {\n    baseData.metadata = this.metadata;\n  }\n\n  // Adicionar informaÃ§Ãµes de leitura\n  baseData.readBy = this.readBy;\n\n  // Adicionar informaÃ§Ãµes de resposta\n  if (this.parentMessage) {\n    baseData.parentMessage = this.parentMessage;\n  }\n\n  if (this.replies && this.replies.length > 0) {\n    baseData.replies = this.replies;\n  }\n\n  return baseData;\n};\n\n// MÃ©todo para obter dados de exibiÃ§Ã£o (para UI)\ntransactionMessageSchema.methods.getDisplayData = function (currentUserId) {\n  const baseData = this.getPublicData();\n\n  // Adicionar flag se Ã© mensagem do usuÃ¡rio atual\n  baseData.isOwnMessage = this.from.toString() === currentUserId.toString();\n\n  // Adicionar informaÃ§Ãµes de anexos para exibiÃ§Ã£o\n  if (this.attachments && this.attachments.length > 0) {\n    baseData.attachments = this.attachments.map(attachment => ({\n      name: attachment.name,\n      type: attachment.type,\n      size: attachment.size,\n      url: attachment.url,\n      thumbnail: attachment.thumbnail,\n      isImage: attachment.type.startsWith('image/'),\n      isFile: !attachment.type.startsWith('image/')\n    }));\n  }\n\n  // Adicionar metadados de localizaÃ§Ã£o se aplicÃ¡vel\n  if (this.type === 'location' && this.metadata?.coordinates) {\n    baseData.location = {\n      lat: this.metadata.coordinates.lat,\n      lng: this.metadata.coordinates.lng,\n      address: this.metadata.coordinates.address\n    };\n  }\n\n  return baseData;\n};\n\n// MÃ©todos estÃ¡ticos para consultas comuns\n\n// Buscar mensagens de uma transaÃ§Ã£o\ntransactionMessageSchema.statics.findByTransaction = function (transactionId, options = {}) {\n  const { limit = 50, skip = 0, sort = { createdAt: -1 }, includeDeleted = false } = options;\n\n  const query = { transactionId };\n\n  if (!includeDeleted) {\n    query.isDeleted = false;\n  }\n\n  return this.find(query)\n    .sort(sort)\n    .skip(skip)\n    .limit(limit)\n    .populate('from', 'name email phone')\n    .populate('to', 'name email phone')\n    .populate('parentMessage')\n    .populate('replies');\n};\n\n// Buscar mensagens nÃ£o lidas de um usuÃ¡rio\ntransactionMessageSchema.statics.findUnreadByUser = function (userId, transactionId = null) {\n  const query = {\n    to: userId,\n    status: { $ne: 'read' },\n    isDeleted: false\n  };\n\n  if (transactionId) {\n    query.transactionId = transactionId;\n  }\n\n  return this.find(query)\n    .populate('from', 'name email phone')\n    .populate('transactionId', 'type itemDetails')\n    .sort({ createdAt: -1 });\n};\n\n// Buscar mensagens de um usuÃ¡rio\ntransactionMessageSchema.statics.findByUser = function (userId, options = {}) {\n  const {\n    limit = 50,\n    skip = 0,\n    sort = { createdAt: -1 },\n    includeDeleted = false,\n    transactionId = null\n  } = options;\n\n  const query = {\n    $or: [{ from: userId }, { to: userId }],\n    isDeleted: false\n  };\n\n  if (transactionId) {\n    query.transactionId = transactionId;\n  }\n\n  if (includeDeleted) {\n    delete query.isDeleted;\n  }\n\n  return this.find(query)\n    .sort(sort)\n    .skip(skip)\n    .limit(limit)\n    .populate('from', 'name email phone')\n    .populate('to', 'name email phone')\n    .populate('transactionId', 'type itemDetails');\n};\n\n// EstatÃ­sticas de mensagens\ntransactionMessageSchema.statics.getStats = async function (userId = null) {\n  const matchStage = userId ? { $or: [{ from: userId }, { to: userId }] } : {};\n\n  const stats = await this.aggregate([\n    { $match: { ...matchStage, isDeleted: false } },\n    {\n      $group: {\n        _id: null,\n        totalMessages: { $sum: 1 },\n        textMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'text'] }, 1, 0] }\n        },\n        imageMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'image'] }, 1, 0] }\n        },\n        fileMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'file'] }, 1, 0] }\n        },\n        locationMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'location'] }, 1, 0] }\n        },\n        systemMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'system'] }, 1, 0] }\n        },\n        sentMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] }\n        },\n        deliveredMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'delivered'] }, 1, 0] }\n        },\n        readMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'read'] }, 1, 0] }\n        },\n        failedMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'failed'] }, 1, 0] }\n        }\n      }\n    }\n  ]);\n\n  return (\n    stats[0] || {\n      totalMessages: 0,\n      textMessages: 0,\n      imageMessages: 0,\n      fileMessages: 0,\n      locationMessages: 0,\n      systemMessages: 0,\n      sentMessages: 0,\n      deliveredMessages: 0,\n      readMessages: 0,\n      failedMessages: 0\n    }\n  );\n};\n\n// Buscar conversas ativas de um usuÃ¡rio\ntransactionMessageSchema.statics.findActiveConversations = function (userId, limit = 20) {\n  return this.aggregate([\n    {\n      $match: {\n        $or: [{ from: userId }, { to: userId }],\n        isDeleted: false\n      }\n    },\n    {\n      $group: {\n        _id: '$transactionId',\n        lastMessage: { $last: '$$ROOT' },\n        messageCount: { $sum: 1 },\n        unreadCount: {\n          $sum: {\n            $cond: [{ $and: [{ $eq: ['$to', userId] }, { $ne: ['$status', 'read'] }] }, 1, 0]\n          }\n        }\n      }\n    },\n    {\n      $sort: { 'lastMessage.createdAt': -1 }\n    },\n    {\n      $limit: limit\n    },\n    {\n      $lookup: {\n        from: 'transactions',\n        localField: '_id',\n        foreignField: '_id',\n        as: 'transaction'\n      }\n    },\n    {\n      $unwind: '$transaction'\n    },\n    {\n      $lookup: {\n        from: 'users',\n        localField: 'lastMessage.from',\n        foreignField: '_id',\n        as: 'fromUser'\n      }\n    },\n    {\n      $unwind: '$fromUser'\n    },\n    {\n      $lookup: {\n        from: 'users',\n        localField: 'lastMessage.to',\n        foreignField: '_id',\n        as: 'toUser'\n      }\n    },\n    {\n      $unwind: '$toUser'\n    }\n  ]);\n};\n\nconst TransactionMessage = mongoose.model('TransactionMessage', transactionMessageSchema);\n\nexport default TransactionMessage;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\User.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\UserD1.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\UserReputation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Vehicle.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\addressValidation.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'validationResult' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":32},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":104,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":104,"endColumn":45},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":142,"column":49,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":142,"endColumn":51},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":204,"column":41,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":204,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport addressValidationService from '../services/addressValidationService.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/address/validate:\n *   post:\n *     summary: Validar endereÃ§o internacional\n *     tags: [Address]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - country\n *             properties:\n *               country:\n *                 type: string\n *                 description: CÃ³digo do paÃ­s (BR, CN, US, etc.)\n *               zipCode:\n *                 type: string\n *                 description: CEP/CÃ³digo postal\n *               address:\n *                 type: string\n *                 description: EndereÃ§o completo\n *               city:\n *                 type: string\n *                 description: Cidade\n *               state:\n *                 type: string\n *                 description: Estado/ProvÃ­ncia\n *               province:\n *                 type: string\n *                 description: ProvÃ­ncia (para China)\n *     responses:\n *       200:\n *         description: Resultado da validaÃ§Ã£o\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post(\n  '/validate',\n  [\n    body('country').notEmpty().withMessage('PaÃ­s Ã© obrigatÃ³rio'),\n    body('zipCode').optional().isLength({ min: 5, max: 10 }).withMessage('CEP invÃ¡lido'),\n    body('address').optional().isLength({ min: 5 }).withMessage('EndereÃ§o muito curto'),\n    body('city').optional().isLength({ min: 2 }).withMessage('Cidade invÃ¡lida'),\n    body('state').optional().isLength({ min: 2 }).withMessage('Estado invÃ¡lido')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { country, zipCode, address, city, state, province } = req.body;\n\n      const validationResult = await addressValidationService.validateAddress({\n        country,\n        zipCode,\n        address,\n        city,\n        state,\n        province\n      });\n\n      logger.info(`ValidaÃ§Ã£o de endereÃ§o realizada para paÃ­s: ${country}`);\n\n      res.status(200).json({\n        success: true,\n        data: validationResult\n      });\n    } catch (error) {\n      logger.error('Erro na validaÃ§Ã£o de endereÃ§o:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/address/countries:\n *   get:\n *     summary: Listar paÃ­ses suportados\n *     tags: [Address]\n *     responses:\n *       200:\n *         description: Lista de paÃ­ses suportados\n */\nrouter.get('/countries', async (req, res) => {\n  try {\n    const countries = addressValidationService.getSupportedCountries();\n\n    res.status(200).json({\n      success: true,\n      data: {\n        countries\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao listar paÃ­ses:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/address/format/{country}:\n *   get:\n *     summary: Obter formato de endereÃ§o por paÃ­s\n *     tags: [Address]\n *     parameters:\n *       - in: path\n *         name: country\n *         required: true\n *         schema:\n *           type: string\n *           description: CÃ³digo do paÃ­s\n *     responses:\n *       200:\n *         description: Formato de endereÃ§o\n *       404:\n *         description: PaÃ­s nÃ£o suportado\n */\nrouter.get('/format/:country', async (req, res) => {\n  try {\n    const { country } = req.params;\n    const format = addressValidationService.getAddressFormat(country.toUpperCase());\n\n    if (!format) {\n      return res.status(404).json({\n        success: false,\n        message: 'PaÃ­s nÃ£o suportado'\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        country: country.toUpperCase(),\n        format\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter formato de endereÃ§o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/address/format:\n *   post:\n *     summary: Formatar endereÃ§o para exibiÃ§Ã£o\n *     tags: [Address]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - addressData\n *             properties:\n *               addressData:\n *                 type: object\n *                 properties:\n *                   street:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   zipCode:\n *                     type: string\n *                   country:\n *                     type: string\n *     responses:\n *       200:\n *         description: EndereÃ§o formatado\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post('/format', async (req, res) => {\n  try {\n    const { addressData } = req.body;\n\n    if (!addressData) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados do endereÃ§o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const formattedAddress = addressValidationService.formatAddress(addressData);\n\n    res.status(200).json({\n      success: true,\n      data: {\n        formattedAddress\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao formatar endereÃ§o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\ai.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":7,"column":68,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":7,"endColumn":70}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿const express = require('express');\nconst router = express.Router();\nconst multer = require('multer');\nconst upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 5 * 1024 * 1024 } });\n\n// Reconhecimento de imagem (stub)\nrouter.post('/recognize', upload.single('image'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'Imagem nÃ£o enviada' });\n    }\n\n    // Placeholder simples: tenta inferir pelo nome do arquivo\n    const name = (req.file.originalname || '').toLowerCase();\n    let label = null;\n    if (name.includes('soja')) {\n      label = 'Saco de Soja';\n    }\n    if (name.includes('milho')) {\n      label = 'Saco de Milho';\n    }\n    if (name.includes('adubo')) {\n      label = 'Adubo';\n    }\n\n    return res.json({ label, confidence: label ? 0.62 : 0.0 });\n  } catch (e) {\n    return res.status(500).json({ error: 'Falha ao processar imagem' });\n  }\n});\n\nmodule.exports = router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\analytics.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\apis-externas.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\auditLogs.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'offset' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":22,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport auth from '../middleware/auth.js';\nimport adminAuth from '../middleware/adminAuth.js';\nimport auditService from '../services/auditService.js';\nimport { captureSessionInfo, captureRequestMetadata } from '../middleware/sessionCapture.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Middleware para capturar informaÃ§Ãµes de sessÃ£o\nrouter.use(captureSessionInfo);\nrouter.use(captureRequestMetadata);\n\n/**\n * @route GET /api/audit-logs\n * @desc Obter logs de auditoria do usuÃ¡rio\n * @access Private\n */\nrouter.get('/', auth, async (req, res) => {\n  try {\n    const { limit = 100, page = 1 } = req.query;\n    const offset = (page - 1) * limit;\n\n    const logs = await auditService.getUserAuditLogs(req.user.id, parseInt(limit, 10));\n\n    res.json({\n      success: true,\n      data: logs,\n      pagination: {\n        page: parseInt(page, 10),\n        limit: parseInt(limit, 10),\n        total: logs.length\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter logs de auditoria:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/pii-access\n * @desc Obter logs de acesso a dados PII\n * @access Private (Admin)\n */\nrouter.get('/pii-access', adminAuth, async (req, res) => {\n  try {\n    const { userId, limit = 100 } = req.query;\n\n    const logs = await auditService.getPIIAccessLogs(userId || null, parseInt(limit, 10));\n\n    res.json({\n      success: true,\n      data: logs\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter logs de acesso PII:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/stats\n * @desc Obter estatÃ­sticas de auditoria\n * @access Private (Admin)\n */\nrouter.get('/stats', adminAuth, async (req, res) => {\n  try {\n    const { startDate, endDate } = req.query;\n\n    if (!startDate || !endDate) {\n      return res.status(400).json({\n        success: false,\n        message: 'Data de inÃ­cio e fim sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    const stats = await auditService.getAuditStats(new Date(startDate), new Date(endDate));\n\n    res.json({\n      success: true,\n      data: stats\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas de auditoria:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/expiring\n * @desc Obter logs prÃ³ximos do vencimento\n * @access Private (Admin)\n */\nrouter.get('/expiring', adminAuth, async (req, res) => {\n  try {\n    const logs = await auditService.getExpiringLogs();\n\n    res.json({\n      success: true,\n      data: logs\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter logs prÃ³ximos do vencimento:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route POST /api/audit-logs/export\n * @desc Exportar logs de auditoria\n * @access Private (Admin)\n */\nrouter.post('/export', adminAuth, async (req, res) => {\n  try {\n    const { startDate, endDate, userId, action, resource, containsPII } = req.body;\n\n    if (!startDate || !endDate) {\n      return res.status(400).json({\n        success: false,\n        message: 'Data de inÃ­cio e fim sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    const logs = await auditService.exportAuditLogs({\n      startDate: new Date(startDate),\n      endDate: new Date(endDate),\n      userId,\n      action,\n      resource,\n      containsPII\n    });\n\n    res.json({\n      success: true,\n      data: logs,\n      exportedAt: new Date(),\n      totalRecords: logs.length\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao exportar logs de auditoria:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route DELETE /api/audit-logs/cleanup\n * @desc Limpar logs expirados\n * @access Private (Admin)\n */\nrouter.delete('/cleanup', adminAuth, async (req, res) => {\n  try {\n    const deletedCount = await auditService.cleanExpiredLogs();\n\n    res.json({\n      success: true,\n      message: `${deletedCount} logs expirados foram removidos`,\n      deletedCount\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao limpar logs expirados:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/:id/verify\n * @desc Verificar integridade de um log especÃ­fico\n * @access Private (Admin)\n */\nrouter.get('/:id/verify', adminAuth, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const isValid = await auditService.verifyLogIntegrity(id);\n\n    res.json({\n      success: true,\n      data: {\n        logId: id,\n        isValid\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar integridade do log:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/:id\n * @desc Obter detalhes de um log especÃ­fico\n * @access Private (Admin)\n */\nrouter.get('/:id', adminAuth, async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // Importar modelo AuditLog\n    const AuditLog = (await import('../models/AuditLog.js')).default;\n    const log = await AuditLog.findById(id);\n\n    if (!log) {\n      return res.status(404).json({\n        success: false,\n        message: 'Log nÃ£o encontrado'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: log\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter log especÃ­fico:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\chat.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'User' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":8,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":11},{"ruleId":"no-unused-vars","severity":1,"message":"'cloudflareService' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":13,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":24},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":25,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":25,"endColumn":27},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":27,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":27,"endColumn":16},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":54,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":54,"endColumn":21},{"ruleId":"callback-return","severity":1,"message":"Expected return with your callback function.","line":56,"column":7,"nodeType":"CallExpression","messageId":"missingReturn","endLine":56,"endColumn":61},{"ruleId":"no-unused-vars","severity":1,"message":"'chat' is defined but never used. Allowed unused args must match /^_/u.","line":416,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":416,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿const express = require('express');\nconst { body, validationResult } = require('express-validator');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs').promises;\nconst { v4: uuidv4 } = require('uuid');\nconst Chat = require('../models/Chat');\nconst User = require('../models/User');\nconst FreightOrder = require('../models/FreightOrder');\nconst { auth } = require('../middleware/auth');\nconst logger = require('../utils/logger');\nconst openaiService = require('../services/openaiService');\nconst cloudflareService = require('../services/cloudflareService');\n\nconst router = express.Router();\n\n// ConfiguraÃ§Ã£o do multer para upload de arquivos\nconst storage = multer.diskStorage({\n  destination: async (req, file, cb) => {\n    const userId = req.user?.id || 'anonymous';\n    const uploadPath = path.join('uploads', 'chats', userId);\n\n    try {\n      await fs.mkdir(uploadPath, { recursive: true });\n      cb(null, uploadPath);\n    } catch (error) {\n      cb(error);\n    }\n  },\n  filename: (req, file, cb) => {\n    const uniqueName = `${uuidv4()}-${file.originalname}`;\n    cb(null, uniqueName);\n  }\n});\n\nconst upload = multer({\n  storage,\n  limits: {\n    fileSize: 10 * 1024 * 1024, // 10MB\n    files: 5\n  },\n  fileFilter: (req, file, cb) => {\n    const allowedTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'image/webp',\n      'audio/mpeg',\n      'audio/wav',\n      'audio/ogg'\n    ];\n\n    if (allowedTypes.includes(file.mimetype)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Tipo de arquivo nÃ£o permitido'), false);\n    }\n  }\n});\n\n/**\n * @swagger\n * /api/chat/send:\n *   post:\n *     summary: Enviar mensagem para o chatbot\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         multipart/form-data:\n *           schema:\n *             type: object\n *             required:\n *               - message\n *             properties:\n *               message:\n *                 type: string\n *               conversationId:\n *                 type: string\n *               attachments:\n *                 type: array\n *                 items:\n *                   type: string\n *                   format: binary\n *     responses:\n *       200:\n *         description: Mensagem enviada com sucesso\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post(\n  '/send',\n  auth,\n  upload.array('attachments', 5),\n  [\n    body('message').notEmpty().withMessage('Mensagem Ã© obrigatÃ³ria'),\n    body('conversationId').optional().isString()\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { message, conversationId } = req.body;\n      const userId = req.user.id;\n      const attachments = req.files || [];\n\n      // Buscar ou criar conversa\n      let chat;\n      if (conversationId) {\n        chat = await Chat.findByConversationId(conversationId);\n        if (!chat || (chat.userId && chat.userId.toString() !== userId)) {\n          return res.status(404).json({\n            success: false,\n            message: 'Conversa nÃ£o encontrada'\n          });\n        }\n      } else {\n        chat = await Chat.createConversation(userId, 'general');\n      }\n\n      // Processar anexos\n      const processedAttachments = [];\n      for (const file of attachments) {\n        const attachment = {\n          type: file.mimetype.startsWith('image/') ? 'image' : 'voice',\n          url: `/uploads/chats/${userId}/${file.filename}`,\n          filename: file.originalname,\n          size: file.size,\n          mimeType: file.mimetype\n        };\n\n        // Se for imagem, gerar caption com IA\n        if (attachment.type === 'image') {\n          try {\n            const caption = await openaiService.generateImageCaption(file.path);\n            attachment.caption = caption;\n            attachment.altText = caption;\n          } catch (error) {\n            logger.error('Erro ao gerar caption da imagem:', error);\n            attachment.caption = 'Imagem enviada';\n            attachment.altText = 'Imagem enviada pelo usuÃ¡rio';\n          }\n        }\n\n        processedAttachments.push(attachment);\n      }\n\n      // Adicionar mensagem do usuÃ¡rio\n      await chat.addMessage('user', message, {\n        attachments: processedAttachments,\n        status: 'delivered'\n      });\n\n      // Verificar se Ã© comando especial (logÃ­stica)\n      const isLogisticsCommand = await handleLogisticsCommand(message, userId, chat);\n\n      let aiResponse = '';\n      if (!isLogisticsCommand) {\n        // Gerar resposta da IA\n        aiResponse = await openaiService.generateResponse(chat.messages, userId);\n      } else {\n        aiResponse = isLogisticsCommand;\n      }\n\n      // Adicionar resposta da IA\n      await chat.addMessage('assistant', aiResponse, {\n        status: 'delivered'\n      });\n\n      logger.info(`Mensagem enviada na conversa ${chat.conversationId} por usuÃ¡rio ${userId}`);\n\n      res.status(200).json({\n        success: true,\n        message: 'Mensagem enviada com sucesso',\n        data: {\n          conversationId: chat.conversationId,\n          userMessage: {\n            role: 'user',\n            text: message,\n            attachments: processedAttachments,\n            timestamp: new Date()\n          },\n          aiResponse: {\n            role: 'assistant',\n            text: aiResponse,\n            timestamp: new Date()\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao enviar mensagem:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/chat/{conversationId}:\n *   get:\n *     summary: Obter histÃ³rico da conversa\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: conversationId\n *         required: true\n *         schema:\n *           type: string\n *     responses:\n *       200:\n *         description: HistÃ³rico da conversa\n *       404:\n *         description: Conversa nÃ£o encontrada\n */\nrouter.get('/:conversationId', auth, async (req, res) => {\n  try {\n    const { conversationId } = req.params;\n    const userId = req.user.id;\n\n    const chat = await Chat.findByConversationId(conversationId);\n\n    if (!chat || (chat.userId && chat.userId.toString() !== userId)) {\n      return res.status(404).json({\n        success: false,\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        conversationId: chat.conversationId,\n        messages: chat.messages,\n        settings: chat.settings,\n        stats: chat.stats,\n        createdAt: chat.createdAt,\n        updatedAt: chat.updatedAt\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter conversa:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/chat/conversations:\n *   get:\n *     summary: Listar conversas do usuÃ¡rio\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       200:\n *         description: Lista de conversas\n */\nrouter.get('/', auth, async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const conversations = await Chat.findByUserId(userId);\n\n    res.status(200).json({\n      success: true,\n      data: {\n        conversations: conversations.map(chat => ({\n          conversationId: chat.conversationId,\n          context: chat.context,\n          lastMessage: chat.lastMessage,\n          messageCount: chat.messageCount,\n          lastActivityAt: chat.stats.lastActivityAt,\n          createdAt: chat.createdAt\n        }))\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao listar conversas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/chat/upload:\n *   post:\n *     summary: Upload de arquivo para chat\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         multipart/form-data:\n *           schema:\n *             type: object\n *             properties:\n *               file:\n *                 type: string\n *                 format: binary\n *     responses:\n *       200:\n *         description: Arquivo enviado com sucesso\n */\nrouter.post('/upload', auth, upload.single('file'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhum arquivo enviado'\n      });\n    }\n\n    const userId = req.user.id;\n    const fileUrl = `/uploads/chats/${userId}/${req.file.filename}`;\n\n    // Se for imagem, gerar caption\n    let caption = null;\n    if (req.file.mimetype.startsWith('image/')) {\n      try {\n        caption = await openaiService.generateImageCaption(req.file.path);\n      } catch (error) {\n        logger.error('Erro ao gerar caption:', error);\n      }\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        url: fileUrl,\n        filename: req.file.originalname,\n        size: req.file.size,\n        mimeType: req.file.mimetype,\n        caption\n      }\n    });\n  } catch (error) {\n    logger.error('Erro no upload:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/chat/voice:\n *   post:\n *     summary: Processar Ã¡udio de voz\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         multipart/form-data:\n *           schema:\n *             type: object\n *             properties:\n *               audio:\n *                 type: string\n *                 format: binary\n *     responses:\n *       200:\n *         description: Ãudio processado com sucesso\n */\nrouter.post('/voice', auth, upload.single('audio'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhum arquivo de Ã¡udio enviado'\n      });\n    }\n\n    // Transcrever Ã¡udio usando OpenAI Whisper\n    const transcription = await openaiService.transcribeAudio(req.file.path);\n\n    res.status(200).json({\n      success: true,\n      data: {\n        transcription,\n        audioUrl: `/uploads/chats/${req.user.id}/${req.file.filename}`\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao processar Ã¡udio:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// FunÃ§Ã£o auxiliar para lidar com comandos de logÃ­stica\nasync function handleLogisticsCommand(message, userId, chat) {\n  const lowerMessage = message.toLowerCase();\n\n  // Verificar se Ã© comando de criaÃ§Ã£o de frete\n  if (lowerMessage.includes('criar frete') || lowerMessage.includes('criar pedido de frete')) {\n    try {\n      // Extrair informaÃ§Ãµes do comando usando IA\n      const freightInfo = await openaiService.extractFreightInfo(message);\n\n      if (freightInfo) {\n        // Criar pedido de frete\n        const freightOrder = new FreightOrder({\n          buyerId: userId,\n          sellerId: freightInfo.sellerId || userId, // Por enquanto, mesmo usuÃ¡rio\n          origin: freightInfo.origin,\n          destination: freightInfo.destination,\n          pickupDate: freightInfo.pickupDate,\n          deliveryDateEstimate: freightInfo.deliveryDateEstimate,\n          items: freightInfo.items,\n          pricing: freightInfo.pricing\n        });\n\n        await freightOrder.save();\n\n        return `âœ… Pedido de frete criado com sucesso!\\n\\nðŸ“‹ **Detalhes do Pedido:**\\n- NÃºmero: ${freightOrder.orderNumber}\\n- Origem: ${freightOrder.origin.city}, ${freightOrder.origin.state}\\n- Destino: ${freightOrder.destination.city}, ${freightOrder.destination.state}\\n- Data de coleta: ${freightOrder.pickupDate.toLocaleDateString('pt-BR')}\\n- PreÃ§o total: R$ ${freightOrder.pricing.totalPrice.toFixed(2)}\\n\\nðŸš› O pedido estÃ¡ aguardando aceitaÃ§Ã£o de transportadores.`;\n      }\n    } catch (error) {\n      logger.error('Erro ao criar pedido de frete:', error);\n      return 'âŒ Erro ao criar pedido de frete. Tente novamente ou use o formulÃ¡rio da plataforma.';\n    }\n  }\n\n  // Verificar se Ã© comando de rastreamento\n  if (lowerMessage.includes('rastrear') || lowerMessage.includes('status do frete')) {\n    try {\n      // Extrair nÃºmero do pedido da mensagem\n      const orderNumber = message.match(/FR-\\d+-\\w+/)?.[0];\n\n      if (orderNumber) {\n        const freightOrder = await FreightOrder.findOne({ orderNumber });\n\n        if (freightOrder) {\n          const lastEvent = freightOrder.trackingEvents[freightOrder.trackingEvents.length - 1];\n          return `ðŸ“¦ **Status do Frete ${orderNumber}:**\\n\\nðŸš› Status atual: ${freightOrder.status}\\nðŸ“ Ãšltima localizaÃ§Ã£o: ${lastEvent?.location?.city || 'NÃ£o informada'}\\nðŸ“… Ãšltima atualizaÃ§Ã£o: ${lastEvent?.timestamp?.toLocaleString('pt-BR') || 'NÃ£o disponÃ­vel'}\\n\\nðŸ’¡ Para mais detalhes, acesse a pÃ¡gina do pedido na plataforma.`;\n        } else {\n          return 'âŒ Pedido de frete nÃ£o encontrado. Verifique o nÃºmero do pedido.';\n        }\n      }\n    } catch (error) {\n      logger.error('Erro ao rastrear frete:', error);\n      return 'âŒ Erro ao consultar status do frete. Tente novamente.';\n    }\n  }\n\n  return null; // NÃ£o Ã© comando especial\n}\n\nmodule.exports = router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\clients.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'requireAdmin' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":22},{"ruleId":"no-unused-vars","severity":1,"message":"'createSecurityLog' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport Client from '../models/Client.js';\nimport User from '../models/User.js';\nimport { authenticateToken, adminAuth } from '../middleware/auth.js';\nimport { requireAdmin } from '../middleware/adminAuth.js';\nimport { getClientIP } from '../utils/ipUtils.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\nimport { logSecurityEvent } from '../services/auditService.js';\nimport {\n  validateReceitaFederal,\n  validateAddressIBGE,\n  validateRequiredDocuments\n} from '../middleware/documentValidation.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Middleware de validaÃ§Ã£o para criaÃ§Ã£o/atualizaÃ§Ã£o de cliente\nconst validateClientData = [\n  body('name')\n    .trim()\n    .isLength({ min: 2, max: 100 })\n    .withMessage('Nome deve ter entre 2 e 100 caracteres'),\n  body('email').isEmail().normalizeEmail().withMessage('Email invÃ¡lido'),\n  body('cpfCnpj').trim().isLength({ min: 11, max: 18 }).withMessage('CPF/CNPJ invÃ¡lido'),\n  body('phone').trim().isLength({ min: 10, max: 15 }).withMessage('Telefone invÃ¡lido'),\n  body('address.street').trim().isLength({ min: 5, max: 200 }).withMessage('EndereÃ§o invÃ¡lido'),\n  body('address.city').trim().isLength({ min: 2, max: 100 }).withMessage('Cidade invÃ¡lida'),\n  body('address.state').trim().isLength({ min: 2, max: 2 }).withMessage('Estado invÃ¡lido'),\n  body('address.zipCode').trim().isLength({ min: 8, max: 9 }).withMessage('CEP invÃ¡lido'),\n  body('documents').isArray({ min: 1 }).withMessage('Pelo menos um documento Ã© obrigatÃ³rio')\n];\n\n// GET /api/clients - Listar clientes (admin vÃª todos, usuÃ¡rio vÃª apenas os seus)\nrouter.get('/', authenticateToken, async (req, res) => {\n  try {\n    const query = {};\n\n    // Se nÃ£o for admin, sÃ³ mostra os clientes do usuÃ¡rio\n    if (!req.user.isAdmin) {\n      query.userId = req.user._id;\n    }\n\n    const clients = await Client.find(query)\n      .populate('userId', 'name email')\n      .sort({ createdAt: -1 });\n\n    res.json({\n      success: true,\n      data: clients,\n      count: clients.length\n    });\n  } catch (error) {\n    logger.error('Erro ao listar clientes:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/clients/:id - Obter cliente especÃ­fico\nrouter.get('/:id', authenticateToken, async (req, res) => {\n  try {\n    const client = await Client.findById(req.params.id).populate('userId', 'name email');\n\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se usuÃ¡rio tem permissÃ£o para ver este cliente\n    if (!req.user.isAdmin && client.userId._id.toString() !== req.user._id.toString()) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: client\n    });\n  } catch (error) {\n    logger.error('Erro ao obter cliente:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/clients - Criar novo cliente\nrouter.post(\n  '/',\n  authenticateToken,\n  validateClientData,\n  validateReceitaFederal,\n  validateAddressIBGE,\n  validateRequiredDocuments,\n  async (req, res) => {\n    try {\n      // Verificar erros de validaÃ§Ã£o\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      // Verificar se CPF/CNPJ jÃ¡ existe\n      const existingClient = await Client.findOne({ cpfCnpj: req.body.cpfCnpj });\n      if (existingClient) {\n        return res.status(400).json({\n          success: false,\n          message: 'CPF/CNPJ jÃ¡ cadastrado'\n        });\n      }\n\n      // Verificar se email jÃ¡ existe\n      const existingEmail = await Client.findOne({ email: req.body.email });\n      if (existingEmail) {\n        return res.status(400).json({\n          success: false,\n          message: 'Email jÃ¡ cadastrado'\n        });\n      }\n\n      // Criar cliente\n      const clientData = {\n        ...req.body,\n        userId: req.user._id\n      };\n\n      const client = new Client(clientData);\n      await client.save();\n\n      // Log de seguranÃ§a\n      await logSecurityEvent(\n        'client_created',\n        req.user._id,\n        getClientIP(req),\n        req.headers['user-agent'],\n        { clientId: client._id }\n      );\n\n      res.status(201).json({\n        success: true,\n        message: 'Cliente criado com sucesso',\n        data: client\n      });\n    } catch (error) {\n      logger.error('Erro ao criar cliente:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// PUT /api/clients/:id - Atualizar cliente\nrouter.put(\n  '/:id',\n  authenticateToken,\n  validateClientData,\n  validateReceitaFederal,\n  validateAddressIBGE,\n  validateRequiredDocuments,\n  async (req, res) => {\n    try {\n      // Verificar erros de validaÃ§Ã£o\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const client = await Client.findById(req.params.id);\n      if (!client) {\n        return res.status(404).json({\n          success: false,\n          message: 'Cliente nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se usuÃ¡rio tem permissÃ£o para editar este cliente\n      if (!req.user.isAdmin && client.userId.toString() !== req.user._id.toString()) {\n        return res.status(403).json({\n          success: false,\n          message: 'Acesso negado'\n        });\n      }\n\n      // Verificar se CPF/CNPJ jÃ¡ existe em outro cliente\n      if (req.body.cpfCnpj && req.body.cpfCnpj !== client.cpfCnpj) {\n        const existingClient = await Client.findOne({ cpfCnpj: req.body.cpfCnpj });\n        if (existingClient) {\n          return res.status(400).json({\n            success: false,\n            message: 'CPF/CNPJ jÃ¡ cadastrado'\n          });\n        }\n      }\n\n      // Verificar se email jÃ¡ existe em outro cliente\n      if (req.body.email && req.body.email !== client.email) {\n        const existingEmail = await Client.findOne({ email: req.body.email });\n        if (existingEmail) {\n          return res.status(400).json({\n            success: false,\n            message: 'Email jÃ¡ cadastrado'\n          });\n        }\n      }\n\n      // Atualizar cliente\n      const updatedClient = await Client.findByIdAndUpdate(req.params.id, req.body, {\n        new: true,\n        runValidators: true\n      });\n\n      // Log de seguranÃ§a\n      await logSecurityEvent(\n        'client_updated',\n        req.user._id,\n        getClientIP(req),\n        req.headers['user-agent'],\n        { clientId: client._id }\n      );\n\n      res.json({\n        success: true,\n        message: 'Cliente atualizado com sucesso',\n        data: updatedClient\n      });\n    } catch (error) {\n      logger.error('Erro ao atualizar cliente:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// DELETE /api/clients/:id - Deletar cliente\nrouter.delete('/:id', authenticateToken, async (req, res) => {\n  try {\n    const client = await Client.findById(req.params.id);\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se usuÃ¡rio tem permissÃ£o para deletar este cliente\n    if (!req.user.isAdmin && client.userId.toString() !== req.user._id.toString()) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    await Client.findByIdAndDelete(req.params.id);\n\n    // Log de seguranÃ§a\n    await logSecurityEvent(\n      'client_deleted',\n      req.user._id,\n      getClientIP(req),\n      req.headers['user-agent'],\n      { clientId: client._id }\n    );\n\n    res.json({\n      success: true,\n      message: 'Cliente deletado com sucesso'\n    });\n  } catch (error) {\n    logger.error('Erro ao deletar cliente:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/clients/:id/validate-documents - Validar documentos (admin)\nrouter.patch('/:id/validate-documents', adminAuth, async (req, res) => {\n  try {\n    const client = await Client.findById(req.params.id);\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    client.isDocumentValidated = true;\n    await client.save();\n\n    // Log de seguranÃ§a\n    await logSecurityEvent(\n      'client_documents_validated',\n      req.user._id,\n      getClientIP(req),\n      req.headers['user-agent'],\n      { clientId: client._id }\n    );\n\n    res.json({\n      success: true,\n      message: 'Documentos validados com sucesso',\n      data: client\n    });\n  } catch (error) {\n    logger.error('Erro ao validar documentos:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/clients/:id/verify-payment - Verificar pagamento (admin)\nrouter.patch('/:id/verify-payment', adminAuth, async (req, res) => {\n  try {\n    const { paymentStatus, transactionId } = req.body;\n\n    if (\n      !paymentStatus ||\n      !['pending', 'approved', 'rejected', 'cancelled'].includes(paymentStatus)\n    ) {\n      return res.status(400).json({\n        success: false,\n        message: 'Status de pagamento invÃ¡lido'\n      });\n    }\n\n    const client = await Client.findById(req.params.id);\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    client.paymentStatus = paymentStatus;\n    if (transactionId) {\n      client.transactionId = transactionId;\n    }\n\n    if (paymentStatus === 'approved') {\n      client.isPaymentVerified = true;\n    }\n\n    await client.save();\n\n    // Log de seguranÃ§a\n    await logSecurityEvent(\n      'client_payment_verified',\n      req.user._id,\n      getClientIP(req),\n      req.headers['user-agent'],\n      { clientId: client._id, paymentStatus, transactionId }\n    );\n\n    res.json({\n      success: true,\n      message: 'Pagamento verificado com sucesso',\n      data: client\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar pagamento:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/clients/stats/overview - EstatÃ­sticas gerais (admin)\nrouter.get('/stats/overview', adminAuth, async (req, res) => {\n  try {\n    const stats = await Client.aggregate([\n      {\n        $group: {\n          _id: null,\n          total: { $sum: 1 },\n          validated: { $sum: { $cond: ['$isDocumentValidated', 1, 0] } },\n          paymentVerified: { $sum: { $cond: ['$isPaymentVerified', 1, 0] } },\n          active: { $sum: { $cond: ['$isActive', 1, 0] } }\n        }\n      }\n    ]);\n\n    const paymentStats = await Client.aggregate([\n      {\n        $group: {\n          _id: '$paymentStatus',\n          count: { $sum: 1 }\n        }\n      }\n    ]);\n\n    const monthlyStats = await Client.aggregate([\n      {\n        $group: {\n          _id: {\n            year: { $year: '$createdAt' },\n            month: { $month: '$createdAt' }\n          },\n          count: { $sum: 1 }\n        }\n      },\n      { $sort: { '_id.year': -1, '_id.month': -1 } },\n      { $limit: 12 }\n    ]);\n\n    res.json({\n      success: true,\n      data: {\n        overview: stats[0] || { total: 0, validated: 0, paymentVerified: 0, active: 0 },\n        paymentStatus: paymentStats,\n        monthlyGrowth: monthlyStats\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter estatÃ­sticas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\conversations.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'requireProductMessagingAccess' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":32},{"ruleId":"no-unused-vars","severity":1,"message":"'requireFreightMessagingAccess' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport mongoose from 'mongoose';\nimport Conversation from '../models/Conversation.js';\nimport Message from '../models/Message.js';\nimport User from '../models/User.js';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport AuditLog from '../models/AuditLog.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport {\n  requireProductMessagingAccess,\n  requireFreightMessagingAccess\n} from '../middleware/requirePaidAccess.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// ===== VALIDAÃ‡ÃƒO DE DADOS =====\n\nconst validateConversationData = (req, res, next) => {\n  const { serviceType, serviceId, participants } = req.body;\n\n  if (!serviceType || !['product', 'freight'].includes(serviceType)) {\n    return res.status(400).json({\n      ok: false,\n      error: 'invalid_service_type',\n      message: 'Tipo de serviÃ§o deve ser \"product\" ou \"freight\"'\n    });\n  }\n\n  if (!serviceId || !mongoose.Types.ObjectId.isValid(serviceId)) {\n    return res.status(400).json({\n      ok: false,\n      error: 'invalid_service_id',\n      message: 'ID do serviÃ§o invÃ¡lido'\n    });\n  }\n\n  if (!participants || !Array.isArray(participants) || participants.length < 2) {\n    return res.status(400).json({\n      ok: false,\n      error: 'invalid_participants',\n      message: 'Deve haver pelo menos 2 participantes'\n    });\n  }\n\n  // Verificar se o usuÃ¡rio atual estÃ¡ nos participantes\n  if (!participants.includes(req.user.userId)) {\n    return res.status(400).json({\n      ok: false,\n      error: 'unauthorized_participant',\n      message: 'VocÃª deve ser um dos participantes da conversa'\n    });\n  }\n\n  next();\n};\n\nconst validateMessageData = (req, res, next) => {\n  const { content } = req.body;\n\n  if (!content || content.trim().length === 0) {\n    return res.status(400).json({\n      ok: false,\n      error: 'empty_message',\n      message: 'Mensagem nÃ£o pode estar vazia'\n    });\n  }\n\n  if (content.trim().length > 5000) {\n    return res.status(400).json({\n      ok: false,\n      error: 'message_too_long',\n      message: 'Mensagem deve ter no mÃ¡ximo 5000 caracteres'\n    });\n  }\n\n  next();\n};\n\n// ===== ROTAS DE CONVERSAS =====\n\n// GET /api/conversations - Listar conversas do usuÃ¡rio\nrouter.get('/', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { serviceType, page = 1, limit = 20, status } = req.query;\n\n    const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n\n    // Construir query\n    const query = {\n      participants: userId,\n      status: { $ne: 'deleted' }\n    };\n\n    if (serviceType && ['product', 'freight'].includes(serviceType)) {\n      query.serviceType = serviceType;\n    }\n\n    if (status && ['active', 'archived', 'closed', 'blocked'].includes(status)) {\n      query.status = status;\n    }\n\n    // Buscar conversas\n    const conversations = await Conversation.find(query)\n      .sort({ lastMessageAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10))\n      .populate('participants', 'name email company.name')\n      .populate('lastMessage.senderId', 'name email')\n      .populate('serviceId', 'name title origin destination price images');\n\n    // Contar total\n    const total = await Conversation.countDocuments(query);\n\n    // Log de acesso\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversations_listed',\n      resource: 'conversation',\n      resourceType: 'Conversation',\n      details: `Listed ${conversations.length} conversations`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { serviceType, page, limit, total }\n    });\n\n    res.json({\n      ok: true,\n      data: {\n        conversations,\n        pagination: {\n          currentPage: parseInt(page, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10)\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Error listing conversations:', error);\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error listing conversations: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/conversations - Criar nova conversa\nrouter.post('/', authenticateToken, validateConversationData, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { serviceType, serviceId, participants, title } = req.body;\n\n    // Verificar se o serviÃ§o existe\n    let service;\n    if (serviceType === 'product') {\n      service = await Product.findById(serviceId);\n    } else {\n      service = await Freight.findById(serviceId);\n    }\n\n    if (!service) {\n      return res.status(404).json({\n        ok: false,\n        error: 'service_not_found',\n        message: 'ServiÃ§o nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se jÃ¡ existe conversa entre estes usuÃ¡rios para este serviÃ§o\n    const existingConversation = await Conversation.findBetweenUsers(\n      participants[0],\n      participants[1],\n      serviceId,\n      serviceType\n    );\n\n    if (existingConversation) {\n      return res.status(409).json({\n        ok: false,\n        error: 'conversation_exists',\n        message: 'Conversa jÃ¡ existe para este serviÃ§o',\n        data: { conversationId: existingConversation._id }\n      });\n    }\n\n    // Criar conversa\n    const conversation = await Conversation.createConversation(\n      participants,\n      serviceId,\n      serviceType,\n      title\n    );\n\n    // Populate dados\n    await conversation.populate([\n      { path: 'participants', select: 'name email company.name' },\n      { path: 'serviceId', select: 'name title origin destination price images' }\n    ]);\n\n    // Log de criaÃ§Ã£o\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversation_created',\n      resource: 'conversation',\n      resourceId: conversation._id,\n      resourceType: 'Conversation',\n      details: `Created conversation for ${serviceType} service`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { serviceType, serviceId, participants }\n    });\n\n    res.status(201).json({\n      ok: true,\n      message: 'Conversa criada com sucesso',\n      data: { conversation }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating conversation:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error creating conversation: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/conversations/:id - Obter conversa especÃ­fica\nrouter.get('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    const conversation = await Conversation.findById(conversationId)\n      .populate('participants', 'name email company.name')\n      .populate('serviceId', 'name title origin destination price images')\n      .populate('lastMessage.senderId', 'name email');\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio Ã© participante\n    if (!conversation.participants.some(p => p._id.toString() === userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to access conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Log de acesso\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversation_accessed',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: 'Accessed conversation details',\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      ok: true,\n      data: { conversation }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching conversation:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching conversation: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/conversations/:id - Atualizar conversa\nrouter.put('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n    const { title, status } = req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    const conversation = await Conversation.findById(conversationId);\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio Ã© participante\n    if (!conversation.participants.includes(userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to update conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Atualizar campos permitidos\n    if (title !== undefined) {\n      conversation.title = title;\n    }\n    if (status !== undefined && ['active', 'archived', 'closed'].includes(status)) {\n      conversation.status = status;\n    }\n\n    await conversation.save();\n\n    // Log de atualizaÃ§Ã£o\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversation_updated',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: 'Updated conversation',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { title, status }\n    });\n\n    res.json({\n      ok: true,\n      message: 'Conversa atualizada com sucesso',\n      data: { conversation }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating conversation:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error updating conversation: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE MENSAGENS =====\n\n// GET /api/conversations/:id/messages - Listar mensagens de uma conversa\nrouter.get('/:id/messages', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n    const { page = 1, limit = 50 } = req.query;\n\n    const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    // Verificar se a conversa existe e se o usuÃ¡rio Ã© participante\n    const conversation = await Conversation.findById(conversationId);\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    if (!conversation.participants.includes(userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to access messages from conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Buscar mensagens\n    const messages = await Message.find({\n      conversationId,\n      status: { $ne: 'deleted' }\n    })\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10))\n      .populate('senderId', 'name email company.name')\n      .populate('receiverId', 'name email company.name');\n\n    // Contar total\n    const total = await Message.countDocuments({\n      conversationId,\n      status: { $ne: 'deleted' }\n    });\n\n    // Marcar mensagens como lidas se o usuÃ¡rio for o destinatÃ¡rio\n    const unreadMessages = messages.filter(\n      msg => msg.receiverId._id.toString() === userId && !msg.isRead\n    );\n\n    if (unreadMessages.length > 0) {\n      await Message.updateMany(\n        { _id: { $in: unreadMessages.map(m => m._id) } },\n        { $set: { isRead: true, readAt: new Date() } }\n      );\n    }\n\n    // Log de acesso\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'messages_accessed',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: `Accessed ${messages.length} messages`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { page, limit, total, unreadCount: unreadMessages.length }\n    });\n\n    res.json({\n      ok: true,\n      data: {\n        messages: messages.reverse(), // Ordem cronolÃ³gica\n        pagination: {\n          currentPage: parseInt(page, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching messages:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching messages: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/conversations/:id/messages - Enviar mensagem\nrouter.post('/:id/messages', authenticateToken, validateMessageData, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n    const { content, attachments = [] } = req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    // Verificar se a conversa existe e se o usuÃ¡rio Ã© participante\n    const conversation = await Conversation.findById(conversationId);\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    if (!conversation.participants.includes(userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to send message to conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Verificar se a conversa nÃ£o estÃ¡ bloqueada\n    if (conversation.status === 'blocked') {\n      return res.status(403).json({\n        ok: false,\n        error: 'conversation_blocked',\n        message: 'Esta conversa foi bloqueada'\n      });\n    }\n\n    // Encontrar destinatÃ¡rio (outro participante)\n    const recipientId = conversation.participants.find(p => p.toString() !== userId);\n\n    // Criar mensagem\n    const message = new Message({\n      conversationId,\n      senderId: userId,\n      receiverId: recipientId,\n      content: content.trim(),\n      attachments,\n      messageType: conversation.serviceType === 'product' ? 'product_inquiry' : 'freight_request',\n      messagingCategory: conversation.serviceType === 'product' ? 'products' : 'freights'\n    });\n\n    await message.save();\n\n    // Atualizar conversa\n    await conversation.updateLastMessage(content, userId);\n    conversation.unreadCount += 1;\n    await conversation.save();\n\n    // Populate dados da mensagem\n    await message.populate([\n      { path: 'senderId', select: 'name email company.name' },\n      { path: 'receiverId', select: 'name email company.name' }\n    ]);\n\n    // Log de envio\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'message_sent',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: 'Sent message in conversation',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: {\n        messageId: message._id,\n        contentLength: content.length,\n        attachmentsCount: attachments.length\n      }\n    });\n\n    res.status(201).json({\n      ok: true,\n      message: 'Mensagem enviada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error sending message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error sending message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE ESTATÃSTICAS =====\n\n// GET /api/conversations/stats - EstatÃ­sticas das conversas\nrouter.get('/stats/summary', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const stats = await Conversation.getStats(userId);\n\n    res.json({\n      ok: true,\n      data: { stats }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching conversation stats:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching conversation stats: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\crypto.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":21,"column":61,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":21,"endColumn":63},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":66,"column":55,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":66,"endColumn":57},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":111,"column":55,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":111,"endColumn":57},{"ruleId":"no-unused-vars","severity":1,"message":"'iv' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":123,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":13},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":152,"column":52,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":152,"endColumn":54},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":188,"column":64,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":188,"endColumn":66},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":228,"column":52,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":228,"endColumn":54},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":266,"column":64,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":266,"endColumn":66},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":304,"column":62,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":304,"endColumn":64}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport crypto from 'crypto';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Middleware de autenticaÃ§Ã£o para rotas criptografadas\nconst requireAuth = (req, res, next) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Token de autenticaÃ§Ã£o necessÃ¡rio'\n    });\n  }\n  // Aqui vocÃª validaria o JWT token\n  next();\n};\n\n// Gerar chaves de criptografia\nrouter.post('/generate-keys', requireAuth, async (req, res) => {\n  try {\n    const { algorithm = 'aes-256-gcm' } = req.body;\n\n    // Gerar chave simÃ©trica\n    const symmetricKey = crypto.randomBytes(32);\n\n    // Gerar par de chaves assimÃ©tricas\n    const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {\n      modulusLength: 2048,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    });\n\n    const keyData = {\n      symmetricKey: symmetricKey.toString('base64'),\n      publicKey,\n      privateKey,\n      algorithm,\n      timestamp: new Date().toISOString()\n    };\n\n    logger.info('Chaves de criptografia geradas com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Chaves geradas com sucesso',\n      data: keyData\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar chaves:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Criptografar dados\nrouter.post('/encrypt', requireAuth, async (req, res) => {\n  try {\n    const { data, key, algorithm = 'aes-256-gcm' } = req.body;\n\n    if (!data || !key) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados e chave sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const keyBuffer = Buffer.from(key, 'base64');\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher(algorithm, keyBuffer);\n\n    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'base64');\n    encrypted += cipher.final('base64');\n\n    const authTag = cipher.getAuthTag ? cipher.getAuthTag() : null;\n\n    const encryptedData = {\n      encrypted,\n      iv: iv.toString('base64'),\n      algorithm,\n      authTag: authTag ? authTag.toString('base64') : null,\n      timestamp: new Date().toISOString()\n    };\n\n    logger.info('Dados criptografados com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Dados criptografados com sucesso',\n      data: encryptedData\n    });\n  } catch (error) {\n    logger.error('Erro ao criptografar dados:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao criptografar dados'\n    });\n  }\n});\n\n// Descriptografar dados\nrouter.post('/decrypt', requireAuth, async (req, res) => {\n  try {\n    const { encryptedData, key } = req.body;\n\n    if (!encryptedData || !key) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados criptografados e chave sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const keyBuffer = Buffer.from(key, 'base64');\n    const iv = Buffer.from(encryptedData.iv, 'base64');\n    const decipher = crypto.createDecipher(encryptedData.algorithm, keyBuffer);\n\n    if (encryptedData.authTag) {\n      decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'base64'));\n    }\n\n    let decrypted = decipher.update(encryptedData.encrypted, 'base64', 'utf8');\n    decrypted += decipher.final('utf8');\n\n    const data = JSON.parse(decrypted);\n\n    logger.info('Dados descriptografados com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Dados descriptografados com sucesso',\n      data\n    });\n  } catch (error) {\n    logger.error('Erro ao descriptografar dados:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao descriptografar dados'\n    });\n  }\n});\n\n// Hash de dados\nrouter.post('/hash', requireAuth, async (req, res) => {\n  try {\n    const { data, algorithm = 'sha256' } = req.body;\n\n    if (!data) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const hash = crypto.createHash(algorithm);\n    hash.update(JSON.stringify(data));\n    const hashValue = hash.digest('hex');\n\n    logger.info('Hash gerado com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Hash gerado com sucesso',\n      data: {\n        hash: hashValue,\n        algorithm,\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar hash:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao gerar hash'\n    });\n  }\n});\n\n// Verificar integridade\nrouter.post('/verify-integrity', requireAuth, async (req, res) => {\n  try {\n    const { data, hash, algorithm = 'sha256' } = req.body;\n\n    if (!data || !hash) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados e hash sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const newHash = crypto.createHash(algorithm);\n    newHash.update(JSON.stringify(data));\n    const calculatedHash = newHash.digest('hex');\n\n    const isValid = calculatedHash === hash;\n\n    logger.info(`VerificaÃ§Ã£o de integridade: ${isValid ? 'vÃ¡lida' : 'invÃ¡lida'}`);\n\n    res.json({\n      success: true,\n      message: 'VerificaÃ§Ã£o de integridade concluÃ­da',\n      data: {\n        isValid,\n        originalHash: hash,\n        calculatedHash,\n        algorithm,\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar integridade:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar integridade'\n    });\n  }\n});\n\n// Assinar dados digitalmente\nrouter.post('/sign', requireAuth, async (req, res) => {\n  try {\n    const { data, privateKey } = req.body;\n\n    if (!data || !privateKey) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados e chave privada sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const sign = crypto.createSign('SHA256');\n    sign.update(JSON.stringify(data));\n    sign.end();\n\n    const signature = sign.sign(privateKey, 'base64');\n\n    logger.info('Dados assinados digitalmente com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Dados assinados com sucesso',\n      data: {\n        signature,\n        algorithm: 'SHA256',\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao assinar dados:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao assinar dados'\n    });\n  }\n});\n\n// Verificar assinatura digital\nrouter.post('/verify-signature', requireAuth, async (req, res) => {\n  try {\n    const { data, signature, publicKey } = req.body;\n\n    if (!data || !signature || !publicKey) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados, assinatura e chave pÃºblica sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const verify = crypto.createVerify('SHA256');\n    verify.update(JSON.stringify(data));\n    verify.end();\n\n    const isValid = verify.verify(publicKey, signature, 'base64');\n\n    logger.info(`VerificaÃ§Ã£o de assinatura: ${isValid ? 'vÃ¡lida' : 'invÃ¡lida'}`);\n\n    res.json({\n      success: true,\n      message: 'VerificaÃ§Ã£o de assinatura concluÃ­da',\n      data: {\n        isValid,\n        algorithm: 'SHA256',\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar assinatura:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar assinatura'\n    });\n  }\n});\n\n// Gerar nonce\nrouter.post('/generate-nonce', requireAuth, async (req, res) => {\n  try {\n    const { length = 32 } = req.body;\n\n    const nonce = crypto.randomBytes(length).toString('hex');\n\n    logger.info('Nonce gerado com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Nonce gerado com sucesso',\n      data: {\n        nonce,\n        length,\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar nonce:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao gerar nonce'\n    });\n  }\n});\n\n// Status das rotas criptografadas\nrouter.get('/status', (req, res) => {\n  res.json({\n    success: true,\n    message: 'Rotas criptografadas ativas',\n    data: {\n      status: 'online',\n      algorithms: ['aes-256-gcm', 'sha256', 'rsa'],\n      endpoints: [\n        'POST /crypto/generate-keys',\n        'POST /crypto/encrypt',\n        'POST /crypto/decrypt',\n        'POST /crypto/hash',\n        'POST /crypto/verify-integrity',\n        'POST /crypto/sign',\n        'POST /crypto/verify-signature',\n        'POST /crypto/generate-nonce'\n      ],\n      timestamp: new Date().toISOString()\n    }\n  });\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\dashboard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\data-access.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'User' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":5,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿const express = require('express');\nconst router = express.Router();\nconst auth = require('../middleware/auth');\nconst { Payment } = require('../models/Payment');\nconst { User } = require('../models/User');\nconst { Product } = require('../models/Product');\nconst { AuditLog } = require('../models/AuditLog');\nconst { SecurityLog } = require('../models/SecurityLog');\n\nconst logger = require('../utils/logger.js');\n// Verificar se usuÃ¡rio tem acesso aos dados de um anÃºncio\nrouter.get('/check-access/:adId', auth, async (req, res) => {\n  try {\n    const { adId } = req.params;\n    const userId = req.user.id;\n\n    // Verificar se existe pagamento aprovado para este anÃºncio\n    const payment = await Payment.findOne({\n      userId,\n      adId,\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    const hasAccess = !!payment;\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'check_data_access',\n      resource: `ad_${adId}`,\n      details: { hasAccess, adId },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({ hasAccess, adId });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar acesso:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Liberar dados apÃ³s pagamento confirmado\nrouter.post('/unlock-data', auth, async (req, res) => {\n  try {\n    const { userId, adId } = req.body;\n    const currentUserId = req.user.id;\n\n    // Verificar se o usuÃ¡rio tem permissÃ£o\n    if (userId !== currentUserId) {\n      return res.status(403).json({ error: 'Acesso negado' });\n    }\n\n    // Verificar se existe pagamento aprovado\n    const payment = await Payment.findOne({\n      userId,\n      adId,\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    if (!payment) {\n      return res.status(400).json({ error: 'Pagamento nÃ£o encontrado ou nÃ£o aprovado' });\n    }\n\n    // Marcar dados como liberados\n    payment.dataUnlocked = true;\n    payment.unlockedAt = new Date();\n    await payment.save();\n\n    // Buscar dados do anÃºncio\n    const product = await Product.findById(adId);\n    if (!product) {\n      return res.status(404).json({ error: 'AnÃºncio nÃ£o encontrado' });\n    }\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'unlock_data_access',\n      resource: `ad_${adId}`,\n      details: { adId, paymentId: payment._id },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    // Log de seguranÃ§a\n    await SecurityLog.create({\n      userId,\n      action: 'data_unlock',\n      resource: `ad_${adId}`,\n      severity: 'medium',\n      details: { adId, paymentId: payment._id },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'Dados liberados com sucesso',\n      unlockedAt: payment.unlockedAt,\n      adData: {\n        title: product.title,\n        userName: product.userName,\n        phone: product.phone,\n        email: product.email,\n        location: product.location,\n        description: product.description\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao liberar dados:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Obter dados liberados de um anÃºncio\nrouter.get('/unlocked-data/:adId', auth, async (req, res) => {\n  try {\n    const { adId } = req.params;\n    const userId = req.user.id;\n\n    // Verificar se usuÃ¡rio tem acesso\n    const payment = await Payment.findOne({\n      userId,\n      adId,\n      status: 'succeeded',\n      type: 'individual',\n      dataUnlocked: true\n    });\n\n    if (!payment) {\n      return res.status(403).json({ error: 'Acesso negado aos dados' });\n    }\n\n    // Buscar dados do anÃºncio\n    const product = await Product.findById(adId);\n    if (!product) {\n      return res.status(404).json({ error: 'AnÃºncio nÃ£o encontrado' });\n    }\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'access_unlocked_data',\n      resource: `ad_${adId}`,\n      details: { adId },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      adData: {\n        title: product.title,\n        userName: product.userName,\n        phone: product.phone,\n        email: product.email,\n        location: product.location,\n        description: product.description,\n        images: product.images,\n        price: product.price,\n        category: product.category\n      },\n      unlockedAt: payment.unlockedAt,\n      paymentId: payment._id\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter dados liberados:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Configurar opÃ§Ãµes de liberaÃ§Ã£o para anunciante\nrouter.post('/configure-release/:adId', auth, async (req, res) => {\n  try {\n    const { adId } = req.params;\n    const userId = req.user.id;\n    const {\n      autoRelease = false,\n      releaseDelay = 0,\n      requireVerification = true,\n      customMessage = ''\n    } = req.body;\n\n    // Verificar se o usuÃ¡rio Ã© o dono do anÃºncio\n    const product = await Product.findById(adId);\n    if (!product) {\n      return res.status(404).json({ error: 'AnÃºncio nÃ£o encontrado' });\n    }\n\n    if (product.userId.toString() !== userId) {\n      return res.status(403).json({ error: 'Acesso negado' });\n    }\n\n    // Atualizar configuraÃ§Ãµes de liberaÃ§Ã£o\n    product.releaseSettings = {\n      autoRelease,\n      releaseDelay,\n      requireVerification,\n      customMessage,\n      updatedAt: new Date()\n    };\n\n    await product.save();\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'configure_data_release',\n      resource: `ad_${adId}`,\n      details: {\n        autoRelease,\n        releaseDelay,\n        requireVerification,\n        customMessage\n      },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'ConfiguraÃ§Ãµes de liberaÃ§Ã£o atualizadas',\n      releaseSettings: product.releaseSettings\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao configurar liberaÃ§Ã£o:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Obter estatÃ­sticas de liberaÃ§Ã£o de dados\nrouter.get('/release-stats', auth, async (req, res) => {\n  try {\n    const userId = req.user.id;\n\n    // EstatÃ­sticas do usuÃ¡rio\n    const totalPayments = await Payment.countDocuments({\n      userId,\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    const unlockedData = await Payment.countDocuments({\n      userId,\n      status: 'succeeded',\n      type: 'individual',\n      dataUnlocked: true\n    });\n\n    const totalSpent = await Payment.aggregate([\n      {\n        $match: {\n          userId,\n          status: 'succeeded',\n          type: 'individual'\n        }\n      },\n      {\n        $group: {\n          _id: null,\n          total: { $sum: '$amount' }\n        }\n      }\n    ]);\n\n    // EstatÃ­sticas dos anÃºncios do usuÃ¡rio\n    const userProducts = await Product.find({ userId });\n    const productIds = userProducts.map(p => p._id);\n\n    const paymentsReceived = await Payment.countDocuments({\n      adId: { $in: productIds },\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    const totalEarned = await Payment.aggregate([\n      {\n        $match: {\n          adId: { $in: productIds },\n          status: 'succeeded',\n          type: 'individual'\n        }\n      },\n      {\n        $group: {\n          _id: null,\n          total: { $sum: '$amount' }\n        }\n      }\n    ]);\n\n    res.json({\n      buyerStats: {\n        totalPayments,\n        unlockedData,\n        totalSpent: totalSpent[0]?.total || 0\n      },\n      sellerStats: {\n        totalProducts: userProducts.length,\n        paymentsReceived,\n        totalEarned: totalEarned[0]?.total || 0\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\nmodule.exports = router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\escrow.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async function 'processStripePayment' has no 'await' expression.","line":459,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":459,"endColumn":36},{"ruleId":"no-unused-vars","severity":1,"message":"'escrow' is defined but never used. Allowed unused args must match /^_/u.","line":459,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":459,"endColumn":43},{"ruleId":"no-unused-vars","severity":1,"message":"'paymentData' is defined but never used. Allowed unused args must match /^_/u.","line":459,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":459,"endColumn":56},{"ruleId":"require-await","severity":1,"message":"Async function 'processMetaMaskPayment' has no 'await' expression.","line":475,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":475,"endColumn":38},{"ruleId":"no-unused-vars","severity":1,"message":"'escrow' is defined but never used. Allowed unused args must match /^_/u.","line":475,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":475,"endColumn":45},{"ruleId":"no-unused-vars","severity":1,"message":"'paymentData' is defined but never used. Allowed unused args must match /^_/u.","line":475,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":475,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport Escrow from '../models/Escrow.js';\nimport Payment from '../models/Payment.js';\nimport User from '../models/User.js';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { body, validationResult } from 'express-validator';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// POST /api/escrow/create - Criar escrow\nrouter.post(\n  '/create',\n  authenticateToken,\n  [\n    body('itemId').isMongoId().withMessage('ID do item invÃ¡lido'),\n    body('itemType').isIn(['product', 'freight']).withMessage('Tipo de item invÃ¡lido'),\n    body('amount').isFloat({ min: 0.01 }).withMessage('Valor deve ser maior que zero'),\n    body('description').notEmpty().withMessage('DescriÃ§Ã£o Ã© obrigatÃ³ria')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { itemId, itemType, amount, description } = req.body;\n      const buyerId = req.user.id;\n\n      // Buscar item\n      let item;\n      if (itemType === 'product') {\n        item = await Product.findById(itemId);\n      } else {\n        item = await Freight.findById(itemId);\n      }\n\n      if (!item) {\n        return res.status(404).json({\n          success: false,\n          message: 'Item nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o comprador nÃ£o Ã© o prÃ³prio vendedor\n      if (item.owner.toString() === buyerId) {\n        return res.status(400).json({\n          success: false,\n          message: 'VocÃª nÃ£o pode comprar seu prÃ³prio item'\n        });\n      }\n\n      // Verificar se jÃ¡ existe escrow ativo para este item\n      const existingEscrow = await Escrow.findOne({\n        itemId,\n        itemType,\n        buyerId,\n        status: { $in: ['pending', 'funded'] }\n      });\n\n      if (existingEscrow) {\n        return res.status(400).json({\n          success: false,\n          message: 'JÃ¡ existe uma transaÃ§Ã£o em andamento para este item'\n        });\n      }\n\n      // Criar escrow\n      const escrow = new Escrow({\n        itemId,\n        itemType,\n        sellerId: item.owner,\n        buyerId,\n        amount: parseFloat(amount),\n        description,\n        status: 'pending',\n        createdAt: new Date(),\n        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 dias\n      });\n\n      await escrow.save();\n\n      // Buscar dados do vendedor\n      const seller = await User.findById(item.owner).select('name email company');\n\n      res.json({\n        success: true,\n        message: 'Escrow criado com sucesso',\n        data: {\n          escrowId: escrow._id,\n          item: {\n            id: item._id,\n            name: item.name || `${item.origin} â†’ ${item.destination}`,\n            type: itemType\n          },\n          seller: {\n            id: seller._id,\n            name: seller.name,\n            company: seller.company\n          },\n          amount: escrow.amount,\n          status: escrow.status,\n          expiresAt: escrow.expiresAt\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao criar escrow:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// POST /api/escrow/fund - Financiar escrow\nrouter.post(\n  '/fund',\n  authenticateToken,\n  [\n    body('escrowId').isMongoId().withMessage('ID do escrow invÃ¡lido'),\n    body('paymentMethod')\n      .isIn(['stripe', 'metamask'])\n      .withMessage('MÃ©todo de pagamento invÃ¡lido'),\n    body('paymentData').isObject().withMessage('Dados de pagamento sÃ£o obrigatÃ³rios')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { escrowId, paymentMethod, paymentData } = req.body;\n      const userId = req.user.id;\n\n      // Buscar escrow\n      const escrow = await Escrow.findById(escrowId);\n      if (!escrow) {\n        return res.status(404).json({\n          success: false,\n          message: 'Escrow nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio Ã© o comprador\n      if (escrow.buyerId.toString() !== userId) {\n        return res.status(403).json({\n          success: false,\n          message: 'Acesso negado'\n        });\n      }\n\n      // Verificar se escrow ainda estÃ¡ pendente\n      if (escrow.status !== 'pending') {\n        return res.status(400).json({\n          success: false,\n          message: 'Escrow nÃ£o estÃ¡ mais pendente'\n        });\n      }\n\n      // Verificar se nÃ£o expirou\n      if (escrow.expiresAt < new Date()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Escrow expirado'\n        });\n      }\n\n      // Processar pagamento baseado no mÃ©todo\n      let paymentResult;\n      if (paymentMethod === 'stripe') {\n        paymentResult = await processStripePayment(escrow, paymentData);\n      } else if (paymentMethod === 'metamask') {\n        paymentResult = await processMetaMaskPayment(escrow, paymentData);\n      }\n\n      if (!paymentResult.success) {\n        return res.status(400).json({\n          success: false,\n          message: paymentResult.message || 'Erro ao processar pagamento'\n        });\n      }\n\n      // Atualizar escrow\n      escrow.status = 'funded';\n      escrow.paymentId = paymentResult.paymentId;\n      escrow.paymentMethod = paymentMethod;\n      escrow.fundedAt = new Date();\n      await escrow.save();\n\n      // Criar registro de pagamento\n      const payment = new Payment({\n        userId: escrow.buyerId,\n        amount: escrow.amount,\n        currency: 'BRL',\n        status: 'completed',\n        provider: paymentMethod,\n        purpose: 'escrow_funding',\n        metadata: {\n          escrowId: escrow._id,\n          itemId: escrow.itemId,\n          itemType: escrow.itemType\n        }\n      });\n      await payment.save();\n\n      res.json({\n        success: true,\n        message: 'Escrow financiado com sucesso',\n        data: {\n          escrowId: escrow._id,\n          status: escrow.status,\n          fundedAt: escrow.fundedAt,\n          paymentId: payment._id\n        }\n      });\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao financiar escrow:', error);\n      }\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// POST /api/escrow/release - Liberar pagamento\nrouter.post(\n  '/release',\n  authenticateToken,\n  [\n    body('escrowId').isMongoId().withMessage('ID do escrow invÃ¡lido'),\n    body('action').isIn(['release', 'dispute']).withMessage('AÃ§Ã£o invÃ¡lida'),\n    body('reason').optional().isString().withMessage('Motivo deve ser texto')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { escrowId, action, reason } = req.body;\n      const userId = req.user.id;\n\n      // Buscar escrow\n      const escrow = await Escrow.findById(escrowId);\n      if (!escrow) {\n        return res.status(404).json({\n          success: false,\n          message: 'Escrow nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio Ã© o comprador ou vendedor\n      if (escrow.buyerId.toString() !== userId && escrow.sellerId.toString() !== userId) {\n        return res.status(403).json({\n          success: false,\n          message: 'Acesso negado'\n        });\n      }\n\n      // Verificar se escrow estÃ¡ financiado\n      if (escrow.status !== 'funded') {\n        return res.status(400).json({\n          success: false,\n          message: 'Escrow nÃ£o estÃ¡ financiado'\n        });\n      }\n\n      if (action === 'release') {\n        // Liberar pagamento para o vendedor\n        escrow.status = 'released';\n        escrow.releasedAt = new Date();\n        escrow.releasedBy = userId;\n        escrow.releaseReason = reason || 'Pagamento liberado pelo comprador';\n\n        // Buscar vendedor\n        const seller = await User.findById(escrow.sellerId);\n        if (seller) {\n          // Aqui vocÃª implementaria a lÃ³gica de transferÃªncia real\n          // Por enquanto, apenas marcar como liberado\n          seller.balance = (seller.balance || 0) + escrow.amount;\n          await seller.save();\n        }\n\n        await escrow.save();\n\n        res.json({\n          success: true,\n          message: 'Pagamento liberado com sucesso',\n          data: {\n            escrowId: escrow._id,\n            status: escrow.status,\n            releasedAt: escrow.releasedAt\n          }\n        });\n      } else if (action === 'dispute') {\n        // Abrir disputa\n        escrow.status = 'disputed';\n        escrow.disputedAt = new Date();\n        escrow.disputedBy = userId;\n        escrow.disputeReason = reason || 'Disputa aberta';\n\n        await escrow.save();\n\n        res.json({\n          success: true,\n          message: 'Disputa aberta com sucesso',\n          data: {\n            escrowId: escrow._id,\n            status: escrow.status,\n            disputedAt: escrow.disputedAt\n          }\n        });\n      }\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao processar escrow:', error);\n      }\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// GET /api/escrow/:id - Obter detalhes do escrow\nrouter.get('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user.id;\n\n    const escrow = await Escrow.findById(id)\n      .populate('sellerId', 'name email company')\n      .populate('buyerId', 'name email company');\n\n    if (!escrow) {\n      return res.status(404).json({\n        success: false,\n        message: 'Escrow nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem acesso\n    if (\n      escrow.buyerId._id.toString() !== userId &&\n      escrow.sellerId._id.toString() !== userId &&\n      !req.user.isAdmin\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    // Buscar item\n    let item;\n    if (escrow.itemType === 'product') {\n      item = await Product.findById(escrow.itemId);\n    } else {\n      item = await Freight.findById(escrow.itemId);\n    }\n\n    res.json({\n      success: true,\n      data: {\n        escrow: {\n          id: escrow._id,\n          status: escrow.status,\n          amount: escrow.amount,\n          description: escrow.description,\n          createdAt: escrow.createdAt,\n          expiresAt: escrow.expiresAt,\n          fundedAt: escrow.fundedAt,\n          releasedAt: escrow.releasedAt,\n          disputedAt: escrow.disputedAt\n        },\n        item: {\n          id: item._id,\n          name: item.name || `${item.origin} â†’ ${item.destination}`,\n          type: escrow.itemType\n        },\n        seller: escrow.sellerId,\n        buyer: escrow.buyerId\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar escrow:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/escrow/user/:userId - Listar escrows do usuÃ¡rio\nrouter.get('/user/:userId', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.params;\n    const currentUserId = req.user.id;\n\n    // Verificar se o usuÃ¡rio pode acessar\n    if (userId !== currentUserId && !req.user.isAdmin) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    const escrows = await Escrow.find({\n      $or: [{ buyerId: userId }, { sellerId: userId }]\n    })\n      .populate('sellerId', 'name email company')\n      .populate('buyerId', 'name email company')\n      .sort({ createdAt: -1 });\n\n    res.json({\n      success: true,\n      data: escrows\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao listar escrows:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// FunÃ§Ãµes auxiliares para processamento de pagamento\nasync function processStripePayment(escrow, paymentData) {\n  try {\n    // Implementar lÃ³gica real do Stripe\n    // Por enquanto, simular sucesso\n    return {\n      success: true,\n      paymentId: `stripe_${Date.now()}`\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: 'Erro ao processar pagamento Stripe'\n    };\n  }\n}\n\nasync function processMetaMaskPayment(escrow, paymentData) {\n  try {\n    // Implementar verificaÃ§Ã£o real da blockchain\n    // Por enquanto, simular sucesso\n    return {\n      success: true,\n      paymentId: `metamask_${Date.now()}`\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: 'Erro ao processar pagamento MetaMask'\n    };\n  }\n}\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\external-apis.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":358,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":358,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { externalAPIService } from '../services/externalAPIs.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { getClientIP } from '../utils/ipUtils.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Aplicar rate limiting\nrouter.use(apiLimiter);\n\n// ===== ROTAS DE CEP E ENDEREÃ‡O =====\n\n// GET /api/external/cep/:cep - Consultar CEP\nrouter.get('/cep/:cep', async (req, res) => {\n  try {\n    const { cep } = req.params;\n    const result = await externalAPIService.consultarCEP(cep);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao consultar CEP:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/estados - Listar estados\nrouter.get('/estados', async (req, res) => {\n  try {\n    const result = await externalAPIService.buscarEstados();\n    res.json(result);\n  } catch (error) {\n    logger.error('Erro ao buscar estados:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/estados/:uf/municipios - Listar municÃ­pios por estado\nrouter.get('/estados/:uf/municipios', async (req, res) => {\n  try {\n    const { uf } = req.params;\n    const result = await externalAPIService.buscarMunicipiosPorEstado(uf);\n    res.json(result);\n  } catch (error) {\n    logger.error('Erro ao buscar municÃ­pios:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/regioes - Listar regiÃµes\nrouter.get('/regioes', async (req, res) => {\n  try {\n    const result = await externalAPIService.buscarRegioes();\n    res.json(result);\n  } catch (error) {\n    logger.error('Erro ao buscar regiÃµes:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE CLIMA =====\n\n// GET /api/external/clima/coordenadas - Obter clima por coordenadas\nrouter.get('/clima/coordenadas', async (req, res) => {\n  try {\n    const { lat, lon, units = 'metric', lang = 'pt' } = req.query;\n\n    if (!lat || !lon) {\n      return res.status(400).json({\n        success: false,\n        message: 'Latitude e longitude sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const result = await externalAPIService.obterClimaPorCoordenadas(\n      parseFloat(lat),\n      parseFloat(lon),\n      units,\n      lang\n    );\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao obter clima por coordenadas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/clima/ip - Obter clima por IP\nrouter.get('/clima/ip', async (req, res) => {\n  try {\n    const { units = 'metric', lang = 'pt' } = req.query;\n    const clientIP = getClientIP(req);\n\n    const result = await externalAPIService.obterClimaPorIP(clientIP, units, lang);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao obter clima por IP:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/clima/ip/:ip - Obter clima por IP especÃ­fico\nrouter.get('/clima/ip/:ip', async (req, res) => {\n  try {\n    const { ip } = req.params;\n    const { units = 'metric', lang = 'pt' } = req.query;\n\n    const result = await externalAPIService.obterClimaPorIP(ip, units, lang);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao obter clima por IP:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DO BAIDU MAPS =====\n\n// GET /api/external/baidu/geocode - Geocoding de endereÃ§o\nrouter.get('/baidu/geocode', async (req, res) => {\n  try {\n    const { address, city, region } = req.query;\n\n    if (!address) {\n      return res.status(400).json({\n        success: false,\n        message: 'EndereÃ§o Ã© obrigatÃ³rio'\n      });\n    }\n\n    const result = await externalAPIService.geocodeAddress(address, city, region);\n    res.json(result);\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no geocoding:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/baidu/reverse-geocode - Reverse geocoding\nrouter.get('/baidu/reverse-geocode', async (req, res) => {\n  try {\n    const { lat, lng } = req.query;\n\n    if (!lat || !lng) {\n      return res.status(400).json({\n        success: false,\n        message: 'Latitude e longitude sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const result = await externalAPIService.reverseGeocode(parseFloat(lat), parseFloat(lng));\n    res.json(result);\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no reverse geocoding:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/baidu/route - Calcular rota\nrouter.get('/baidu/route', async (req, res) => {\n  try {\n    const { originLat, originLng, destLat, destLng, mode = 'driving' } = req.query;\n\n    if (!originLat || !originLng || !destLat || !destLng) {\n      return res.status(400).json({\n        success: false,\n        message: 'Coordenadas de origem e destino sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    const origin = { lat: parseFloat(originLat), lng: parseFloat(originLng) };\n    const destination = { lat: parseFloat(destLat), lng: parseFloat(destLng) };\n\n    const result = await externalAPIService.calculateRoute(origin, destination, mode);\n    res.json(result);\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao calcular rota:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DA RECEITA FEDERAL =====\n\n// GET /api/external/receita/cnpj/:cnpj - Consultar CNPJ\nrouter.get('/receita/cnpj/:cnpj', async (req, res) => {\n  try {\n    const { cnpj } = req.params;\n    const result = await externalAPIService.consultarCNPJ(cnpj);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao consultar CNPJ:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/receita/cpf/:cpf - Consultar CPF\nrouter.get('/receita/cpf/:cpf', async (req, res) => {\n  try {\n    const { cpf } = req.params;\n    const result = await externalAPIService.consultarCPF(cpf);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao consultar CPF:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE VALIDAÃ‡ÃƒO =====\n\n// POST /api/external/validar/endereco - Validar endereÃ§o\nrouter.post('/validar/endereco', async (req, res) => {\n  try {\n    const { endereco } = req.body;\n\n    if (!endereco) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados do endereÃ§o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const result = await externalAPIService.validarEndereco(endereco);\n    res.json(result);\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao validar endereÃ§o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE GEOLOCALIZAÃ‡ÃƒO =====\n\n// GET /api/external/geo/ip/:ip - Obter coordenadas por IP\nrouter.get('/geo/ip/:ip', async (req, res) => {\n  try {\n    const { ip } = req.params;\n    const result = await externalAPIService.obterCoordenadasPorIP(ip);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter coordenadas por IP:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/external/geo/ip - Obter coordenadas do IP do cliente\nrouter.get('/geo/ip', async (req, res) => {\n  try {\n    const clientIP = getClientIP(req);\n    const result = await externalAPIService.obterCoordenadasPorIP(clientIP);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter coordenadas do IP do cliente:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTA DE STATUS DAS APIS =====\n\n// GET /api/external/status - Status das APIs externas\nrouter.get('/status', async (req, res) => {\n  try {\n    const status = {\n      success: true,\n      data: {\n        timestamp: new Date().toISOString(),\n        apis: {\n          viacep: {\n            name: 'ViaCEP',\n            status: 'online',\n            description: 'Consulta de CEP'\n          },\n          ibge: {\n            name: 'IBGE',\n            status: 'online',\n            description: 'Dados geogrÃ¡ficos'\n          },\n          openweather: {\n            name: 'OpenWeather',\n            status: process.env.OPENWEATHER_API_KEY ? 'online' : 'offline',\n            description: 'Dados meteorolÃ³gicos'\n          },\n          receitaFederal: {\n            name: 'Receita Federal',\n            status: process.env.RECEITA_FEDERAL_API_KEY ? 'online' : 'offline',\n            description: 'ValidaÃ§Ã£o de documentos'\n          },\n          baiduMaps: {\n            name: 'Baidu Maps',\n            status: process.env.BAIDU_MAPS_API_KEY ? 'online' : 'offline',\n            description: 'Geocoding e rotas'\n          }\n        }\n      }\n    };\n\n    res.json(status);\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar status das APIs:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\freight.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\freightOrders.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Vehicle' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport FreightOrder from '../models/FreightOrder.js';\nimport User from '../models/User.js';\nimport Vehicle from '../models/Vehicle.js';\nimport { auth } from '../middleware/auth.js';\nimport logger from '../utils/logger.js';\nimport openaiService from '../services/openaiService.js';\nimport emailService from '../services/emailService.js';\n\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/freight-orders:\n *   post:\n *     summary: Criar novo pedido de frete\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - sellerId\n *               - origin\n *               - destination\n *               - pickupDate\n *               - deliveryDateEstimate\n *               - items\n *               - pricing\n *             properties:\n *               sellerId:\n *                 type: string\n *               origin:\n *                 type: object\n *                 properties:\n *                   address:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   zipCode:\n *                     type: string\n *                   coordinates:\n *                     type: object\n *                     properties:\n *                       lat:\n *                         type: number\n *                       lng:\n *                         type: number\n *                   contact:\n *                     type: object\n *                     properties:\n *                       name:\n *                         type: string\n *                       phone:\n *                         type: string\n *                       email:\n *                         type: string\n *               destination:\n *                 type: object\n *                 properties:\n *                   address:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   zipCode:\n *                     type: string\n *                   coordinates:\n *                     type: object\n *                     properties:\n *                       lat:\n *                         type: number\n *                       lng:\n *                         type: number\n *                   contact:\n *                     type: object\n *                     properties:\n *                       name:\n *                         type: string\n *                       phone:\n *                         type: string\n *                       email:\n *                         type: string\n *               pickupDate:\n *                 type: string\n *                 format: date\n *               deliveryDateEstimate:\n *                 type: string\n *                 format: date\n *               items:\n *                 type: array\n *                 items:\n *                   type: object\n *                   properties:\n *                     name:\n *                       type: string\n *                     description:\n *                       type: string\n *                     quantity:\n *                       type: number\n *                     unit:\n *                       type: string\n *                     weight:\n *                       type: number\n *                     volume:\n *                       type: number\n *                     value:\n *                       type: number\n *                     category:\n *                       type: string\n *                       enum: [grain, livestock, equipment, fertilizer, other]\n *               pricing:\n *                 type: object\n *                 properties:\n *                   basePrice:\n *                     type: number\n *                   additionalFees:\n *                     type: array\n *                     items:\n *                       type: object\n *                       properties:\n *                         name:\n *                           type: string\n *                         amount:\n *                           type: number\n *                         description:\n *                           type: string\n *                   currency:\n *                     type: string\n *                     default: BRL\n *     responses:\n *       201:\n *         description: Pedido de frete criado com sucesso\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post(\n  '/',\n  auth,\n  [\n    body('sellerId').isMongoId().withMessage('ID do vendedor invÃ¡lido'),\n    body('origin.address').notEmpty().withMessage('EndereÃ§o de origem Ã© obrigatÃ³rio'),\n    body('origin.city').notEmpty().withMessage('Cidade de origem Ã© obrigatÃ³ria'),\n    body('origin.state').notEmpty().withMessage('Estado de origem Ã© obrigatÃ³rio'),\n    body('destination.address').notEmpty().withMessage('EndereÃ§o de destino Ã© obrigatÃ³rio'),\n    body('destination.city').notEmpty().withMessage('Cidade de destino Ã© obrigatÃ³ria'),\n    body('destination.state').notEmpty().withMessage('Estado de destino Ã© obrigatÃ³rio'),\n    body('pickupDate').isISO8601().withMessage('Data de coleta invÃ¡lida'),\n    body('deliveryDateEstimate').isISO8601().withMessage('Data estimada de entrega invÃ¡lida'),\n    body('items').isArray({ min: 1 }).withMessage('Pelo menos um item Ã© obrigatÃ³rio'),\n    body('pricing.basePrice').isNumeric().withMessage('PreÃ§o base Ã© obrigatÃ³rio')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const userId = req.user.id;\n      const freightOrderData = {\n        ...req.body,\n        buyerId: userId\n      };\n\n      const freightOrder = new FreightOrder(freightOrderData);\n      await freightOrder.save();\n\n      // Adicionar evento inicial de criaÃ§Ã£o\n      await freightOrder.addTrackingEvent('created', {}, 'Pedido de frete criado');\n\n      // Enviar notificaÃ§Ã£o para vendedor\n      const seller = await User.findById(freightOrderData.sellerId);\n      if (seller) {\n        await emailService.sendFreightOrderNotification({\n          to: seller.email,\n          name: seller.name,\n          orderNumber: freightOrder.orderNumber,\n          buyerName: req.user.name,\n          origin: freightOrder.origin,\n          destination: freightOrder.destination,\n          pickupDate: freightOrder.pickupDate,\n          totalPrice: freightOrder.pricing.totalPrice\n        });\n      }\n\n      logger.info(\n        `Novo pedido de frete criado: ${freightOrder.orderNumber} por usuÃ¡rio ${userId}`\n      );\n\n      res.status(201).json({\n        success: true,\n        message: 'Pedido de frete criado com sucesso',\n        data: {\n          freightOrder: {\n            id: freightOrder._id,\n            orderNumber: freightOrder.orderNumber,\n            status: freightOrder.status,\n            origin: freightOrder.origin,\n            destination: freightOrder.destination,\n            pickupDate: freightOrder.pickupDate,\n            deliveryDateEstimate: freightOrder.deliveryDateEstimate,\n            items: freightOrder.items,\n            pricing: freightOrder.pricing,\n            createdAt: freightOrder.createdAt\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao criar pedido de frete:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/freight-orders/{id}/tracking:\n *   post:\n *     summary: Atualizar rastreamento do frete\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - status\n *               - location\n *             properties:\n *               status:\n *                 type: string\n *                 enum: [accepted, picked_up, in_transit, delayed, delivered, exception]\n *               location:\n *                 type: object\n *                 properties:\n *                   address:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   coordinates:\n *                     type: object\n *                     properties:\n *                       lat:\n *                         type: number\n *                       lng:\n *                         type: number\n *               description:\n *                 type: string\n *               metadata:\n *                 type: object\n *                 properties:\n *                   driver:\n *                     type: string\n *                   vehicle:\n *                     type: string\n *                   notes:\n *                     type: string\n *                   images:\n *                     type: array\n *                     items:\n *                       type: string\n *                   documents:\n *                     type: array\n *                     items:\n *                       type: string\n *     responses:\n *       200:\n *         description: Rastreamento atualizado com sucesso\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.post(\n  '/:id/tracking',\n  auth,\n  [\n    body('status')\n      .isIn(['accepted', 'picked_up', 'in_transit', 'delayed', 'delivered', 'exception'])\n      .withMessage('Status invÃ¡lido'),\n    body('location').isObject().withMessage('LocalizaÃ§Ã£o Ã© obrigatÃ³ria')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { id } = req.params;\n      const { status, location, description, metadata } = req.body;\n      const userId = req.user.id;\n\n      const freightOrder = await FreightOrder.findById(id);\n      if (!freightOrder) {\n        return res.status(404).json({\n          success: false,\n          message: 'Pedido de frete nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio tem permissÃ£o para atualizar\n      if (\n        freightOrder.carrierId?.toString() !== userId &&\n        freightOrder.buyerId?.toString() !== userId &&\n        freightOrder.sellerId?.toString() !== userId\n      ) {\n        return res.status(403).json({\n          success: false,\n          message: 'Sem permissÃ£o para atualizar este pedido'\n        });\n      }\n\n      // Adicionar evento de rastreamento\n      await freightOrder.addTrackingEvent(status, location, description, metadata);\n\n      // Enviar notificaÃ§Ãµes para partes envolvidas\n      const parties = [freightOrder.buyerId, freightOrder.sellerId];\n      if (freightOrder.carrierId) {\n        parties.push(freightOrder.carrierId);\n      }\n\n      for (const partyId of parties) {\n        if (partyId && partyId.toString() !== userId) {\n          const party = await User.findById(partyId);\n          if (party) {\n            await emailService.sendTrackingUpdateNotification({\n              to: party.email,\n              name: party.name,\n              orderNumber: freightOrder.orderNumber,\n              status,\n              location,\n              description\n            });\n          }\n        }\n      }\n\n      logger.info(`Rastreamento atualizado para pedido ${freightOrder.orderNumber}: ${status}`);\n\n      res.status(200).json({\n        success: true,\n        message: 'Rastreamento atualizado com sucesso',\n        data: {\n          freightOrder: {\n            id: freightOrder._id,\n            orderNumber: freightOrder.orderNumber,\n            status: freightOrder.status,\n            trackingEvents: freightOrder.trackingEvents\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao atualizar rastreamento:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/freight-orders/{id}/ai-closure:\n *   post:\n *     summary: Iniciar fechamento assistido por IA\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     responses:\n *       200:\n *         description: Fechamento assistido por IA iniciado\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.post('/:id/ai-closure', auth, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user.id;\n\n    const freightOrder = await FreightOrder.findById(id);\n    if (!freightOrder) {\n      return res.status(404).json({\n        success: false,\n        message: 'Pedido de frete nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem permissÃ£o\n    if (\n      freightOrder.buyerId?.toString() !== userId &&\n      freightOrder.sellerId?.toString() !== userId\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Sem permissÃ£o para fechar este pedido'\n      });\n    }\n\n    // Verificar se o pedido estÃ¡ entregue\n    if (freightOrder.status !== 'delivered') {\n      return res.status(400).json({\n        success: false,\n        message: 'Pedido deve estar entregue para iniciar fechamento'\n      });\n    }\n\n    // Gerar anÃ¡lise de IA\n    const aiAnalysis = await openaiService.generateFreightClosureSummary(freightOrder);\n\n    // Atualizar pedido com anÃ¡lise de IA\n    freightOrder.aiClosure = {\n      ...aiAnalysis,\n      isCompleted: false\n    };\n    await freightOrder.save();\n\n    logger.info(`Fechamento assistido por IA iniciado para pedido ${freightOrder.orderNumber}`);\n\n    res.status(200).json({\n      success: true,\n      message: 'Fechamento assistido por IA iniciado',\n      data: {\n        freightOrder: {\n          id: freightOrder._id,\n          orderNumber: freightOrder.orderNumber,\n          aiClosure: freightOrder.aiClosure\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao iniciar fechamento assistido por IA:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/freight-orders/{id}/complete-closure:\n *   post:\n *     summary: Completar fechamento do pedido\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               confirmClosure:\n *                 type: boolean\n *               customMessage:\n *                 type: string\n *               rating:\n *                 type: number\n *                 minimum: 1\n *                 maximum: 5\n *               comment:\n *                 type: string\n *     responses:\n *       200:\n *         description: Fechamento completado com sucesso\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.post(\n  '/:id/complete-closure',\n  auth,\n  [\n    body('confirmClosure').isBoolean().withMessage('ConfirmaÃ§Ã£o de fechamento Ã© obrigatÃ³ria'),\n    body('rating')\n      .optional()\n      .isInt({ min: 1, max: 5 })\n      .withMessage('AvaliaÃ§Ã£o deve ser entre 1 e 5')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { id } = req.params;\n      const { confirmClosure, customMessage, rating, comment } = req.body;\n      const userId = req.user.id;\n\n      const freightOrder = await FreightOrder.findById(id);\n      if (!freightOrder) {\n        return res.status(404).json({\n          success: false,\n          message: 'Pedido de frete nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio tem permissÃ£o\n      if (\n        freightOrder.buyerId?.toString() !== userId &&\n        freightOrder.sellerId?.toString() !== userId\n      ) {\n        return res.status(403).json({\n          success: false,\n          message: 'Sem permissÃ£o para fechar este pedido'\n        });\n      }\n\n      if (!confirmClosure) {\n        return res.status(400).json({\n          success: false,\n          message: 'Fechamento nÃ£o confirmado'\n        });\n      }\n\n      // Completar fechamento\n      const finalMessage = customMessage || freightOrder.aiClosure.suggestedMessage;\n      await freightOrder.completeAIClosure(\n        freightOrder.aiClosure.summary,\n        freightOrder.aiClosure.performanceMetrics,\n        finalMessage,\n        freightOrder.aiClosure.invoiceDraft\n      );\n\n      // Adicionar avaliaÃ§Ã£o se fornecida\n      if (rating && comment) {\n        const userType = freightOrder.buyerId?.toString() === userId ? 'buyer' : 'seller';\n        await freightOrder.rateUser(userType, rating, comment, userId);\n      }\n\n      logger.info(`Pedido de frete ${freightOrder.orderNumber} fechado com sucesso`);\n\n      res.status(200).json({\n        success: true,\n        message: 'Fechamento completado com sucesso',\n        data: {\n          freightOrder: {\n            id: freightOrder._id,\n            orderNumber: freightOrder.orderNumber,\n            status: freightOrder.status,\n            aiClosure: freightOrder.aiClosure,\n            rating: freightOrder.rating\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao completar fechamento:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/freight-orders:\n *   get:\n *     summary: Listar pedidos de frete do usuÃ¡rio\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: query\n *         name: status\n *         schema:\n *           type: string\n *           enum: [pending, accepted, picked_up, in_transit, delivered, closed, cancelled]\n *       - in: query\n *         name: role\n *         schema:\n *           type: string\n *           enum: [buyer, seller, carrier]\n *     responses:\n *       200:\n *         description: Lista de pedidos de frete\n */\nrouter.get('/', auth, async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { status, role } = req.query;\n\n    let query = {};\n\n    if (role === 'buyer') {\n      query.buyerId = userId;\n    } else if (role === 'seller') {\n      query.sellerId = userId;\n    } else if (role === 'carrier') {\n      query.carrierId = userId;\n    } else {\n      // Buscar todos os pedidos onde o usuÃ¡rio estÃ¡ envolvido\n      query = {\n        $or: [{ buyerId: userId }, { sellerId: userId }, { carrierId: userId }]\n      };\n    }\n\n    if (status) {\n      query.status = status;\n    }\n\n    const freightOrders = await FreightOrder.find(query)\n      .populate('buyerId', 'name email')\n      .populate('sellerId', 'name email')\n      .populate('carrierId', 'name email')\n      .sort({ createdAt: -1 });\n\n    res.status(200).json({\n      success: true,\n      data: {\n        freightOrders: freightOrders.map(order => ({\n          id: order._id,\n          orderNumber: order.orderNumber,\n          status: order.status,\n          origin: order.origin,\n          destination: order.destination,\n          pickupDate: order.pickupDate,\n          deliveryDateEstimate: order.deliveryDateEstimate,\n          deliveryDateActual: order.deliveryDateActual,\n          items: order.items,\n          pricing: order.pricing,\n          buyer: order.buyerId,\n          seller: order.sellerId,\n          carrier: order.carrierId,\n          trackingEvents: order.trackingEvents,\n          aiClosure: order.aiClosure,\n          rating: order.rating,\n          createdAt: order.createdAt,\n          updatedAt: order.updatedAt\n        }))\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao listar pedidos de frete:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/freight-orders/{id}:\n *   get:\n *     summary: Obter detalhes de um pedido de frete\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     responses:\n *       200:\n *         description: Detalhes do pedido de frete\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.get('/:id', auth, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user.id;\n\n    const freightOrder = await FreightOrder.findById(id)\n      .populate('buyerId', 'name email phone')\n      .populate('sellerId', 'name email phone')\n      .populate('carrierId', 'name email phone');\n\n    if (!freightOrder) {\n      return res.status(404).json({\n        success: false,\n        message: 'Pedido de frete nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem permissÃ£o para ver\n    if (\n      freightOrder.buyerId?._id.toString() !== userId &&\n      freightOrder.sellerId?._id.toString() !== userId &&\n      freightOrder.carrierId?._id.toString() !== userId\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Sem permissÃ£o para visualizar este pedido'\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        freightOrder: {\n          id: freightOrder._id,\n          orderNumber: freightOrder.orderNumber,\n          status: freightOrder.status,\n          origin: freightOrder.origin,\n          destination: freightOrder.destination,\n          pickupDate: freightOrder.pickupDate,\n          deliveryDateEstimate: freightOrder.deliveryDateEstimate,\n          deliveryDateActual: freightOrder.deliveryDateActual,\n          items: freightOrder.items,\n          pricing: freightOrder.pricing,\n          vehicle: freightOrder.vehicle,\n          documents: freightOrder.documents,\n          trackingEvents: freightOrder.trackingEvents,\n          aiClosure: freightOrder.aiClosure,\n          rating: freightOrder.rating,\n          notifications: freightOrder.notifications,\n          buyer: freightOrder.buyerId,\n          seller: freightOrder.sellerId,\n          carrier: freightOrder.carrierId,\n          createdAt: freightOrder.createdAt,\n          updatedAt: freightOrder.updatedAt\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter pedido de frete:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\gamification.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":12},{"ruleId":"no-unused-vars","severity":1,"message":"'Transaction' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":19},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":286,"column":46,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":286,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport UserReputation from '../models/UserReputation.js';\nimport User from '../models/User.js';\nimport Transaction from '../models/Transaction.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Aplicar rate limiting\nrouter.use(apiLimiter);\n\n// Aplicar autenticaÃ§Ã£o em todas as rotas\nrouter.use(authenticateToken);\n\n// ===== ROTAS DE GAMIFICAÃ‡ÃƒO =====\n\n// GET /api/gamification/profile - Obter perfil de reputaÃ§Ã£o do usuÃ¡rio\nrouter.get('/profile', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    let userReputation = await UserReputation.findOne({ userId }).populate(\n      'userId',\n      'name email avatar'\n    );\n\n    if (!userReputation) {\n      // Criar perfil de reputaÃ§Ã£o se nÃ£o existir\n      userReputation = new UserReputation({ userId });\n      await userReputation.save();\n    }\n\n    res.json({\n      success: true,\n      data: userReputation\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar perfil de reputaÃ§Ã£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/leaderboard - Obter ranking global\nrouter.get('/leaderboard', async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 20,\n      category = 'global', // 'global', 'regional', 'category'\n      region = null\n    } = req.query;\n\n    const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n\n    const query = {};\n\n    // Filtrar por regiÃ£o se especificado\n    if (region && category === 'regional') {\n      query['userId.region'] = region;\n    }\n\n    // Buscar ranking\n    const leaderboard = await UserReputation.find(query)\n      .populate('userId', 'name email avatar region')\n      .sort({ totalScore: -1, level: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10));\n\n    const total = await UserReputation.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        leaderboard,\n        pagination: {\n          page: parseInt(page, 10),\n          limit: parseInt(limit, 10),\n          total,\n          pages: Math.ceil(total / parseInt(limit, 10))\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar ranking:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/badges - Obter badges disponÃ­veis\nrouter.get('/badges', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      return res.status(404).json({\n        success: false,\n        message: 'Perfil de reputaÃ§Ã£o nÃ£o encontrado'\n      });\n    }\n\n    // Calcular novos badges\n    const newBadges = userReputation.calculateBadges();\n\n    // Adicionar novos badges se houver\n    if (newBadges.length > 0) {\n      userReputation.badges.push(...newBadges);\n      await userReputation.save();\n    }\n\n    res.json({\n      success: true,\n      data: {\n        earnedBadges: userReputation.badges,\n        newBadges\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar badges:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/gamification/points - Adicionar pontos (para aÃ§Ãµes do usuÃ¡rio)\nrouter.post('/points', async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { action, points, description, metadata } = req.body;\n\n    if (!action || !points || !description) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o, pontos e descriÃ§Ã£o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    let userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      userReputation = new UserReputation({ userId });\n    }\n\n    // Adicionar pontos\n    userReputation.addPoints(points, action, description, metadata);\n\n    // Calcular novos badges\n    const newBadges = userReputation.calculateBadges();\n    if (newBadges.length > 0) {\n      userReputation.badges.push(...newBadges);\n    }\n\n    await userReputation.save();\n\n    res.json({\n      success: true,\n      data: {\n        newScore: userReputation.totalScore,\n        newLevel: userReputation.level,\n        newBadges,\n        levelUp: newBadges.length > 0\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao adicionar pontos:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/stats - Obter estatÃ­sticas do usuÃ¡rio\nrouter.get('/stats', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      return res.status(404).json({\n        success: false,\n        message: 'Perfil de reputaÃ§Ã£o nÃ£o encontrado'\n      });\n    }\n\n    // Calcular estatÃ­sticas adicionais\n    const stats = {\n      ...userReputation.toObject(),\n      progressToNextLevel: {\n        current: userReputation.experience,\n        required: userReputation.experienceToNextLevel,\n        percentage: Math.round(\n          (userReputation.experience / userReputation.experienceToNextLevel) * 100\n        )\n      },\n      ranking: {\n        global:\n          (await UserReputation.countDocuments({\n            totalScore: { $gt: userReputation.totalScore }\n          })) + 1,\n        regional:\n          (await UserReputation.countDocuments({\n            totalScore: { $gt: userReputation.totalScore },\n            'userId.region': userReputation.userId?.region\n          })) + 1\n      }\n    };\n\n    res.json({\n      success: true,\n      data: stats\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar estatÃ­sticas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/gamification/notifications - Atualizar configuraÃ§Ãµes de notificaÃ§Ãµes\nrouter.put('/notifications', async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { notifications } = req.body;\n\n    if (!notifications || typeof notifications !== 'object') {\n      return res.status(400).json({\n        success: false,\n        message: 'ConfiguraÃ§Ãµes de notificaÃ§Ãµes sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    const userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      return res.status(404).json({\n        success: false,\n        message: 'Perfil de reputaÃ§Ã£o nÃ£o encontrado'\n      });\n    }\n\n    // Atualizar configuraÃ§Ãµes\n    userReputation.notifications = {\n      ...userReputation.notifications,\n      ...notifications\n    };\n\n    await userReputation.save();\n\n    res.json({\n      success: true,\n      data: userReputation.notifications\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao atualizar notificaÃ§Ãµes:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/achievements - Obter conquistas disponÃ­veis\nrouter.get('/achievements', async (req, res) => {\n  try {\n    const achievements = [\n      {\n        id: 'FIRST_TRANSACTION',\n        name: 'Primeira TransaÃ§Ã£o',\n        description: 'Completou sua primeira transaÃ§Ã£o',\n        icon: 'ðŸŽ¯',\n        category: 'TRANSACTION',\n        rarity: 'COMMON',\n        requirement: '1 transaÃ§Ã£o',\n        points: 50\n      },\n      {\n        id: 'ACTIVE_SELLER',\n        name: 'Vendedor Ativo',\n        description: 'Cadastrou 10 ou mais produtos',\n        icon: 'ðŸª',\n        category: 'PRODUCT',\n        rarity: 'RARE',\n        requirement: '10 produtos',\n        points: 200\n      },\n      {\n        id: 'TRANSPORTER',\n        name: 'Transportador',\n        description: 'Completou 5 ou mais fretes',\n        icon: 'ðŸšš',\n        category: 'FREIGHT',\n        rarity: 'RARE',\n        requirement: '5 fretes',\n        points: 200\n      },\n      {\n        id: 'TRUSTED_USER',\n        name: 'UsuÃ¡rio ConfiÃ¡vel',\n        description: 'Alta avaliaÃ§Ã£o e muitas transaÃ§Ãµes bem-sucedidas',\n        icon: 'â­',\n        category: 'SPECIAL',\n        rarity: 'EPIC',\n        requirement: '4.5+ rating, 20+ transaÃ§Ãµes',\n        points: 500\n      },\n      {\n        id: 'TOP_SELLER',\n        name: 'Top Vendedor',\n        description: 'Vendeu mais de R$ 10.000 em produtos',\n        icon: 'ðŸ‘‘',\n        category: 'SPECIAL',\n        rarity: 'LEGENDARY',\n        requirement: 'R$ 10.000+ em vendas',\n        points: 1000\n      }\n    ];\n\n    res.json({\n      success: true,\n      data: achievements\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar conquistas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\geolocation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\health-check.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":38,"column":42,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":38,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿/**\n * Health Check Routes - Monitoramento automÃ¡tico do sistema\n */\n\nimport express from 'express';\n\nconst router = express.Router();\n\n// Status da aplicaÃ§Ã£o\nconst appStatus = {\n  startTime: Date.now(),\n  lastCheck: null,\n  checks: {\n    api: { status: 'ok', lastCheck: null },\n    database: { status: 'unknown', lastCheck: null },\n    external: { status: 'unknown', lastCheck: null }\n  }\n};\n\n/**\n * GET /health - Health check bÃ¡sico\n */\nrouter.get('/', (req, res) => {\n  const uptime = Date.now() - appStatus.startTime;\n\n  res.json({\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n    uptime: Math.floor(uptime / 1000), // em segundos\n    environment: process.env.NODE_ENV || 'development',\n    version: process.env.npm_package_version || '1.0.0'\n  });\n});\n\n/**\n * GET /health/detailed - Health check detalhado\n */\nrouter.get('/detailed', async (req, res) => {\n  const uptime = Date.now() - appStatus.startTime;\n\n  // Verificar API\n  appStatus.checks.api = {\n    status: 'ok',\n    lastCheck: new Date().toISOString()\n  };\n\n  // Verificar Database (Cloudflare D1)\n  try {\n    // Aqui vocÃª adicionaria verificaÃ§Ã£o real do D1\n    appStatus.checks.database = {\n      status: process.env.CLOUDFLARE_D1_DATABASE_ID ? 'ok' : 'not_configured',\n      lastCheck: new Date().toISOString()\n    };\n  } catch (error) {\n    appStatus.checks.database = {\n      status: 'error',\n      lastCheck: new Date().toISOString(),\n      error: error.message\n    };\n  }\n\n  // Verificar APIs Externas\n  try {\n    appStatus.checks.external = {\n      status: 'ok',\n      lastCheck: new Date().toISOString()\n    };\n  } catch (error) {\n    appStatus.checks.external = {\n      status: 'error',\n      lastCheck: new Date().toISOString(),\n      error: error.message\n    };\n  }\n\n  // Status geral\n  const allChecksOk = Object.values(appStatus.checks).every(\n    check => check.status === 'ok' || check.status === 'not_configured'\n  );\n\n  res.status(allChecksOk ? 200 : 503).json({\n    status: allChecksOk ? 'healthy' : 'degraded',\n    timestamp: new Date().toISOString(),\n    uptime: Math.floor(uptime / 1000),\n    environment: process.env.NODE_ENV || 'development',\n    version: process.env.npm_package_version || '1.0.0',\n    checks: appStatus.checks,\n    memory: {\n      used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),\n      total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),\n      unit: 'MB'\n    },\n    cpu: process.cpuUsage()\n  });\n});\n\n/**\n * GET /health/ready - Readiness probe (Kubernetes)\n */\nrouter.get('/ready', (req, res) => {\n  const allChecksOk = Object.values(appStatus.checks).every(\n    check => check.status === 'ok' || check.status === 'not_configured'\n  );\n\n  if (allChecksOk) {\n    res.status(200).json({ status: 'ready' });\n  } else {\n    res.status(503).json({ status: 'not_ready', checks: appStatus.checks });\n  }\n});\n\n/**\n * GET /health/live - Liveness probe (Kubernetes)\n */\nrouter.get('/live', (req, res) => {\n  res.status(200).json({ status: 'alive' });\n});\n\n/**\n * GET /health/metrics - MÃ©tricas bÃ¡sicas\n */\nrouter.get('/metrics', (req, res) => {\n  const uptime = Date.now() - appStatus.startTime;\n  const mem = process.memoryUsage();\n\n  res.json({\n    uptime_seconds: Math.floor(uptime / 1000),\n    memory_used_mb: Math.round(mem.heapUsed / 1024 / 1024),\n    memory_total_mb: Math.round(mem.heapTotal / 1024 / 1024),\n    memory_external_mb: Math.round(mem.external / 1024 / 1024),\n    cpu_user: process.cpuUsage().user,\n    cpu_system: process.cpuUsage().system,\n    node_version: process.version,\n    platform: process.platform,\n    arch: process.arch\n  });\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\health.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\marketplace.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\messages.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\mirror-apis.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getClientIP' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":21},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":268,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":268,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { externalAPIService } from '../services/externalAPIs.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { getClientIP } from '../utils/ipUtils.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Aplicar rate limiting especÃ­fico para mirrors\nrouter.use(apiLimiter);\n\n// ===== MIRROR API - BAIDU MAPS =====\n\n// GET /api/mirror/baidu?query=... - Geocoding e busca de endereÃ§os\nrouter.get('/baidu', async (req, res) => {\n  try {\n    const { query, lat, lng, type = 'geocoding' } = req.query;\n\n    if (!query && !lat && !lng) {\n      return res.status(400).json({\n        success: false,\n        message: 'Query de busca ou coordenadas (lat/lng) sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    let result;\n    if (type === 'geocoding' && query) {\n      // Buscar coordenadas por endereÃ§o\n      result = await externalAPIService.buscarCoordenadasBaidu(query);\n    } else if (type === 'reverse' && lat && lng) {\n      // Buscar endereÃ§o por coordenadas\n      result = await externalAPIService.buscarEnderecoBaidu(lat, lng);\n    } else if (type === 'search' && query) {\n      // Busca geral de lugares\n      result = await externalAPIService.buscarLugaresBaidu(query);\n    } else {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipo de busca invÃ¡lido ou parÃ¢metros insuficientes'\n      });\n    }\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'baidu-maps',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no mirror Baidu Maps:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// ===== MIRROR API - RECEITA FEDERAL =====\n\n// GET /api/mirror/receita/validate?cnpj=... - Validar CNPJ\nrouter.get('/receita/validate', async (req, res) => {\n  try {\n    const { cnpj, cpf, ie } = req.query;\n\n    if (!cnpj && !cpf && !ie) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ, CPF ou IE deve ser fornecido'\n      });\n    }\n\n    let result;\n    if (cnpj) {\n      result = await externalAPIService.validarCNPJ(cnpj);\n    } else if (cpf) {\n      result = await externalAPIService.validarCPF(cpf);\n    } else if (ie) {\n      result = await externalAPIService.validarIE(ie);\n    }\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'receita-federal',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no mirror Receita Federal:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// GET /api/mirror/receita/company/:cnpj - Obter dados da empresa\nrouter.get('/receita/company/:cnpj', async (req, res) => {\n  try {\n    const { cnpj } = req.params;\n\n    if (!cnpj) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ Ã© obrigatÃ³rio'\n      });\n    }\n\n    const result = await externalAPIService.obterDadosEmpresa(cnpj);\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'receita-federal',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter dados da empresa:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// ===== MIRROR API - IBGE =====\n\n// GET /api/mirror/ibge?cep=... - Buscar dados por CEP\nrouter.get('/ibge', async (req, res) => {\n  try {\n    const { cep, uf, municipio } = req.query;\n\n    if (!cep && !uf && !municipio) {\n      return res.status(400).json({\n        success: false,\n        message: 'CEP, UF ou municÃ­pio deve ser fornecido'\n      });\n    }\n\n    let result;\n    if (cep) {\n      result = await externalAPIService.consultarCEP(cep);\n    } else if (uf && municipio) {\n      result = await externalAPIService.buscarMunicipioPorNome(uf, municipio);\n    } else if (uf) {\n      result = await externalAPIService.buscarMunicipiosPorEstado(uf);\n    } else {\n      return res.status(400).json({\n        success: false,\n        message: 'ParÃ¢metros insuficientes para busca'\n      });\n    }\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'ibge',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no mirror IBGE:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// GET /api/mirror/ibge/estados - Listar todos os estados\nrouter.get('/ibge/estados', async (req, res) => {\n  try {\n    const result = await externalAPIService.buscarEstados();\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'ibge',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar estados:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// GET /api/mirror/ibge/estados/:uf/municipios - Listar municÃ­pios por estado\nrouter.get('/ibge/estados/:uf/municipios', async (req, res) => {\n  try {\n    const { uf } = req.params;\n\n    if (!uf) {\n      return res.status(400).json({\n        success: false,\n        message: 'UF Ã© obrigatÃ³ria'\n      });\n    }\n\n    const result = await externalAPIService.buscarMunicipiosPorEstado(uf);\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'ibge',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar municÃ­pios:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// ===== MIRROR API - STATUS E SAÃšDE =====\n\n// GET /api/mirror/status - Status das APIs mirror\nrouter.get('/status', async (req, res) => {\n  try {\n    const status = {\n      baidu: {\n        status: 'operational',\n        lastCheck: new Date().toISOString(),\n        endpoints: ['/api/mirror/baidu']\n      },\n      receita: {\n        status: 'operational',\n        lastCheck: new Date().toISOString(),\n        endpoints: ['/api/mirror/receita/validate', '/api/mirror/receita/company/:cnpj']\n      },\n      ibge: {\n        status: 'operational',\n        lastCheck: new Date().toISOString(),\n        endpoints: [\n          '/api/mirror/ibge',\n          '/api/mirror/ibge/estados',\n          '/api/mirror/ibge/estados/:uf/municipios'\n        ]\n      }\n    };\n\n    res.json({\n      success: true,\n      data: status,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar status dos mirrors:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\news.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getClientIP' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":21},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":82,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":82,"endColumn":36},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":162,"column":44,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":162,"endColumn":46},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":214,"column":37,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":214,"endColumn":39},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":248,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":248,"endColumn":52},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":291,"column":42,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":291,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { getClientIP } from '../utils/ipUtils.js';\nimport axios from 'axios';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// Simulated news data (in production, this would come from a database or external API)\nconst mockNews = [\n  {\n    id: 1,\n    title: 'Safra de soja 2024/25 deve crescer 5% no Brasil',\n    summary: 'Estimativas apontam para produÃ§Ã£o recorde de 158 milhÃµes de toneladas',\n    content:\n      'A safra de soja 2024/25 no Brasil deve crescer 5% em relaÃ§Ã£o Ã  temporada anterior, atingindo 158 milhÃµes de toneladas, segundo estimativas da Companhia Nacional de Abastecimento (Conab). O aumento Ã© impulsionado pela expansÃ£o da Ã¡rea plantada e melhores condiÃ§Ãµes climÃ¡ticas.',\n    category: 'grains',\n    image: 'https://images.unsplash.com/photo-1574323347407-f5e1ad6d020b?w=800&h=600&fit=crop',\n    source: 'AgroNews',\n    publishedAt: '2024-01-15T10:00:00Z',\n    isActive: true,\n    tags: ['soja', 'safra', 'conab', 'produÃ§Ã£o']\n  },\n  {\n    id: 2,\n    title: 'Tecnologia de irrigaÃ§Ã£o inteligente reduz consumo de Ã¡gua em 30%',\n    summary: 'Sistema automatizado monitora umidade do solo e otimiza uso de recursos hÃ­dricos',\n    content:\n      'Novas tecnologias de irrigaÃ§Ã£o inteligente estÃ£o revolucionando a agricultura brasileira, permitindo reduÃ§Ã£o de atÃ© 30% no consumo de Ã¡gua. Sensores IoT monitoram a umidade do solo em tempo real, ajustando automaticamente a irrigaÃ§Ã£o conforme as necessidades das plantas.',\n    category: 'technology',\n    image: 'https://images.unsplash.com/photo-1565299624946-b28f40a0ca4b?w=800&h=600&fit=crop',\n    source: 'TechAgro',\n    publishedAt: '2024-01-14T14:30:00Z',\n    isActive: true,\n    tags: ['irrigaÃ§Ã£o', 'tecnologia', 'IoT', 'sustentabilidade']\n  },\n  {\n    id: 3,\n    title: 'ExportaÃ§Ãµes de carne bovina batem recorde em dezembro',\n    summary: 'Volume exportado supera 200 mil toneladas, maior marca para o mÃªs',\n    content:\n      'As exportaÃ§Ãµes brasileiras de carne bovina em dezembro de 2023 atingiram 203 mil toneladas, representando um crescimento de 12% em relaÃ§Ã£o ao mesmo perÃ­odo do ano anterior. A China continua sendo o principal destino, seguida pelos Estados Unidos e UniÃ£o Europeia.',\n    category: 'livestock',\n    image: 'https://images.unsplash.com/photo-1544025162-d76694265947?w=800&h=600&fit=crop',\n    source: 'AgroBusiness',\n    publishedAt: '2024-01-13T16:45:00Z',\n    isActive: true,\n    tags: ['carne bovina', 'exportaÃ§Ã£o', 'china', 'mercado']\n  },\n  {\n    id: 4,\n    title: 'Fertilizantes orgÃ¢nicos ganham espaÃ§o no mercado brasileiro',\n    summary: 'Produtores buscam alternativas sustentÃ¡veis aos fertilizantes quÃ­micos',\n    content:\n      'O mercado de fertilizantes orgÃ¢nicos no Brasil estÃ¡ em expansÃ£o, impulsionado pela busca por prÃ¡ticas agrÃ­colas mais sustentÃ¡veis. Produtores estÃ£o investindo em compostagem, biofertilizantes e outras alternativas naturais para reduzir dependÃªncia de insumos quÃ­micos.',\n    category: 'fertilizers',\n    image: 'https://images.unsplash.com/photo-1574323347407-f5e1ad6d020b?w=800&h=600&fit=crop',\n    source: 'SustentAgro',\n    publishedAt: '2024-01-12T09:15:00Z',\n    isActive: true,\n    tags: ['fertilizantes orgÃ¢nicos', 'sustentabilidade', 'agricultura orgÃ¢nica']\n  },\n  {\n    id: 5,\n    title: 'PreÃ§os do milho se estabilizam apÃ³s perÃ­odo de alta',\n    summary: 'Oferta adequada e demanda estÃ¡vel levam Ã  estabilizaÃ§Ã£o dos preÃ§os',\n    content:\n      'Os preÃ§os do milho no mercado brasileiro se estabilizaram apÃ³s um perÃ­odo de alta significativa. A oferta adequada do grÃ£o e a demanda estÃ¡vel por parte dos produtores de raÃ§Ã£o animal contribuÃ­ram para a estabilizaÃ§Ã£o dos preÃ§os nas principais praÃ§as do paÃ­s.',\n    category: 'grains',\n    image: 'https://images.unsplash.com/photo-1574323347407-f5e1ad6d020b?w=800&h=600&fit=crop',\n    source: 'MercadoAgro',\n    publishedAt: '2024-01-11T11:20:00Z',\n    isActive: true,\n    tags: ['milho', 'preÃ§os', 'mercado', 'oferta']\n  }\n];\n\n// GET /api/v1/news - Get latest news\nrouter.get('/', async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 10,\n      category,\n      search,\n      sortBy = 'publishedAt',\n      sortOrder = 'desc'\n    } = req.query;\n\n    let filteredNews = [...mockNews];\n\n    // Filter by category\n    if (category) {\n      filteredNews = filteredNews.filter(news => news.category === category && news.isActive);\n    }\n\n    // Filter by search term\n    if (search) {\n      const searchRegex = new RegExp(search, 'i');\n      filteredNews = filteredNews.filter(\n        news =>\n          news.isActive &&\n          (searchRegex.test(news.title) ||\n            searchRegex.test(news.summary) ||\n            searchRegex.test(news.content) ||\n            news.tags.some(tag => searchRegex.test(tag)))\n      );\n    }\n\n    // Sort news\n    filteredNews.sort((a, b) => {\n      let aValue = a[sortBy];\n      let bValue = b[sortBy];\n\n      if (sortBy === 'publishedAt') {\n        aValue = new Date(aValue);\n        bValue = new Date(bValue);\n      }\n\n      if (sortOrder === 'desc') {\n        return bValue > aValue ? 1 : -1;\n      } else {\n        return aValue > bValue ? 1 : -1;\n      }\n    });\n\n    // Pagination\n    const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n    const paginatedNews = filteredNews.slice(skip, skip + parseInt(limit, 10));\n\n    // Calculate pagination info\n    const total = filteredNews.length;\n    const totalPages = Math.ceil(total / parseInt(limit, 10));\n\n    res.json({\n      success: true,\n      data: {\n        news: paginatedNews,\n        pagination: {\n          currentPage: parseInt(page, 10),\n          totalPages,\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10),\n          hasNextPage: parseInt(page, 10) < totalPages,\n          hasPrevPage: parseInt(page, 10) > 1\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Get news error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter notÃ­cias'\n    });\n  }\n});\n\n// GET /api/v1/news/categories - Get news categories\nrouter.get('/categories', async (req, res) => {\n  try {\n    const categories = [\n      {\n        id: 'grains',\n        name: 'GrÃ£os',\n        count: mockNews.filter(n => n.category === 'grains' && n.isActive).length\n      },\n      {\n        id: 'technology',\n        name: 'Tecnologia',\n        count: mockNews.filter(n => n.category === 'technology' && n.isActive).length\n      },\n      {\n        id: 'livestock',\n        name: 'PecuÃ¡ria',\n        count: mockNews.filter(n => n.category === 'livestock' && n.isActive).length\n      },\n      {\n        id: 'fertilizers',\n        name: 'Fertilizantes',\n        count: mockNews.filter(n => n.category === 'fertilizers' && n.isActive).length\n      },\n      {\n        id: 'machinery',\n        name: 'MaquinÃ¡rio',\n        count: mockNews.filter(n => n.category === 'machinery' && n.isActive).length\n      },\n      {\n        id: 'market',\n        name: 'Mercado',\n        count: mockNews.filter(n => n.category === 'market' && n.isActive).length\n      }\n    ];\n\n    res.json({\n      success: true,\n      data: {\n        categories,\n        totalCategories: categories.length\n      }\n    });\n  } catch (error) {\n    logger.error('Get categories error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter categorias'\n    });\n  }\n});\n\n// GET /api/v1/news/:id - Get news article by ID\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const news = mockNews.find(n => n.id === parseInt(id, 10) && n.isActive);\n\n    if (!news) {\n      return res.status(404).json({\n        success: false,\n        message: 'NotÃ­cia nÃ£o encontrada'\n      });\n    }\n\n    // Get related news (same category, excluding current)\n    const relatedNews = mockNews\n      .filter(n => n.id !== parseInt(id, 10) && n.category === news.category && n.isActive)\n      .slice(0, 3);\n\n    res.json({\n      success: true,\n      data: {\n        news,\n        relatedNews\n      }\n    });\n  } catch (error) {\n    logger.error('Get news by ID error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter notÃ­cia'\n    });\n  }\n});\n\n// GET /api/v1/news/rss/agribusiness - Get agribusiness RSS feed\nrouter.get('/rss/agribusiness', async (req, res) => {\n  try {\n    // Filter agribusiness related news\n    const agribusinessNews = mockNews\n      .filter(\n        news =>\n          news.isActive &&\n          (news.category === 'grains' ||\n            news.category === 'livestock' ||\n            news.category === 'fertilizers' ||\n            news.category === 'machinery')\n      )\n      .slice(0, 10);\n\n    // Create RSS feed\n    const items = agribusinessNews\n      .map(\n        n => `\n    <item>\n      <title><![CDATA[${n.title}]]></title>\n      <link>https://agrotm.com.br/news/${n.id}</link>\n      <description><![CDATA[${n.summary}]]></description>\n      <category>${n.category}</category>\n      <pubDate>${new Date(n.publishedAt).toUTCString()}</pubDate>\n      <guid>https://agrotm.com.br/news/${n.id}</guid>\n    </item>`\n      )\n      .join('');\n\n    const rssFeed = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\">\\n  <channel>\\n    <title>AGROTM - Notícias do Agronegócio</title>\\n    <link>https://agrotm.com.br/news</link>\\n    <description>Últimas notícias e atualizações do setor agrícola brasileiro</description>\\n    <language>pt-BR</language>\\n    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>\\n    <atom:link href=\"https://agrotm.com.br/api/v1/news/rss/agribusiness\" rel=\"self\" type=\"application/rss+xml\" />\\n${items}\\n  </channel>\\n</rss>`;\n\n    res.set('Content-Type', 'application/xml');\n    res.send(rssFeed);\n  } catch (error) {\n    logger.error('RSS feed error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao gerar feed RSS'\n    });\n  }\n});\n\n// GET /api/v1/news/featured - Get featured news\nrouter.get('/featured', async (req, res) => {\n  try {\n    const featuredNews = mockNews\n      .filter(news => news.isActive)\n      .sort((a, b) => new Date(b.publishedAt) - new Date(a.publishedAt))\n      .slice(0, 5);\n\n    res.json({\n      success: true,\n      data: {\n        featuredNews,\n        totalFeatured: featuredNews.length\n      }\n    });\n  } catch (error) {\n    logger.error('Get featured news error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter notÃ­cias em destaque'\n    });\n  }\n});\n\n// ConfiguraÃ§Ãµes\nconst RSS_URLS = {\n  'globo-rural': 'https://g1.globo.com/rss/g1/economia/agronegocios/',\n  agrolink: 'https://www.agrolink.com.br/rss/noticias',\n  'canal-rural': 'https://www.canalrural.com.br/rss/noticias'\n};\n\n// GET /api/news/globo-rural - Obter notÃ­cias do Globo Rural\nrouter.get(\n  '/globo-rural',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const rssUrl = RSS_URLS['globo-rural'];\n\n      // Fazer requisiÃ§Ã£o para o RSS\n      const response = await axios.get(rssUrl, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'AgroSync-News/1.0'\n        }\n      });\n\n      // Parsear o XML RSS (simplificado)\n      const rssData = parseRSSXML(response.data);\n\n      res.json({\n        success: true,\n        source: 'Globo Rural',\n        lastUpdated: new Date().toISOString(),\n        items: rssData.items || []\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias do Globo Rural:', error);\n      // Retornar dados de fallback\n      res.json({\n        success: true,\n        source: 'Globo Rural (Fallback)',\n        lastUpdated: new Date().toISOString(),\n        items: getFallbackNews()\n      });\n    }\n  }\n);\n\n// GET /api/news/agrolink - Obter notÃ­cias do Agrolink\nrouter.get(\n  '/agrolink',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const rssUrl = RSS_URLS['agrolink'];\n\n      const response = await axios.get(rssUrl, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'AgroSync-News/1.0'\n        }\n      });\n\n      const rssData = parseRSSXML(response.data);\n\n      res.json({\n        success: true,\n        source: 'Agrolink',\n        lastUpdated: new Date().toISOString(),\n        items: rssData.items || []\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias do Agrolink:', error);\n      res.json({\n        success: true,\n        source: 'Agrolink (Fallback)',\n        lastUpdated: new Date().toISOString(),\n        items: getFallbackNews()\n      });\n    }\n  }\n);\n\n// GET /api/news/canal-rural - Obter notÃ­cias do Canal Rural\nrouter.get(\n  '/canal-rural',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const rssUrl = RSS_URLS['canal-rural'];\n\n      const response = await axios.get(rssUrl, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'AgroSync-News/1.0'\n        }\n      });\n\n      const rssData = parseRSSXML(response.data);\n\n      res.json({\n        success: true,\n        source: 'Canal Rural',\n        lastUpdated: new Date().toISOString(),\n        items: rssData.items || []\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias do Canal Rural:', error);\n      res.json({\n        success: true,\n        source: 'Canal Rural (Fallback)',\n        lastUpdated: new Date().toISOString(),\n        items: getFallbackNews()\n      });\n    }\n  }\n);\n\n// GET /api/news/all - Obter notÃ­cias de todas as fontes\nrouter.get(\n  '/all',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const limit = parseInt(req.query.limit, 10) || 20;\n      const sources = Object.keys(RSS_URLS);\n      const allNews = [];\n\n      // Obter notÃ­cias de todas as fontes\n      for (const source of sources) {\n        try {\n          const response = await axios.get(RSS_URLS[source], {\n            timeout: 5000,\n            headers: {\n              'User-Agent': 'AgroSync-News/1.0'\n            }\n          });\n\n          const rssData = parseRSSXML(response.data);\n          if (rssData.items && rssData.items.length > 0) {\n            allNews.push(...rssData.items.slice(0, Math.ceil(limit / sources.length)));\n          }\n        } catch (error) {\n          logger.warn(`Erro ao obter notícias de ${source}:`, error.message);\n        }\n      }\n\n      // Ordenar por data e limitar\n      const sortedNews = allNews\n        .sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate))\n        .slice(0, limit);\n\n      res.json({\n        success: true,\n        sources,\n        lastUpdated: new Date().toISOString(),\n        totalItems: sortedNews.length,\n        items: sortedNews\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias de todas as fontes:', error);\n      res.json({\n        success: true,\n        sources: ['Fallback'],\n        lastUpdated: new Date().toISOString(),\n        totalItems: 10,\n        items: getFallbackNews(10)\n      });\n    }\n  }\n);\n\n// FunÃ§Ã£o para parsear XML RSS (simplificada)\nfunction parseRSSXML(xmlString) {\n  try {\n    // Parse bÃ¡sico do XML RSS\n    const items = [];\n\n    // Extrair itens do RSS\n    const itemRegex = /<item>([\\s\\S]*?)<\\/item>/g;\n    let match;\n\n    while ((match = itemRegex.exec(xmlString)) !== null) {\n      const itemContent = match[1];\n\n      const title = extractTag(itemContent, 'title');\n      const description = extractTag(itemContent, 'description');\n      const link = extractTag(itemContent, 'link');\n      const pubDate = extractTag(itemContent, 'pubDate');\n      const guid = extractTag(itemContent, 'guid');\n\n      if (title && link) {\n        items.push({\n          title: decodeXMLEntities(title),\n          description: decodeXMLEntities(description || ''),\n          link: decodeXMLEntities(link),\n          pubDate: pubDate || new Date().toISOString(),\n          guid: guid || link\n        });\n      }\n    }\n\n    return { items };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao parsear XML RSS:', error);\n    }\n    return { items: [] };\n  }\n}\n\n// FunÃ§Ã£o para extrair conteÃºdo de tags XML\nfunction extractTag(content, tagName) {\n  const regex = new RegExp(`<${tagName}[^>]*>([\\\\s\\\\S]*?)<\\\\/${tagName}>`, 'i');\n  const match = content.match(regex);\n  return match ? match[1].trim() : null;\n}\n\n// FunÃ§Ã£o para decodificar entidades XML\nfunction decodeXMLEntities(text) {\n  if (!text) {\n    return '';\n  }\n\n  return text\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&nbsp;/g, ' ');\n}\n\n// FunÃ§Ã£o para gerar notÃ­cias de fallback\nfunction getFallbackNews(limit = 10) {\n  const fallbackNews = [\n    {\n      title: 'Mercado agrÃ­cola em alta com forte demanda internacional',\n      description:\n        'Commodities agrÃ­colas brasileiras registram alta expressiva com forte demanda de paÃ­ses asiÃ¡ticos.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date().toISOString(),\n      guid: 'fallback-1'\n    },\n    {\n      title: 'Tecnologia revoluciona agricultura brasileira',\n      description:\n        'Novas tecnologias como drones e IoT aumentam produtividade no campo brasileiro.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-2'\n    },\n    {\n      title: 'Clima favorÃ¡vel para safra de grÃ£os 2024',\n      description:\n        'PrevisÃµes climÃ¡ticas indicam condiÃ§Ãµes favorÃ¡veis para a prÃ³xima safra de grÃ£os.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-3'\n    },\n    {\n      title: 'ExportaÃ§Ã£o de carne bovina atinge recorde',\n      description:\n        'Setor de carne bovina brasileiro registra recorde de exportaÃ§Ãµes para mercados internacionais.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-4'\n    },\n    {\n      title: 'Investimentos em agricultura sustentÃ¡vel crescem',\n      description:\n        'Produtores rurais investem cada vez mais em prÃ¡ticas sustentÃ¡veis e certificaÃ§Ãµes ambientais.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-5'\n    }\n  ];\n\n  return fallbackNews.slice(0, limit);\n}\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\notifications.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'skip' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":332,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":332,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport notificationService from '../services/notificationService.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Aplicar rate limiting\nrouter.use(apiLimiter);\n\n// Aplicar autenticaÃ§Ã£o em todas as rotas\nrouter.use(authenticateToken);\n\n// ===== ROTAS DE NOTIFICAÃ‡Ã•ES =====\n\n// GET /api/notifications - Listar notificaÃ§Ãµes do usuÃ¡rio\nrouter.get('/', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, read, archived = false, type, category } = req.query;\n\n    const result = await notificationService.getUserNotifications(req.user.userId, {\n      page: parseInt(page, 10),\n      limit: parseInt(limit, 10),\n      read: read === 'true' ? true : read === 'false' ? false : null,\n      archived: archived === 'true',\n      type,\n      category\n    });\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao buscar notificaÃ§Ãµes:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/unread - Contar notificaÃ§Ãµes nÃ£o lidas\nrouter.get('/unread/count', async (req, res) => {\n  try {\n    const result = await notificationService.getUserNotifications(req.user.userId, {\n      read: false,\n      archived: false,\n      limit: 1\n    });\n\n    if (result.success) {\n      res.json({\n        success: true,\n        count: result.data.pagination.total\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao contar notificaÃ§Ãµes nÃ£o lidas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/:id - Obter notificaÃ§Ã£o especÃ­fica\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    // Buscar notificaÃ§Ã£o especÃ­fica do usuÃ¡rio\n    const result = await notificationService.getUserNotifications(userId, {\n      limit: 1000 // Buscar todas para encontrar a especÃ­fica\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    const notification = result.data.notifications.find(n => n._id.toString() === id);\n\n    if (!notification) {\n      return res.status(404).json({\n        success: false,\n        message: 'NotificaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: notification\n    });\n  } catch (error) {\n    logger.error('Erro ao buscar notificaÃ§Ã£o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/notifications/:id/read - Marcar como lida\nrouter.patch('/:id/read', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const result = await notificationService.markAsRead(id, userId);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao marcar como lida:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/notifications/:id/archive - Arquivar notificaÃ§Ã£o\nrouter.patch('/:id/archive', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const result = await notificationService.archiveNotification(id, userId);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao arquivar notificaÃ§Ã£o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/notifications/read-all - Marcar todas como lidas\nrouter.patch('/read-all', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar todas as notificaÃ§Ãµes nÃ£o lidas\n    const result = await notificationService.getUserNotifications(userId, {\n      read: false,\n      archived: false,\n      limit: 1000\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    // Marcar todas como lidas\n    const { notifications } = result.data;\n    const updatePromises = notifications.map(notification => notification.markAsRead());\n\n    await Promise.all(updatePromises);\n\n    res.json({\n      success: true,\n      message: `${notifications.length} notificaÃ§Ãµes marcadas como lidas`,\n      count: notifications.length\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao marcar todas como lidas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/notifications/:id - Deletar notificaÃ§Ã£o\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    // Buscar notificaÃ§Ã£o\n    const result = await notificationService.getUserNotifications(userId, {\n      limit: 1000\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    const notification = result.data.notifications.find(n => n._id.toString() === id);\n\n    if (!notification) {\n      return res.status(404).json({\n        success: false,\n        message: 'NotificaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Deletar notificaÃ§Ã£o\n    await notification.deleteOne();\n\n    res.json({\n      success: true,\n      message: 'NotificaÃ§Ã£o deletada com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao deletar notificaÃ§Ã£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/notifications/clear-read - Limpar notificaÃ§Ãµes lidas\nrouter.delete('/clear-read', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar todas as notificaÃ§Ãµes lidas\n    const result = await notificationService.getUserNotifications(userId, {\n      read: true,\n      archived: false,\n      limit: 1000\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    // Deletar todas as lidas\n    const { notifications } = result.data;\n    const deletePromises = notifications.map(notification => notification.deleteOne());\n\n    await Promise.all(deletePromises);\n\n    res.json({\n      success: true,\n      message: `${notifications.length} notificaÃ§Ãµes lidas removidas`,\n      count: notifications.length\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao limpar notificaÃ§Ãµes lidas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/stats - EstatÃ­sticas das notificaÃ§Ãµes\nrouter.get('/stats/overview', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const result = await notificationService.getNotificationStats(userId);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS ADMIN (APENAS PARA ADMINISTRADORES) =====\n\n// Middleware para verificar se Ã© admin\nconst adminAuth = (req, res, next) => {\n  if (!req.user.isAdmin) {\n    return res.status(403).json({\n      success: false,\n      message: 'Acesso negado. Apenas administradores.'\n    });\n  }\n  next();\n};\n\n// GET /api/notifications/admin/all - Listar todas as notificaÃ§Ãµes (admin)\nrouter.get('/admin/all', adminAuth, async (req, res) => {\n  try {\n    const { page = 1, limit = 50, userId, type, category, status } = req.query;\n\n    // Construir query\n    const query = {};\n    if (userId) {\n      query.userId = userId;\n    }\n    if (type) {\n      query.type = type;\n    }\n    if (category) {\n      query.category = category;\n    }\n    if (status) {\n      if (status === 'read') {\n        query.read = true;\n      } else if (status === 'unread') {\n        query.read = false;\n      } else if (status === 'archived') {\n        query.archived = true;\n      }\n    }\n\n    const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n\n    // Buscar notificaÃ§Ãµes\n    const notifications = await notificationService.getUserNotifications(null, {\n      limit: 1000\n    });\n\n    if (!notifications.success) {\n      return res.status(400).json(notifications);\n    }\n\n    const { total } = notifications.data.pagination;\n\n    res.json({\n      success: true,\n      data: {\n        notifications,\n        pagination: {\n          page: parseInt(page, 10),\n          limit: parseInt(limit, 10),\n          total,\n          pages: Math.ceil(total / parseInt(limit, 10))\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar todas as notificaÃ§Ãµes:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/notifications/admin/send - Enviar notificaÃ§Ã£o manual (admin)\nrouter.post('/admin/send', adminAuth, async (req, res) => {\n  try {\n    const { userId, type, title, body, channels, priority, category, data, metadata } = req.body;\n\n    if (!userId || !type || !title || !body) {\n      return res.status(400).json({\n        success: false,\n        message: 'userId, type, title e body sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const result = await notificationService.createAndSendNotification({\n      userId,\n      type,\n      title,\n      body,\n      channels,\n      priority,\n      category,\n      data,\n      metadata\n    });\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao enviar notificaÃ§Ã£o manual:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/admin/stats - EstatÃ­sticas gerais (admin)\nrouter.get('/admin/stats', adminAuth, async (req, res) => {\n  try {\n    const result = await notificationService.getNotificationStats();\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas gerais:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/notifications/admin/cleanup - Limpeza manual (admin)\nrouter.post('/admin/cleanup', adminAuth, async (req, res) => {\n  try {\n    const result = await notificationService.cleanupExpiredNotifications();\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao fazer limpeza manual:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\partners.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\partnership-messages.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport mongoose from 'mongoose';\nimport PartnershipMessage from '../models/PartnershipMessage.js';\nimport Partner from '../models/Partner.js';\nimport User from '../models/User.js';\nimport { authenticateToken, requireAdmin } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\nimport { sanitizeInput } from '../utils/sanitizer.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO =====\n\n// ValidaÃ§Ã£o para mensagens de parceiros\nconst validatePartnershipMessage = (req, res, next) => {\n  const { partnerId, subject, content, messageType, category, priority } = req.body;\n\n  if (!partnerId || !subject || !content) {\n    return res.status(400).json({\n      success: false,\n      message: 'ID do parceiro, assunto e conteÃºdo sÃ£o obrigatÃ³rios'\n    });\n  }\n\n  if (!mongoose.Types.ObjectId.isValid(partnerId)) {\n    return res.status(400).json({\n      success: false,\n      message: 'ID do parceiro invÃ¡lido'\n    });\n  }\n\n  if (subject.trim().length < 5 || subject.trim().length > 200) {\n    return res.status(400).json({\n      success: false,\n      message: 'Assunto deve ter entre 5 e 200 caracteres'\n    });\n  }\n\n  if (content.trim().length < 10 || content.trim().length > 5000) {\n    return res.status(400).json({\n      success: false,\n      message: 'ConteÃºdo deve ter entre 10 e 5000 caracteres'\n    });\n  }\n\n  // Validar tipo de mensagem\n  const validMessageTypes = [\n    'partnership_request',\n    'business_proposal',\n    'collaboration',\n    'support',\n    'general',\n    'urgent'\n  ];\n  if (messageType && !validMessageTypes.includes(messageType)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Tipo de mensagem invÃ¡lido'\n    });\n  }\n\n  // Validar categoria\n  const validCategories = [\n    'agriculture',\n    'technology',\n    'finance',\n    'logistics',\n    'marketing',\n    'research',\n    'other'\n  ];\n  if (category && !validCategories.includes(category)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Categoria invÃ¡lida'\n    });\n  }\n\n  // Validar prioridade\n  const validPriorities = ['low', 'normal', 'high', 'urgent'];\n  if (priority && !validPriorities.includes(priority)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Prioridade invÃ¡lida'\n    });\n  }\n\n  next();\n};\n\n// ===== ROTAS DE MENSAGENS DE PARCEIROS =====\n\n// GET /api/partnership-messages - Listar mensagens de parceiros (admin apenas)\nrouter.get('/', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const { page = 1, limit = 20, status, priority, category, partnerId, assignedTo } = req.query;\n    const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n\n    const query = {};\n\n    // Filtros\n    if (status) {\n      query.status = status;\n    }\n    if (priority) {\n      query.priority = priority;\n    }\n    if (category) {\n      query.category = category;\n    }\n    if (partnerId) {\n      query.partnerId = partnerId;\n    }\n    if (assignedTo) {\n      query.assignedTo = assignedTo;\n    }\n\n    const messages = await PartnershipMessage.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10))\n      .populate('partnerId', 'name company category')\n      .populate('assignedTo', 'name email')\n      .populate('readBy', 'name email')\n      .populate('repliedBy', 'name email');\n\n    const total = await PartnershipMessage.countDocuments(query);\n\n    // Log de acesso\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin accessed partnership messages',\n      req,\n      req.user.userId\n    );\n\n    res.json({\n      success: true,\n      data: {\n        messages,\n        pagination: {\n          currentPage: parseInt(page, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership messages:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching partnership messages: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/partnership-messages - Criar nova mensagem de parceiro\nrouter.post('/', authenticateToken, requireAdmin, validatePartnershipMessage, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const { partnerId, subject, content, messageType, category, priority, tags, assignedTo } =\n      req.body;\n\n    // Verificar se o parceiro existe\n    const partner = await Partner.findById(partnerId);\n    if (!partner) {\n      return res.status(404).json({\n        success: false,\n        message: 'Parceiro nÃ£o encontrado'\n      });\n    }\n\n    // Criar mensagem\n    const message = new PartnershipMessage({\n      partnerId,\n      subject: sanitizeInput(subject.trim()),\n      content: sanitizeInput(content.trim()),\n      messageType: messageType || 'general',\n      category: category || 'other',\n      priority: priority || 'normal',\n      tags: tags || [],\n      assignedTo: assignedTo || adminId\n    });\n\n    await message.save();\n\n    // Populate informaÃ§Ãµes\n    await message.populate([\n      { path: 'partnerId', select: 'name company category' },\n      { path: 'assignedTo', select: 'name email' }\n    ]);\n\n    // Log de criaÃ§Ã£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      'Admin created partnership message',\n      req,\n      adminId,\n      {\n        partnerId,\n        messageId: message._id,\n        messageType\n      }\n    );\n\n    res.status(201).json({\n      success: true,\n      message: 'Mensagem de parceiro criada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error creating partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/partnership-messages/:id - Obter mensagem especÃ­fica\nrouter.get('/:id', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const messageId = req.params.id;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId)\n      .populate('partnerId', 'name company category contact')\n      .populate('assignedTo', 'name email')\n      .populate('readBy', 'name email')\n      .populate('repliedBy', 'name email')\n      .populate('flaggedBy', 'name email');\n\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Log de acesso\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin accessed specific partnership message',\n      req,\n      req.user.userId,\n      {\n        messageId\n      }\n    );\n\n    res.json({\n      success: true,\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/partnership-messages/:id - Atualizar mensagem\nrouter.put('/:id', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const messageId = req.params.id;\n    const { subject, content, messageType, category, priority, tags, adminNotes, assignedTo } =\n      req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Atualizar campos permitidos\n    if (subject) {\n      message.subject = sanitizeInput(subject.trim());\n    }\n    if (content) {\n      message.content = sanitizeInput(content.trim());\n    }\n    if (messageType) {\n      message.messageType = messageType;\n    }\n    if (category) {\n      message.category = category;\n    }\n    if (priority) {\n      message.priority = priority;\n    }\n    if (tags) {\n      message.tags = tags;\n    }\n    if (adminNotes) {\n      message.adminNotes = sanitizeInput(adminNotes.trim());\n    }\n    if (assignedTo) {\n      message.assignedTo = assignedTo;\n    }\n\n    await message.save();\n\n    // Log de atualizaÃ§Ã£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      'Admin updated partnership message',\n      req,\n      adminId,\n      {\n        messageId,\n        updatedFields: Object.keys(req.body)\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'Mensagem atualizada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error updating partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/partnership-messages/:id/status - Atualizar status da mensagem\nrouter.put('/:id/status', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const messageId = req.params.id;\n    const { status, action } = req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Executar aÃ§Ã£o baseada no status\n    switch (action) {\n      case 'mark_read':\n        await message.markAsRead(adminId);\n        break;\n      case 'mark_in_progress':\n        await message.markInProgress(adminId);\n        break;\n      case 'reply':\n        if (!req.body.replyContent) {\n          return res.status(400).json({\n            success: false,\n            message: 'ConteÃºdo da resposta Ã© obrigatÃ³rio'\n          });\n        }\n        await message.reply(req.body.replyContent, adminId);\n        break;\n      case 'close':\n        await message.close(adminId);\n        break;\n      case 'archive':\n        await message.archive(adminId);\n        break;\n      case 'flag':\n        if (!req.body.flagReason) {\n          return res.status(400).json({\n            success: false,\n            message: 'Motivo da sinalizaÃ§Ã£o Ã© obrigatÃ³rio'\n          });\n        }\n        await message.flag(req.body.flagReason, adminId);\n        break;\n      case 'unflag':\n        await message.unflag();\n        break;\n      default:\n        if (status) {\n          message.status = status;\n          await message.save();\n        }\n    }\n\n    // Log de aÃ§Ã£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      `Admin performed action on partnership message: ${action}`,\n      req,\n      adminId,\n      {\n        messageId,\n        action,\n        newStatus: message.status\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'AÃ§Ã£o executada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating partnership message status:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error updating partnership message status: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/partnership-messages/:id - Excluir mensagem\nrouter.delete('/:id', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const messageId = req.params.id;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Soft delete - marcar como arquivada\n    message.status = 'archived';\n    message.assignedTo = adminId;\n    message.assignedAt = new Date();\n    await message.save();\n\n    // Log de exclusÃ£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      'Admin archived partnership message',\n      req,\n      adminId,\n      {\n        messageId\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'Mensagem arquivada com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error archiving partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error archiving partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/partnership-messages/stats - EstatÃ­sticas das mensagens\nrouter.get('/stats/overview', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const stats = await PartnershipMessage.getMessageStats();\n\n    // Contar mensagens por prioridade\n    const priorityStats = await PartnershipMessage.aggregate([\n      {\n        $group: {\n          _id: '$priority',\n          count: { $sum: 1 }\n        }\n      }\n    ]);\n\n    // Contar mensagens por categoria\n    const categoryStats = await PartnershipMessage.aggregate([\n      {\n        $group: {\n          _id: '$category',\n          count: { $sum: 1 }\n        }\n      }\n    ]);\n\n    // Contar mensagens nÃ£o lidas\n    const unreadCount = await PartnershipMessage.countDocuments({\n      isRead: false,\n      status: { $nin: ['closed', 'archived'] }\n    });\n\n    // Log de acesso Ã s estatÃ­sticas\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin accessed partnership messages statistics',\n      req,\n      req.user.userId\n    );\n\n    res.json({\n      success: true,\n      data: {\n        statusStats: stats,\n        priorityStats: priorityStats.reduce((acc, stat) => {\n          acc[stat._id] = stat.count;\n          return acc;\n        }, {}),\n        categoryStats: categoryStats.reduce((acc, stat) => {\n          acc[stat._id] = stat.count;\n          return acc;\n        }, {}),\n        unreadCount\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership messages stats:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching partnership messages stats: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/partnership-messages/search/:term - Buscar mensagens\nrouter.get('/search/:term', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const searchTerm = req.params.term;\n    const { page = 1, limit = 20 } = req.query;\n    const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n\n    if (!searchTerm || searchTerm.trim().length < 2) {\n      return res.status(400).json({\n        success: false,\n        message: 'Termo de busca deve ter pelo menos 2 caracteres'\n      });\n    }\n\n    const messages = await PartnershipMessage.searchMessages(\n      searchTerm.trim(),\n      parseInt(limit, 10)\n    );\n    const total = messages.length;\n\n    // Log de busca\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin searched partnership messages',\n      req,\n      req.user.userId,\n      {\n        searchTerm\n      }\n    );\n\n    res.json({\n      success: true,\n      data: {\n        messages: messages.slice(skip, skip + parseInt(limit, 10)),\n        pagination: {\n          currentPage: parseInt(page, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error searching partnership messages:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error searching partnership messages: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\payment-verification.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'apiRateLimiter' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":24},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":296,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":296,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiRateLimiter } from '../middleware/rateLimiter.js';\nimport AuditLog from '../models/AuditLog.js';\nimport User from '../models/User.js';\nimport Payment from '../models/Payment.js';\nimport stripe from 'stripe';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Inicializar Stripe\nconst stripeClient = new stripe(process.env.STRIPE_SECRET_KEY);\n\n// ===== VERIFICAÃ‡ÃƒO DE PAGAMENTO =====\n\n// GET /api/payment-verification/status - Verificar status do pagamento do usuÃ¡rio\nrouter.get('/status', authenticateToken, async (req, res) => {\n  try {\n    const userId = req.user.id;\n\n    // Buscar usuÃ¡rio\n    const user = await User.findById(userId);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Verificar planos ativos\n    const hasActivePlan =\n      user.subscriptions &&\n      ((user.subscriptions.store && user.subscriptions.store.status === 'active') ||\n        (user.subscriptions.agroconecta && user.subscriptions.agroconecta.status === 'active'));\n\n    // Verificar pagamentos recentes (Ãºltimos 30 dias)\n    const thirtyDaysAgo = new Date();\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n    const recentPayments = await Payment.find({\n      userId,\n      status: 'completed',\n      createdAt: { $gte: thirtyDaysAgo }\n    }).sort({ createdAt: -1 });\n\n    // Verificar pagamentos pendentes\n    const pendingPayments = await Payment.find({\n      userId,\n      status: { $in: ['pending', 'processing'] }\n    }).sort({ createdAt: -1 });\n\n    // Status geral\n    const paymentStatus = {\n      hasActivePlan,\n      hasRecentPayment: recentPayments.length > 0,\n      hasPendingPayment: pendingPayments.length > 0,\n      lastPayment: recentPayments[0] || null,\n      pendingPayment: pendingPayments[0] || null,\n      canAccessMessaging: hasActivePlan || recentPayments.length > 0\n    };\n\n    // Log da verificaÃ§Ã£o\n    await AuditLog.logAction({\n      userId,\n      userEmail: req.user.email,\n      action: 'PAYMENT_STATUS_CHECKED',\n      resource: 'payment_verification',\n      details: `Payment status checked. Has access: ${paymentStatus.canAccessMessaging}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      data: paymentStatus\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar status do pagamento:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'PAYMENT_STATUS_CHECK_ERROR',\n      resource: 'payment_verification',\n      details: `Error checking payment status: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'STATUS_CHECK_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/payment-verification/verify-stripe - Verificar pagamento Stripe\nrouter.post('/verify-stripe', authenticateToken, async (req, res) => {\n  try {\n    const { paymentIntentId } = req.body;\n    const userId = req.user.id;\n\n    if (!paymentIntentId) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID do pagamento Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Verificar pagamento no Stripe\n    const paymentIntent = await stripeClient.paymentIntents.retrieve(paymentIntentId);\n\n    if (paymentIntent.status === 'succeeded') {\n      // Buscar ou criar registro de pagamento\n      let payment = await Payment.findOne({\n        stripePaymentIntentId: paymentIntentId\n      });\n\n      if (!payment) {\n        payment = new Payment({\n          userId,\n          amount: paymentIntent.amount / 100, // Stripe usa centavos\n          currency: paymentIntent.currency,\n          status: 'completed',\n          provider: 'stripe',\n          stripePaymentIntentId: paymentIntentId,\n          metadata: {\n            stripeCustomerId: paymentIntent.customer,\n            stripeChargeId: paymentIntent.latest_charge\n          }\n        });\n\n        await payment.save();\n      }\n\n      // Atualizar status do usuÃ¡rio se necessÃ¡rio\n      const user = await User.findById(userId);\n      if (user) {\n        // Aqui vocÃª pode implementar lÃ³gica para ativar planos especÃ­ficos\n        // baseado no valor do pagamento ou metadata\n        await user.save();\n      }\n\n      // Log do pagamento verificado\n      await AuditLog.logAction({\n        userId,\n        userEmail: req.user.email,\n        action: 'STRIPE_PAYMENT_VERIFIED',\n        resource: 'payment_verification',\n        resourceId: payment._id,\n        details: `Stripe payment verified: ${paymentIntentId}`,\n        ip: req.ip,\n        userAgent: req.get('User-Agent')\n      });\n\n      res.json({\n        success: true,\n        message: 'Pagamento verificado com sucesso',\n        data: {\n          payment,\n          canAccessMessaging: true\n        }\n      });\n    } else {\n      return res.status(400).json({\n        success: false,\n        message: 'Pagamento nÃ£o foi concluÃ­do com sucesso',\n        data: {\n          status: paymentIntent.status,\n          canAccessMessaging: false\n        }\n      });\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar pagamento Stripe:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'STRIPE_PAYMENT_VERIFICATION_ERROR',\n      resource: 'payment_verification',\n      details: `Error verifying Stripe payment: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'STRIPE_VERIFICATION_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar pagamento'\n    });\n  }\n});\n\n// POST /api/payment-verification/verify-metamask - Verificar pagamento Metamask\nrouter.post('/verify-metamask', authenticateToken, async (req, res) => {\n  try {\n    const { transactionHash, amount, currency, network } = req.body;\n    const userId = req.user.id;\n\n    if (!transactionHash || !amount || !currency || !network) {\n      return res.status(400).json({\n        success: false,\n        message: 'Todos os campos sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Verificar se jÃ¡ existe pagamento com este hash\n    let payment = await Payment.findOne({\n      metamaskTransactionHash: transactionHash\n    });\n\n    if (payment) {\n      return res.status(400).json({\n        success: false,\n        message: 'TransaÃ§Ã£o jÃ¡ foi verificada'\n      });\n    }\n\n    // Aqui vocÃª implementaria a verificaÃ§Ã£o real da transaÃ§Ã£o na blockchain\n    // Por enquanto, vamos assumir que Ã© vÃ¡lida se os dados estÃ£o corretos\n\n    // Criar registro de pagamento\n    payment = new Payment({\n      userId,\n      amount: parseFloat(amount),\n      currency,\n      status: 'completed',\n      provider: 'metamask',\n      metamaskTransactionHash: transactionHash,\n      metadata: {\n        network,\n        verifiedAt: new Date()\n      }\n    });\n\n    await payment.save();\n\n    // Atualizar status do usuÃ¡rio se necessÃ¡rio\n    const user = await User.findById(userId);\n    if (user) {\n      // Implementar lÃ³gica de ativaÃ§Ã£o de planos\n      await user.save();\n    }\n\n    // Log do pagamento verificado\n    await AuditLog.logAction({\n      userId,\n      userEmail: req.user.email,\n      action: 'METAMASK_PAYMENT_VERIFIED',\n      resource: 'payment_verification',\n      resourceId: payment._id,\n      details: `Metamask payment verified: ${transactionHash}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'Pagamento Metamask verificado com sucesso',\n      data: {\n        payment,\n        canAccessMessaging: true\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar pagamento Metamask:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'METAMASK_PAYMENT_VERIFICATION_ERROR',\n      resource: 'payment_verification',\n      details: `Error verifying Metamask payment: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'METAMASK_VERIFICATION_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar pagamento Metamask'\n    });\n  }\n});\n\n// GET /api/payment-verification/plans - Obter planos disponÃ­veis\nrouter.get('/plans', authenticateToken, async (req, res) => {\n  try {\n    const plans = {\n      store: {\n        id: 'store',\n        name: 'Loja',\n        price: 25.0,\n        currency: 'BRL',\n        interval: 'month',\n        features: [\n          'AtÃ© 3 anÃºncios de produtos',\n          'Mensageria privada com compradores',\n          'Dashboard de vendas',\n          'Suporte prioritÃ¡rio'\n        ],\n        messagingAccess: true\n      },\n      agroconecta: {\n        id: 'agroconecta',\n        name: 'AgroConecta',\n        price: 50.0,\n        currency: 'BRL',\n        interval: 'month',\n        features: [\n          'AtÃ© 10 anÃºncios de fretes',\n          'Mensageria privada com fretistas',\n          'Rastreamento de cargas',\n          'Suporte 24/7'\n        ],\n        messagingAccess: true\n      },\n      agroconectaPro: {\n        id: 'agroconecta-pro',\n        name: 'AgroConecta Pro',\n        price: 149.0,\n        currency: 'BRL',\n        interval: 'month',\n        features: [\n          'AtÃ© 30 anÃºncios de fretes',\n          'Mensageria privada ilimitada',\n          'Rastreamento GPS em tempo real',\n          'RelatÃ³rios avanÃ§ados',\n          'Suporte VIP'\n        ],\n        messagingAccess: true\n      }\n    };\n\n    res.json({\n      success: true,\n      data: plans\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar planos:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/payment-verification/create-stripe-session - Criar sessÃ£o de pagamento Stripe\nrouter.post('/create-stripe-session', authenticateToken, async (req, res) => {\n  try {\n    const { planId, successUrl, cancelUrl } = req.body;\n    const userId = req.user.id;\n\n    if (!planId || !successUrl || !cancelUrl) {\n      return res.status(400).json({\n        success: false,\n        message: 'Todos os campos sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Buscar usuÃ¡rio\n    const user = await User.findById(userId);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Definir preÃ§o baseado no plano\n    let price;\n    switch (planId) {\n      case 'store':\n        price = 2500; // R$25.00 em centavos\n        break;\n      case 'agroconecta':\n        price = 5000; // R$50.00 em centavos\n        break;\n      case 'agroconecta-pro':\n        price = 14900; // R$149.00 em centavos\n        break;\n      default:\n        return res.status(400).json({\n          success: false,\n          message: 'Plano invÃ¡lido'\n        });\n    }\n\n    // Criar sessÃ£o do Stripe\n    const session = await stripeClient.checkout.sessions.create({\n      customer_email: user.email,\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price_data: {\n            currency: 'brl',\n            product_data: {\n              name: `Plano ${planId}`,\n              description: `Assinatura mensal do plano ${planId}`\n            },\n            unit_amount: price\n          },\n          quantity: 1\n        }\n      ],\n      mode: 'subscription',\n      success_url: successUrl,\n      cancel_url: cancelUrl,\n      metadata: {\n        userId,\n        planId\n      }\n    });\n\n    // Log da criaÃ§Ã£o da sessÃ£o\n    await AuditLog.logAction({\n      userId,\n      userEmail: user.email,\n      action: 'STRIPE_SESSION_CREATED',\n      resource: 'payment_verification',\n      details: `Stripe session created for plan: ${planId}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      data: {\n        sessionId: session.id,\n        url: session.url\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao criar sessÃ£o do Stripe:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'STRIPE_SESSION_CREATION_ERROR',\n      resource: 'payment_verification',\n      details: `Error creating Stripe session: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'SESSION_CREATION_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao criar sessÃ£o de pagamento'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\plans.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\privacy.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\registration.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'auth' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":4,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":11},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":22,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":22,"endColumn":34},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":51,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":51,"endColumn":33},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":79,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":79,"endColumn":35},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":118,"column":36,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":118,"endColumn":38},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":140,"column":36,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":140,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿const express = require('express');\nconst router = express.Router();\nconst { AgroConecta, Loja, Marketplace, Fazenda } = require('../models/Registration');\nconst auth = require('../middleware/auth');\nconst rateLimit = require('express-rate-limit');\n\n// Rate limiting para APIs externas\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 100, // mÃ¡ximo 100 requests por IP\n  message: 'Muitas tentativas de acesso. Tente novamente em 15 minutos.'\n});\n\n// Rate limiting para cadastros\nconst registrationLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hora\n  max: 5, // mÃ¡ximo 5 cadastros por IP por hora\n  message: 'Muitos cadastros realizados. Tente novamente em 1 hora.'\n});\n\n// FunÃ§Ã£o para buscar dados por CEP\nconst fetchCEPData = async cep => {\n  try {\n    // Simular API dos Correios (substituir por API real)\n    const cleanCEP = cep.replace(/\\D/g, '');\n\n    if (cleanCEP.length !== 8) {\n      throw new Error('CEP invÃ¡lido');\n    }\n\n    // Mock data - substituir por chamada real para API dos Correios\n    const mockData = {\n      cep,\n      logradouro: 'Avenida Paulista',\n      bairro: 'Bela Vista',\n      localidade: 'SÃ£o Paulo',\n      uf: 'SP',\n      ibge: '3550308',\n      gia: '1004',\n      ddd: '11',\n      siafi: '7107'\n    };\n\n    return mockData;\n  } catch (error) {\n    throw new Error(`Erro ao buscar CEP: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para validar CPF na Receita Federal\nconst validateCPF = async cpf => {\n  try {\n    const cleanCPF = cpf.replace(/\\D/g, '');\n\n    if (cleanCPF.length !== 11) {\n      throw new Error('CPF deve ter 11 dÃ­gitos');\n    }\n\n    // Simular validaÃ§Ã£o na Receita Federal\n    // Em produÃ§Ã£o, usar API real da Receita Federal\n    const isValid = true; // Mock validation\n\n    if (!isValid) {\n      throw new Error('CPF invÃ¡lido na Receita Federal');\n    }\n\n    return {\n      isValid: true,\n      status: 'VALID',\n      name: 'Nome da Pessoa', // Mock - em produÃ§Ã£o viria da API\n      birthDate: '1990-01-01' // Mock\n    };\n  } catch (error) {\n    throw new Error(`Erro ao validar CPF: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para validar CNPJ na Receita Federal\nconst validateCNPJ = async cnpj => {\n  try {\n    const cleanCNPJ = cnpj.replace(/\\D/g, '');\n\n    if (cleanCNPJ.length !== 14) {\n      throw new Error('CNPJ deve ter 14 dÃ­gitos');\n    }\n\n    // Simular validaÃ§Ã£o na Receita Federal\n    // Em produÃ§Ã£o, usar API real da Receita Federal\n    const isValid = true; // Mock validation\n\n    if (!isValid) {\n      throw new Error('CNPJ invÃ¡lido na Receita Federal');\n    }\n\n    return {\n      isValid: true,\n      status: 'ATIVA',\n      companyName: 'Empresa Exemplo LTDA', // Mock - em produÃ§Ã£o viria da API\n      fantasyName: 'Empresa Exemplo',\n      openingDate: '2020-01-01',\n      ie: '123.456.789.012',\n      address: {\n        street: 'Rua das Flores, 123',\n        neighborhood: 'Centro',\n        city: 'SÃ£o Paulo',\n        state: 'SP',\n        zipCode: '01000-000'\n      },\n      activities: ['ComÃ©rcio de produtos agrÃ­colas'],\n      capital: 100000\n    };\n  } catch (error) {\n    throw new Error(`Erro ao validar CNPJ: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para buscar localizaÃ§Ã£o por IP\nconst fetchLocationByIP = async ip => {\n  try {\n    // Simular busca por IP (substituir por API real como ipapi.co)\n    const mockData = {\n      ip,\n      city: 'SÃ£o Paulo',\n      region: 'SÃ£o Paulo',\n      country: 'BR',\n      country_name: 'Brazil',\n      postal: '01000-000',\n      latitude: -23.5505,\n      longitude: -46.6333,\n      timezone: 'America/Sao_Paulo'\n    };\n\n    return mockData;\n  } catch (error) {\n    throw new Error(`Erro ao buscar localizaÃ§Ã£o: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para buscar produtos por API\nconst searchProducts = async query => {\n  try {\n    // Simular busca de produtos (substituir por API real)\n    const mockProducts = [\n      {\n        id: '1',\n        name: 'Soja',\n        category: 'GrÃ£os',\n        unit: 'saca',\n        description: 'Soja para alimentaÃ§Ã£o animal'\n      },\n      {\n        id: '2',\n        name: 'Milho',\n        category: 'GrÃ£os',\n        unit: 'saca',\n        description: 'Milho para alimentaÃ§Ã£o animal'\n      },\n      {\n        id: '3',\n        name: 'Trigo',\n        category: 'GrÃ£os',\n        unit: 'saca',\n        description: 'Trigo para panificaÃ§Ã£o'\n      },\n      { id: '4', name: 'CafÃ©', category: 'Bebidas', unit: 'kg', description: 'CafÃ© em grÃ£o' },\n      {\n        id: '5',\n        name: 'AÃ§Ãºcar',\n        category: 'DulÃ§or',\n        unit: 'kg',\n        description: 'AÃ§Ãºcar cristal'\n      },\n      {\n        id: '6',\n        name: 'Fertilizante NPK',\n        category: 'Insumos',\n        unit: 'kg',\n        description: 'Fertilizante NPK 20-10-10'\n      },\n      {\n        id: '7',\n        name: 'Sementes de Soja',\n        category: 'Insumos',\n        unit: 'kg',\n        description: 'Sementes de soja certificadas'\n      },\n      {\n        id: '8',\n        name: 'Defensivo AgrÃ­cola',\n        category: 'Insumos',\n        unit: 'L',\n        description: 'Defensivo para controle de pragas'\n      }\n    ];\n\n    const filtered = mockProducts.filter(\n      product =>\n        product.name.toLowerCase().includes(query.toLowerCase()) ||\n        product.category.toLowerCase().includes(query.toLowerCase()) ||\n        product.description.toLowerCase().includes(query.toLowerCase())\n    );\n\n    return filtered;\n  } catch (error) {\n    throw new Error(`Erro ao buscar produtos: ${error.message}`);\n  }\n};\n\n// GET /api/registration/cep/:cep - Buscar dados por CEP\nrouter.get('/cep/:cep', apiLimiter, async (req, res) => {\n  try {\n    const { cep } = req.params;\n    const data = await fetchCEPData(cep);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/validate/cpf/:cpf - Validar CPF\nrouter.get('/validate/cpf/:cpf', apiLimiter, async (req, res) => {\n  try {\n    const { cpf } = req.params;\n    const data = await validateCPF(cpf);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/validate/cnpj/:cnpj - Validar CNPJ\nrouter.get('/validate/cnpj/:cnpj', apiLimiter, async (req, res) => {\n  try {\n    const { cnpj } = req.params;\n    const data = await validateCNPJ(cnpj);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/location/:ip - Buscar localizaÃ§Ã£o por IP\nrouter.get('/location/:ip', apiLimiter, async (req, res) => {\n  try {\n    const { ip } = req.params;\n    const data = await fetchLocationByIP(ip);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/products/search/:query - Buscar produtos\nrouter.get('/products/search/:query', apiLimiter, async (req, res) => {\n  try {\n    const { query } = req.params;\n    const products = await searchProducts(query);\n\n    res.json({\n      success: true,\n      data: products\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// POST /api/registration/agroconecta - Cadastrar no AgroConecta\nrouter.post('/agroconecta', registrationLimiter, async (req, res) => {\n  try {\n    const {\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      vehicle,\n      services,\n      plan,\n      isPublic\n    } = req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await AgroConecta.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await AgroConecta.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCNPJ = await AgroConecta.findOne({ cnpj });\n    if (existingCNPJ) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newAgroConecta = new AgroConecta({\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      vehicle,\n      services,\n      plan,\n      isPublic\n    });\n\n    await newAgroConecta.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newAgroConecta._id,\n        email: newAgroConecta.email,\n        plan: newAgroConecta.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar AgroConecta:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/registration/loja - Cadastrar na Loja\nrouter.post('/loja', registrationLimiter, async (req, res) => {\n  try {\n    const { name, email, phone, cpf, companyName, cnpj, ie, address, products, plan, isPublic } =\n      req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await Loja.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await Loja.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCNPJ = await Loja.findOne({ cnpj });\n    if (existingCNPJ) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newLoja = new Loja({\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      products,\n      plan,\n      isPublic\n    });\n\n    await newLoja.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newLoja._id,\n        email: newLoja.email,\n        plan: newLoja.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar Loja:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/registration/marketplace - Cadastrar no Marketplace\nrouter.post('/marketplace', registrationLimiter, async (req, res) => {\n  try {\n    const { name, email, phone, cpf, companyName, cnpj, ie, address, offerings, plan, isPublic } =\n      req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await Marketplace.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await Marketplace.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCNPJ = await Marketplace.findOne({ cnpj });\n    if (existingCNPJ) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newMarketplace = new Marketplace({\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      offerings,\n      plan,\n      isPublic\n    });\n\n    await newMarketplace.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newMarketplace._id,\n        email: newMarketplace.email,\n        plan: newMarketplace.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar Marketplace:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/registration/fazenda - Cadastrar Fazenda\nrouter.post('/fazenda', registrationLimiter, async (req, res) => {\n  try {\n    const {\n      name,\n      email,\n      phone,\n      cpf,\n      farmName,\n      farmSize,\n      farmType,\n      address,\n      products,\n      plan,\n      isPublic\n    } = req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await Fazenda.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await Fazenda.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newFazenda = new Fazenda({\n      name,\n      email,\n      phone,\n      cpf,\n      farmName,\n      farmSize,\n      farmType,\n      address,\n      products,\n      plan,\n      isPublic\n    });\n\n    await newFazenda.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newFazenda._id,\n        email: newFazenda.email,\n        plan: newFazenda.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar Fazenda:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/agroconecta/public - Listar cadastros pÃºblicos do AgroConecta\nrouter.get('/agroconecta/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, vehicleType } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n    if (vehicleType) {\n      filter['vehicle.type'] = vehicleType;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [agroconectas, total] = await Promise.all([\n      AgroConecta.find(filter)\n        .select('name companyName address vehicle services stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10))\n        .sort({ createdAt: -1 }),\n      AgroConecta.countDocuments(filter)\n    ]);\n\n    res.json({\n      success: true,\n      data: agroconectas,\n      pagination: {\n        page: parseInt(page, 10),\n        limit: parseInt(limit, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar AgroConecta:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/loja/public - Listar cadastros pÃºblicos da Loja\nrouter.get('/loja/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, category } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [lojas, total] = await Promise.all([\n      Loja.find(filter)\n        .select('name companyName address products stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10))\n        .sort({ createdAt: -1 }),\n      Loja.countDocuments(filter)\n    ]);\n\n    // Filtrar produtos por categoria se especificado\n    if (category) {\n      lojas.forEach(loja => {\n        loja.products = loja.products.filter(product =>\n          product.category.toLowerCase().includes(category.toLowerCase())\n        );\n      });\n    }\n\n    res.json({\n      success: true,\n      data: lojas,\n      pagination: {\n        page: parseInt(page, 10),\n        limit: parseInt(limit, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar Lojas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/marketplace/public - Listar cadastros pÃºblicos do Marketplace\nrouter.get('/marketplace/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, type } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [marketplaces, total] = await Promise.all([\n      Marketplace.find(filter)\n        .select('name companyName address offerings stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10))\n        .sort({ createdAt: -1 }),\n      Marketplace.countDocuments(filter)\n    ]);\n\n    // Filtrar ofertas por tipo se especificado\n    if (type) {\n      marketplaces.forEach(marketplace => {\n        marketplace.offerings = marketplace.offerings.filter(offering => offering.type === type);\n      });\n    }\n\n    res.json({\n      success: true,\n      data: marketplaces,\n      pagination: {\n        page: parseInt(page, 10),\n        limit: parseInt(limit, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar Marketplaces:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/fazenda/public - Listar cadastros pÃºblicos de Fazendas\nrouter.get('/fazenda/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, farmType } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n    if (farmType) {\n      filter.farmType = farmType;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [fazendas, total] = await Promise.all([\n      Fazenda.find(filter)\n        .select('name farmName farmSize farmType address products stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10))\n        .sort({ createdAt: -1 }),\n      Fazenda.countDocuments(filter)\n    ]);\n\n    res.json({\n      success: true,\n      data: fazendas,\n      pagination: {\n        page: parseInt(page, 10),\n        limit: parseInt(limit, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar Fazendas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\nmodule.exports = router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\secureURLs.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":36,"column":62,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":36,"endColumn":64},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":97,"column":60,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":97,"endColumn":62},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":149,"column":47,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":149,"endColumn":49},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":192,"column":59,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":192,"endColumn":61},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":254,"column":20,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":254,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿import express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport secureURLService from '../services/secureURLService.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/secure-urls/generate:\n *   post:\n *     summary: Gerar URL segura para cadastro\n *     tags: [Secure URLs]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               type:\n *                 type: string\n *                 enum: [signup-store, signup-freight, signup-product]\n *               metadata:\n *                 type: object\n *                 description: Dados adicionais para o cadastro\n *     responses:\n *       200:\n *         description: URL segura gerada com sucesso\n *       401:\n *         description: NÃ£o autorizado\n */\nrouter.post('/generate', authenticateToken, async (req, res) => {\n  try {\n    const { type, metadata = {} } = req.body;\n\n    if (!type || !['signup-store', 'signup-freight', 'signup-product'].includes(type)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipo de cadastro invÃ¡lido'\n      });\n    }\n\n    const secureURL = secureURLService.generateSecureURL(type, {\n      ...metadata,\n      generatedBy: req.user.userId,\n      generatedAt: new Date().toISOString()\n    });\n\n    logger.info(`URL segura gerada por ${req.user.email} para ${type}`);\n\n    res.status(200).json({\n      success: true,\n      message: 'URL segura gerada com sucesso',\n      data: {\n        url: secureURL,\n        type,\n        expiresIn: '24h'\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar URL segura:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/secure-urls/invite:\n *   post:\n *     summary: Gerar URL de convite\n *     tags: [Secure URLs]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               type:\n *                 type: string\n *                 enum: [signup-store, signup-freight, signup-product]\n *     responses:\n *       200:\n *         description: URL de convite gerada com sucesso\n *       401:\n *         description: NÃ£o autorizado\n */\nrouter.post('/invite', authenticateToken, async (req, res) => {\n  try {\n    const { type } = req.body;\n\n    if (!type || !['signup-store', 'signup-freight', 'signup-product'].includes(type)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipo de cadastro invÃ¡lido'\n      });\n    }\n\n    const inviteURL = secureURLService.generateInviteURL(req.user.userId, type);\n\n    logger.info(`URL de convite gerada por ${req.user.email} para ${type}`);\n\n    res.status(200).json({\n      success: true,\n      message: 'URL de convite gerada com sucesso',\n      data: {\n        url: inviteURL,\n        type,\n        expiresIn: '7d'\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar URL de convite:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/secure-urls/verify/{token}:\n *   get:\n *     summary: Verificar token de URL segura\n *     tags: [Secure URLs]\n *     parameters:\n *       - in: path\n *         name: token\n *         required: true\n *         schema:\n *           type: string\n *         description: Token da URL segura\n *     responses:\n *       200:\n *         description: Token vÃ¡lido\n *       400:\n *         description: Token invÃ¡lido ou expirado\n */\nrouter.get('/verify/:token', async (req, res) => {\n  try {\n    const { token } = req.params;\n\n    const decoded = secureURLService.verifySecureToken(token);\n\n    res.status(200).json({\n      success: true,\n      message: 'Token vÃ¡lido',\n      data: {\n        type: decoded.type,\n        metadata: decoded.metadata,\n        expiresAt: new Date(decoded.exp * 1000).toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar token:', error);\n    res.status(400).json({\n      success: false,\n      message: 'Token invÃ¡lido ou expirado'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/secure-urls/verify-invite/{inviteCode}:\n *   get:\n *     summary: Verificar cÃ³digo de convite\n *     tags: [Secure URLs]\n *     parameters:\n *       - in: path\n *         name: inviteCode\n *         required: true\n *         schema:\n *           type: string\n *         description: CÃ³digo de convite\n *     responses:\n *       200:\n *         description: CÃ³digo de convite vÃ¡lido\n *       400:\n *         description: CÃ³digo de convite invÃ¡lido ou expirado\n */\nrouter.get('/verify-invite/:inviteCode', async (req, res) => {\n  try {\n    const { inviteCode } = req.params;\n\n    const decoded = secureURLService.verifyInviteCode(inviteCode);\n\n    res.status(200).json({\n      success: true,\n      message: 'CÃ³digo de convite vÃ¡lido',\n      data: {\n        referrerId: decoded.referrerId,\n        type: decoded.type,\n        expiresAt: new Date(decoded.exp * 1000).toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar cÃ³digo de convite:', error);\n    res.status(400).json({\n      success: false,\n      message: 'CÃ³digo de convite invÃ¡lido ou expirado'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/secure-urls/validate:\n *   post:\n *     summary: Valida uma URL segura e extrai os dados\n *     tags: [Secure URLs]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - token\n *             properties:\n *               token:\n *                 type: string\n *                 description: Token da URL segura\n *                 example: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n *     responses:\n *       200:\n *         description: URL segura validada com sucesso\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success: { type: boolean, example: true }\n *                 message: { type: string, example: \"URL segura validada com sucesso\" }\n *                 data: { type: object, description: \"Dados extraÃ­dos da URL\" }\n *       400:\n *         description: Token invÃ¡lido ou expirado\n *       500:\n *         description: Erro interno do servidor\n */\nrouter.post(\n  '/validate',\n  [body('token').isString().withMessage('Token Ã© obrigatÃ³rio')],\n  async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res\n        .status(400)\n        .json({ success: false, message: 'Token invÃ¡lido', errors: errors.array() });\n    }\n\n    const { token } = req.body;\n\n    try {\n      const data = secureURLService.validateSecureURL(\n        `${process.env.FRONTEND_URL}/signup/${token}`\n      );\n      logger.info(`URL segura validada: ${token.substring(0, 20)}...`);\n      res.status(200).json({ success: true, message: 'URL segura validada com sucesso', data });\n    } catch (error) {\n      logger.error('Erro ao validar URL segura:', error);\n      res.status(400).json({ success: false, message: 'Token invÃ¡lido ou expirado.' });\n    }\n  }\n);\n\nexport default router;\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\staking.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\swagger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\userDashboard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\apiFallbackService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\emailService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\swagger\\swagger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\cors.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\d1-helper.js","messages":[{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":141,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":141,"endColumn":52},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":149,"column":48,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":149,"endColumn":50},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":157,"column":55,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":157,"endColumn":57},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":182,"column":69,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":182,"endColumn":71},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":244,"column":54,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":244,"endColumn":56},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":320,"column":54,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":320,"endColumn":56},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":347,"column":54,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":347,"endColumn":56},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":372,"column":68,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":372,"endColumn":70},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":386,"column":62,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":386,"endColumn":64},{"ruleId":"require-await","severity":1,"message":"Async arrow function has no 'await' expression.","line":412,"column":51,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":412,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"﻿// ===== D1 DATABASE HELPER =====\n// UtilitÃ¡rios para trabalhar com Cloudflare D1 Database\n// Substitui MongoDB com queries SQL otimizadas\n\nimport { v4 as uuidv4 } from 'uuid';\nimport bcrypt from 'bcryptjs';\n\n/**\n * Gerar ID Ãºnico para registros\n */\nexport const generateId = (prefix = '') => {\n  const id = uuidv4();\n  return prefix ? `${prefix}-${id}` : id;\n};\n\n/**\n * Timestamp Unix atual\n */\nexport const now = () => Math.floor(Date.now() / 1000);\n\n/**\n * Executar query D1 com tratamento de erro\n */\nexport const executeD1Query = async (db, query, params = []) => {\n  try {\n    const result = await db\n      .prepare(query)\n      .bind(...params)\n      .all();\n    return {\n      success: true,\n      results: result.results || [],\n      meta: result.meta || {}\n    };\n  } catch (error) {\n    const logger = require('./logger');\n    logger.error('D1 Query Error:', error);\n    return {\n      success: false,\n      error: error.message,\n      results: []\n    };\n  }\n};\n\n/**\n * Executar query e retornar primeiro resultado\n */\nexport const executeD1QueryFirst = async (db, query, params = []) => {\n  try {\n    const result = await db\n      .prepare(query)\n      .bind(...params)\n      .first();\n    return {\n      success: true,\n      result: result || null\n    };\n  } catch (error) {\n    const logger = require('./logger');\n    logger.error('D1 Query Error:', error);\n    return {\n      success: false,\n      error: error.message,\n      result: null\n    };\n  }\n};\n\n/**\n * Executar query de escrita (INSERT, UPDATE, DELETE)\n */\nexport const executeD1Write = async (db, query, params = []) => {\n  try {\n    const result = await db\n      .prepare(query)\n      .bind(...params)\n      .run();\n    return {\n      success: true,\n      meta: result.meta || {},\n      changes: result.meta?.changes || 0\n    };\n  } catch (error) {\n    const logger = require('./logger');\n    logger.error('D1 Write Error:', error);\n    return {\n      success: false,\n      error: error.message,\n      changes: 0\n    };\n  }\n};\n\n/**\n * Criar usuÃ¡rio no D1\n */\nexport const createUser = async (db, userData) => {\n  const { email, name, password, phone = null, businessType = 'user', role = 'user' } = userData;\n\n  const id = generateId('user');\n  const hashedPassword = await bcrypt.hash(password, 12);\n  const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();\n  const codeExpires = now() + 600; // 10 minutos\n\n  const query = `\n    INSERT INTO users (\n      id, email, name, password, phone, businessType, role,\n      verificationCode, codeExpires, createdAt, updatedAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  const result = await executeD1Write(db, query, [\n    id,\n    email.toLowerCase(),\n    name,\n    hashedPassword,\n    phone,\n    businessType,\n    role,\n    verificationCode,\n    codeExpires,\n    now(),\n    now()\n  ]);\n\n  if (result.success) {\n    return {\n      success: true,\n      userId: id,\n      verificationCode\n    };\n  }\n\n  return result;\n};\n\n/**\n * Buscar usuÃ¡rio por email\n */\nexport const findUserByEmail = async (db, email) => {\n  const query = 'SELECT * FROM users WHERE email = ? LIMIT 1';\n  return executeD1QueryFirst(db, query, [email.toLowerCase()]);\n};\n\n/**\n * Buscar usuÃ¡rio por ID\n */\nexport const findUserById = async (db, userId) => {\n  const query = 'SELECT * FROM users WHERE id = ? LIMIT 1';\n  return executeD1QueryFirst(db, query, [userId]);\n};\n\n/**\n * Atualizar usuÃ¡rio\n */\nexport const updateUser = async (db, userId, updates) => {\n  const fields = [];\n  const values = [];\n\n  Object.keys(updates).forEach(key => {\n    if (updates[key] !== undefined) {\n      fields.push(`${key} = ?`);\n      values.push(updates[key]);\n    }\n  });\n\n  // Adicionar updatedAt\n  fields.push('updatedAt = ?');\n  values.push(now());\n\n  // Adicionar userId no final\n  values.push(userId);\n\n  const query = `UPDATE users SET ${fields.join(', ')} WHERE id = ?`;\n  return executeD1Write(db, query, values);\n};\n\n/**\n * Verificar senha\n */\nexport const verifyPassword = async (plainPassword, hashedPassword) => {\n  return bcrypt.compare(plainPassword, hashedPassword);\n};\n\n/**\n * Criar produto\n */\nexport const createProduct = async (db, userId, productData) => {\n  const {\n    title,\n    description = '',\n    category,\n    price,\n    stock = 0,\n    images = [],\n    city = '',\n    state = ''\n  } = productData;\n\n  const id = generateId('prod');\n  const slug = title\n    .toLowerCase()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/\\s+/g, '-');\n\n  const query = `\n    INSERT INTO products (\n      id, userId, title, description, category, price, stock,\n      images, city, state, slug, status, createdAt, updatedAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  const result = await executeD1Write(db, query, [\n    id,\n    userId,\n    title,\n    description,\n    category,\n    price,\n    stock,\n    JSON.stringify(images),\n    city,\n    state,\n    slug,\n    'active',\n    now(),\n    now()\n  ]);\n\n  if (result.success) {\n    return {\n      success: true,\n      productId: id\n    };\n  }\n\n  return result;\n};\n\n/**\n * Buscar produtos com filtros\n */\nexport const findProducts = async (db, filters = {}) => {\n  let query = \"SELECT * FROM products WHERE status = 'active'\";\n  const params = [];\n\n  if (filters.category) {\n    query += ' AND category = ?';\n    params.push(filters.category);\n  }\n\n  if (filters.state) {\n    query += ' AND state = ?';\n    params.push(filters.state);\n  }\n\n  if (filters.search) {\n    query += ' AND (title LIKE ? OR description LIKE ?)';\n    const searchTerm = `%${filters.search}%`;\n    params.push(searchTerm, searchTerm);\n  }\n\n  query += ' ORDER BY createdAt DESC';\n\n  if (filters.limit) {\n    query += ' LIMIT ?';\n    params.push(parseInt(filters.limit, 10));\n  }\n\n  return executeD1Query(db, query, params);\n};\n\n/**\n * Criar frete\n */\nexport const createFreight = async (db, userId, freightData) => {\n  const { originCity, originState, destinationCity, destinationState, loadType, price } =\n    freightData;\n\n  const id = generateId('freight');\n  const trackingCode = `AGR${Date.now().toString(36).toUpperCase()}`;\n\n  const query = `\n    INSERT INTO freights (\n      id, userId, originCity, originState, destinationCity, destinationState,\n      loadType, price, trackingCode, status, createdAt, updatedAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  const result = await executeD1Write(db, query, [\n    id,\n    userId,\n    originCity,\n    originState,\n    destinationCity,\n    destinationState,\n    loadType,\n    price,\n    trackingCode,\n    'available',\n    now(),\n    now()\n  ]);\n\n  if (result.success) {\n    return {\n      success: true,\n      freightId: id,\n      trackingCode\n    };\n  }\n\n  return result;\n};\n\n/**\n * Buscar fretes\n */\nexport const findFreights = async (db, filters = {}) => {\n  let query = \"SELECT * FROM freights WHERE status = 'available'\";\n  const params = [];\n\n  if (filters.originState) {\n    query += ' AND originState = ?';\n    params.push(filters.originState);\n  }\n\n  if (filters.destinationState) {\n    query += ' AND destinationState = ?';\n    params.push(filters.destinationState);\n  }\n\n  query += ' ORDER BY createdAt DESC';\n\n  if (filters.limit) {\n    query += ' LIMIT ?';\n    params.push(parseInt(filters.limit, 10));\n  }\n\n  return executeD1Query(db, query, params);\n};\n\n/**\n * Criar mensagem\n */\nexport const createMessage = async (db, messageData) => {\n  const { conversationId, senderId, receiverId, content, type = 'text' } = messageData;\n\n  const id = generateId('msg');\n\n  const query = `\n    INSERT INTO messages (\n      id, conversationId, senderId, receiverId, content, type, createdAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  return executeD1Write(db, query, [\n    id,\n    conversationId,\n    senderId,\n    receiverId,\n    content,\n    type,\n    now()\n  ]);\n};\n\n/**\n * Buscar mensagens de uma conversa\n */\nexport const findMessages = async (db, conversationId, limit = 50) => {\n  const query = `\n    SELECT * FROM messages \n    WHERE conversationId = ? AND isDeleted = 0\n    ORDER BY createdAt DESC\n    LIMIT ?\n  `;\n\n  return executeD1Query(db, query, [conversationId, limit]);\n};\n\n/**\n * Criar transaÃ§Ã£o\n */\nexport const createTransaction = async (db, transactionData) => {\n  const { userId, type, amount, paymentMethod, description } = transactionData;\n\n  const id = generateId('txn');\n\n  const query = `\n    INSERT INTO transactions (\n      id, userId, type, amount, paymentMethod, paymentStatus, description, createdAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  return executeD1Write(db, query, [\n    id,\n    userId,\n    type,\n    amount,\n    paymentMethod,\n    'pending',\n    description,\n    now()\n  ]);\n};\n\n/**\n * Criar log de auditoria\n */\nexport const createAuditLog = async (db, logData) => {\n  const { userId, action, entity, entityId, ipAddress, userAgent } = logData;\n\n  const id = generateId('log');\n\n  const query = `\n    INSERT INTO audit_logs (\n      id, userId, action, entity, entityId, ipAddress, userAgent, createdAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  return executeD1Write(db, query, [\n    id,\n    userId,\n    action,\n    entity,\n    entityId,\n    ipAddress,\n    userAgent,\n    now()\n  ]);\n};\n\n/**\n * Sanitizar dados para JSON\n */\nexport const sanitizeForJSON = data => {\n  if (!data) {\n    return null;\n  }\n\n  const sanitized = { ...data };\n\n  // Converter integers para boolean\n  ['isAdmin', 'isActive', 'isBlocked', 'isEmailVerified', 'isPaid', 'twoFactorEnabled'].forEach(\n    field => {\n      if (field in sanitized) {\n        sanitized[field] = Boolean(sanitized[field]);\n      }\n    }\n  );\n\n  // Parsear JSON strings\n  ['images', 'tags', 'certifications', 'dimensions'].forEach(field => {\n    if (sanitized[field] && typeof sanitized[field] === 'string') {\n      try {\n        sanitized[field] = JSON.parse(sanitized[field]);\n      } catch (e) {\n        // Manter como string se nÃ£o for JSON vÃ¡lido\n      }\n    }\n  });\n\n  // Remover senha\n  delete sanitized.password;\n  delete sanitized.twoFactorSecret;\n\n  return sanitized;\n};\n\nexport default {\n  generateId,\n  now,\n  executeD1Query,\n  executeD1QueryFirst,\n  executeD1Write,\n  createUser,\n  findUserByEmail,\n  findUserById,\n  updateUser,\n  verifyPassword,\n  createProduct,\n  findProducts,\n  createFreight,\n  findFreights,\n  createMessage,\n  findMessages,\n  createTransaction,\n  createAuditLog,\n  sanitizeForJSON\n};\n","usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\sanitizer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]},{"filePath":"C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\verifyTurnstile.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"callback-return","replacedBy":[]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]}]}]
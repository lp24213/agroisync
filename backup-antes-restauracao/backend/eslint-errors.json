[
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\__tests__\\csrf.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\__tests__\\health.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\cloudflare-worker.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\auth.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'config' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 3,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 16
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 25,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 25,
        "endColumn": 42
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 128,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 128,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 155,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 155,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 185,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 185,
        "endColumn": 13
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 215,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 215,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { config } from './config.js';\n\nimport logger from '../utils/logger.js';\n// ===== CONFIGURAÃ‡ÃƒO JWT =====\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN || '7d';\n\n// ===== FUNÃ‡Ã•ES DE AUTENTICAÃ‡ÃƒO =====\n\n// Gerar token JWT\nexport const generateToken = payload => {\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n};\n\n// Gerar refresh token\nexport const generateRefreshToken = payload => {\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: REFRESH_TOKEN_EXPIRES_IN });\n};\n\n// Verificar token JWT\nexport const verifyToken = async token => {\n  try {\n    const payload = jwt.verify(token, JWT_SECRET);\n    return {\n      valid: true,\n      payload,\n      userId: payload.userId,\n      email: payload.email,\n      userType: payload.userType || 'buyer',\n      groups: payload.groups || []\n    };\n  } catch (error) {\n    // Console log removido (dados sensÃ­veis)\n    return {\n      valid: false,\n      error: error.message\n    };\n  }\n};\n\n// Hash de senha\nexport const hashPassword = async password => {\n  const saltRounds = 12;\n  return await bcrypt.hash(password, saltRounds);\n};\n\n// Verificar senha\nexport const verifyPassword = async (password, hashedPassword) => {\n  return await bcrypt.compare(password, hashedPassword);\n};\n\n// Verificar se usuÃ¡rio Ã© admin\nexport const isAdmin = groups => {\n  return groups && groups.includes('admin');\n};\n\n// Verificar se usuÃ¡rio tem plano ativo\nexport const hasActivePlan = (user, module) => {\n  if (!user || !user.subscriptions) {\n    return false;\n  }\n\n  const subscription = user.subscriptions[module];\n  if (!subscription) {\n    return false;\n  }\n\n  return (\n    subscription.status === 'active' &&\n    subscription.endDate &&\n    new Date(subscription.endDate) > new Date()\n  );\n};\n\n// Verificar permissÃµes para mensagens privadas\nexport const canAccessPrivateMessages = user => {\n  // UsuÃ¡rios com plano ativo podem acessar mensagens privadas\n  return hasActivePlan(user, 'store') || hasActivePlan(user, 'freight');\n};\n\n// Verificar permissÃµes para criar anÃºncios\nexport const canCreateAds = user => {\n  return (\n    hasActivePlan(user, 'store') &&\n    user.subscriptions.store.currentAds < user.subscriptions.store.maxAds\n  );\n};\n\n// Verificar permissÃµes para criar fretes\nexport const canCreateFreights = user => {\n  return (\n    hasActivePlan(user, 'freight') &&\n    user.subscriptions.freight.currentFreights < user.subscriptions.freight.maxFreights\n  );\n};\n\n// ===== MIDDLEWARE DE AUTENTICAÃ‡ÃƒO =====\n\nexport const authenticateToken = async (req, res, next) => {\n  try {\n    const authHeader = req.headers.authorization;\n\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token de autenticaÃ§Ã£o nÃ£o fornecido'\n      });\n    }\n\n    const token = authHeader.substring(7);\n    const verification = await verifyToken(token);\n\n    if (!verification.valid) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token invÃ¡lido ou expirado'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes do usuÃ¡rio ao request\n    req.user = verification;\n    req.userId = verification.userId;\n\n    next();\n  } catch (error) {\n    // Console log removido (dados sensÃ­veis)\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno de autenticaÃ§Ã£o'\n    });\n  }\n};\n\n// Middleware para verificar se usuÃ¡rio Ã© admin\nexport const requireAdmin = (req, res, next) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'AutenticaÃ§Ã£o necessÃ¡ria'\n      });\n    }\n\n    if (!isAdmin(req.user.groups)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado: apenas administradores'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error in admin verification:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno de verificaÃ§Ã£o'\n    });\n  }\n};\n\n// Middleware para verificar plano ativo\nexport const requireActivePlan = module => {\n  return (req, res, next) => {\n    try {\n      if (!req.user) {\n        return res.status(401).json({\n          success: false,\n          message: 'AutenticaÃ§Ã£o necessÃ¡ria'\n        });\n      }\n\n      if (!hasActivePlan(req.user, module)) {\n        return res.status(403).json({\n          success: false,\n          message: `Plano ${module} ativo necessÃ¡rio para esta funcionalidade`\n        });\n      }\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Error in plan verification:', error);\n      }\n      return res.status(500).json({\n        success: false,\n        message: 'Erro interno de verificaÃ§Ã£o'\n      });\n    }\n  };\n};\n\n// Middleware para verificar acesso a mensagens privadas\nexport const requireMessageAccess = (req, res, next) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'AutenticaÃ§Ã£o necessÃ¡ria'\n      });\n    }\n\n    if (!canAccessPrivateMessages(req.user)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano ativo necessÃ¡rio para acessar mensagens privadas'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error in message access verification:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno de verificaÃ§Ã£o'\n    });\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE UTILIDADE =====\n\n// Gerar cÃ³digo de verificaÃ§Ã£o\nexport const generateVerificationCode = (length = 6) => {\n  const digits = '0123456789';\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += digits.charAt(Math.floor(Math.random() * digits.length));\n  }\n  return result;\n};\n\n// Gerar token de reset de senha\nexport const generatePasswordResetToken = userId => {\n  const payload = {\n    userId,\n    type: 'password_reset',\n    timestamp: Date.now()\n  };\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: '15m' });\n};\n\n// Verificar token de reset de senha\nexport const verifyPasswordResetToken = token => {\n  try {\n    const payload = jwt.verify(token, JWT_SECRET);\n    if (payload.type !== 'password_reset') {\n      throw new Error('Invalid token type');\n    }\n    return {\n      valid: true,\n      userId: payload.userId,\n      timestamp: payload.timestamp\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error.message\n    };\n  }\n};\n\n// Gerar token de verificaÃ§Ã£o de email\nexport const generateEmailVerificationToken = (userId, email) => {\n  const payload = {\n    userId,\n    email,\n    type: 'email_verification',\n    timestamp: Date.now()\n  };\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: '24h' });\n};\n\n// Verificar token de verificaÃ§Ã£o de email\nexport const verifyEmailVerificationToken = token => {\n  try {\n    const payload = jwt.verify(token, JWT_SECRET);\n    if (payload.type !== 'email_verification') {\n      throw new Error('Invalid token type');\n    }\n    return {\n      valid: true,\n      userId: payload.userId,\n      email: payload.email,\n      timestamp: payload.timestamp\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      error: error.message\n    };\n  }\n};\n\nexport default {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  hashPassword,\n  verifyPassword,\n  isAdmin,\n  hasActivePlan,\n  canAccessPrivateMessages,\n  canCreateAds,\n  canCreateFreights,\n  authenticateToken,\n  requireAdmin,\n  requireActivePlan,\n  requireMessageAccess,\n  generateVerificationCode,\n  generatePasswordResetToken,\n  verifyPasswordResetToken,\n  generateEmailVerificationToken,\n  verifyEmailVerificationToken\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\constants.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\devConfig.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\environment.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\metamask.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'createSecurityLog' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 2,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 27
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Parsing error: 'await' is only allowed within async functions and at the top levels of modules.",
        "line": 266,
        "column": 27,
        "nodeType": null
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'transactions' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 269,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 269,
        "endColumn": 23
      },
      {
        "ruleId": "no-useless-catch",
        "severity": 2,
        "message": "Unnecessary try/catch wrapper.",
        "line": 333,
        "column": 3,
        "nodeType": "TryStatement",
        "messageId": "unnecessaryCatch",
        "endLine": 360,
        "endColumn": 4
      },
      {
        "ruleId": "no-useless-catch",
        "severity": 2,
        "message": "Unnecessary try/catch wrapper.",
        "line": 365,
        "column": 3,
        "nodeType": "TryStatement",
        "messageId": "unnecessaryCatch",
        "endLine": 391,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import { ethers } from 'ethers';\nimport { createSecurityLog } from '../utils/securityLogger.js';\n\nimport logger from '../utils/logger.js';\n// ===== CONFIGURAÃ‡ÃƒO DO METAMASK =====\n\n// EndereÃ§os das redes suportadas\nexport const SUPPORTED_NETWORKS = {\n  ethereum: {\n    chainId: 1,\n    name: 'Ethereum Mainnet',\n    rpcUrl: process.env.ETHEREUM_RPC_URL || 'https://mainnet.infura.io/v3/your-project-id',\n    explorer: 'https://etherscan.io',\n    nativeCurrency: {\n      name: 'Ether',\n      symbol: 'ETH',\n      decimals: 18\n    }\n  },\n  polygon: {\n    chainId: 137,\n    name: 'Polygon Mainnet',\n    rpcUrl: process.env.POLYGON_RPC_URL || 'https://polygon-rpc.com',\n    explorer: 'https://polygonscan.com',\n    nativeCurrency: {\n      name: 'MATIC',\n      symbol: 'MATIC',\n      decimals: 18\n    }\n  },\n  binance: {\n    chainId: 56,\n    name: 'Binance Smart Chain',\n    rpcUrl: process.env.BSC_RPC_URL || 'https://bsc-dataseed.binance.org',\n    explorer: 'https://bscscan.com',\n    nativeCurrency: {\n      name: 'BNB',\n      symbol: 'BNB',\n      decimals: 18\n    }\n  },\n  arbitrum: {\n    chainId: 42161,\n    name: 'Arbitrum One',\n    rpcUrl: process.env.ARBITRUM_RPC_URL || 'https://arb1.arbitrum.io/rpc',\n    explorer: 'https://arbiscan.io',\n    nativeCurrency: {\n      name: 'Ether',\n      symbol: 'ETH',\n      decimals: 18\n    }\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE VALIDAÃ‡ÃƒO =====\n\n// Validar endereÃ§o Ethereum\nexport const isValidEthereumAddress = address => {\n  try {\n    return ethers.isAddress(address);\n  } catch (error) {\n    return false;\n  }\n};\n\n// Validar assinatura\nexport const isValidSignature = (message, signature, address) => {\n  try {\n    const recoveredAddress = ethers.verifyMessage(message, signature);\n    return recoveredAddress.toLowerCase() === address.toLowerCase();\n  } catch (error) {\n    return false;\n  }\n};\n\n// Validar hash de transaÃ§Ã£o\nexport const isValidTransactionHash = hash => {\n  try {\n    return ethers.isHexString(hash, 32);\n  } catch (error) {\n    return false;\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE AUTENTICAÃ‡ÃƒO =====\n\n// Gerar mensagem para assinatura\nexport const generateAuthMessage = (address, nonce) => {\n  const timestamp = Date.now();\n  const message = `AGROTM Authentication\\n\\nAddress: ${address}\\nNonce: ${nonce}\\nTimestamp: ${timestamp}\\n\\nPlease sign this message to authenticate with AGROTM.`;\n\n  return {\n    message,\n    timestamp,\n    nonce\n  };\n};\n\n// Verificar autenticaÃ§Ã£o Metamask\nexport const verifyMetamaskAuth = (address, signature, nonce, timestamp) => {\n  try {\n    // Verificar se o timestamp nÃ£o Ã© muito antigo (5 minutos)\n    const now = Date.now();\n    if (now - timestamp > 5 * 60 * 1000) {\n      return {\n        valid: false,\n        error: 'Timestamp expired'\n      };\n    }\n\n    // Verificar se o endereÃ§o Ã© vÃ¡lido\n    if (!isValidEthereumAddress(address)) {\n      return {\n        valid: false,\n        error: 'Invalid Ethereum address'\n      };\n    }\n\n    // Verificar se a assinatura Ã© vÃ¡lida\n    const authMessage = generateAuthMessage(address, nonce);\n    if (!isValidSignature(authMessage.message, signature, address)) {\n      return {\n        valid: false,\n        error: 'Invalid signature'\n      };\n    }\n\n    return {\n      valid: true,\n      address: address.toLowerCase()\n    };\n  } catch (error) {\n    // Console log removido (dados sensÃ­veis)\n    return {\n      valid: false,\n      error: 'Verification failed'\n    };\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE PAGAMENTO =====\n\n// Criar transaÃ§Ã£o de pagamento\nexport const createPaymentTransaction = async (\n  fromAddress,\n  toAddress,\n  amount,\n  network = 'ethereum'\n) => {\n  try {\n    const networkConfig = SUPPORTED_NETWORKS[network];\n    if (!networkConfig) {\n      throw new Error('Unsupported network');\n    }\n\n    // Conectar ao provedor\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);\n\n    // Obter nonce atual\n    const nonce = await provider.getTransactionCount(fromAddress);\n\n    // Obter preÃ§o do gas\n    const gasPrice = await provider.getFeeData();\n\n    // Criar transaÃ§Ã£o\n    const transaction = {\n      to: toAddress,\n      value: ethers.parseEther(amount.toString()),\n      nonce,\n      gasLimit: 21000, // Gas limit padrÃ£o para transferÃªncias\n      gasPrice: gasPrice.gasPrice\n    };\n\n    return {\n      transaction,\n      network: networkConfig,\n      estimatedGas: transaction.gasLimit * Number(transaction.gasPrice)\n    };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating payment transaction:', error);\n    }\n    throw error;\n  }\n};\n\n// Verificar status da transaÃ§Ã£o\nexport const checkTransactionStatus = async (txHash, network = 'ethereum') => {\n  try {\n    const networkConfig = SUPPORTED_NETWORKS[network];\n    if (!networkConfig) {\n      throw new Error('Unsupported network');\n    }\n\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);\n\n    // Obter receita da transaÃ§Ã£o\n    const receipt = await provider.getTransactionReceipt(txHash);\n\n    if (!receipt) {\n      return {\n        status: 'pending',\n        confirmations: 0,\n        blockNumber: null\n      };\n    }\n\n    // Obter bloco atual\n    const currentBlock = await provider.getBlockNumber();\n    const confirmations = currentBlock - receipt.blockNumber;\n\n    return {\n      status: receipt.status === 1 ? 'confirmed' : 'failed',\n      confirmations,\n      blockNumber: receipt.blockNumber,\n      gasUsed: receipt.gasUsed.toString(),\n      effectiveGasPrice: receipt.effectiveGasPrice.toString()\n    };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error checking transaction status:', error);\n    }\n    throw error;\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE CARTEIRA =====\n\n// Obter saldo da carteira\nexport const getWalletBalance = async (address, network = 'ethereum') => {\n  try {\n    const networkConfig = SUPPORTED_NETWORKS[network];\n    if (!networkConfig) {\n      throw new Error('Unsupported network');\n    }\n\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);\n    const balance = await provider.getBalance(address);\n\n    return {\n      address,\n      network: networkConfig.name,\n      balance: ethers.formatEther(balance),\n      balanceWei: balance.toString(),\n      currency: networkConfig.nativeCurrency.symbol\n    };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error getting wallet balance:', error);\n    }\n    throw error;\n  }\n};\n\n// Obter histÃ³rico de transaÃ§Ãµes\nexport const getTransactionHistory = (address, network = 'ethereum', limit = 50) => {\n  try {\n    const networkConfig = SUPPORTED_NETWORKS[network];\n    if (!networkConfig) {\n      throw new Error('Unsupported network');\n    }\n\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);\n\n    // Obter bloco atual\n    const currentBlock = await provider.getBlockNumber();\n\n    // Buscar transaÃ§Ãµes (limitado pela API)\n    const transactions = [];\n\n    // Buscar transaÃ§Ãµes de entrada\n    const incomingTxs = await provider.getLogs({\n      address,\n      fromBlock: currentBlock - 10000, // Ãšltimos 10k blocos\n      toBlock: currentBlock,\n      topics: [\n        null, // Qualquer evento\n        `0x000000000000000000000000${address.slice(2)}` // Para endereÃ§o\n      ]\n    });\n\n    // Buscar transaÃ§Ãµes de saÃ­da\n    const outgoingTxs = await provider.getLogs({\n      address,\n      fromBlock: currentBlock - 10000,\n      toBlock: currentBlock,\n      topics: [\n        null,\n        address.slice(2).padStart(64, '0') // De endereÃ§o\n      ]\n    });\n\n    // Combinar e ordenar transaÃ§Ãµes\n    const allTxs = [...incomingTxs, ...outgoingTxs];\n    allTxs.sort((a, b) => b.blockNumber - a.blockNumber);\n\n    // Limitar resultados\n    return allTxs.slice(0, limit).map(tx => ({\n      hash: tx.transactionHash,\n      blockNumber: tx.blockNumber,\n      from: tx.address,\n      to: tx.topics[1] ? `0x${tx.topics[1].slice(26)}` : null,\n      value: ethers.formatEther(tx.data || '0'),\n      timestamp: Date.now() // Seria melhor obter do bloco\n    }));\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error getting transaction history:', error);\n    }\n    throw error;\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE TOKEN =====\n\n// ABI bÃ¡sico para tokens ERC-20\nconst ERC20_ABI = [\n  'function name() view returns (string)',\n  'function symbol() view returns (string)',\n  'function decimals() view returns (uint8)',\n  'function totalSupply() view returns (uint256)',\n  'function balanceOf(address) view returns (uint256)',\n  'function transfer(address to, uint256 amount) returns (bool)',\n  'function allowance(address owner, address spender) view returns (uint256)',\n  'function approve(address spender, uint256 amount) returns (bool)',\n  'function transferFrom(address from, address to, uint256 amount) returns (bool)',\n  'event Transfer(address indexed from, address indexed to, uint256 value)',\n  'event Approval(address indexed owner, address indexed spender, uint256 value)'\n];\n\n// Obter informaÃ§Ãµes do token\nexport const getTokenInfo = async (tokenAddress, network = 'ethereum') => {\n  try {\n    const networkConfig = SUPPORTED_NETWORKS[network];\n    if (!networkConfig) {\n      throw new Error('Unsupported network');\n    }\n\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);\n    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);\n\n    const [name, symbol, decimals, totalSupply] = await Promise.all([\n      contract.name(),\n      contract.symbol(),\n      contract.decimals(),\n      contract.totalSupply()\n    ]);\n\n    return {\n      address: tokenAddress,\n      name,\n      symbol,\n      decimals,\n      totalSupply: ethers.formatUnits(totalSupply, decimals),\n      network: networkConfig.name\n    };\n  } catch (error) {\n    // Console log removido (dados sensÃ­veis)\n    throw error;\n  }\n};\n\n// Obter saldo do token\nexport const getTokenBalance = (tokenAddress, walletAddress, network = 'ethereum') => {\n  try {\n    const networkConfig = SUPPORTED_NETWORKS[network];\n    if (!networkConfig) {\n      throw new Error('Unsupported network');\n    }\n\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);\n    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);\n\n    const [balance, decimals, symbol] = await Promise.all([\n      contract.balanceOf(walletAddress),\n      contract.decimals(),\n      contract.symbol()\n    ]);\n\n    return {\n      tokenAddress,\n      walletAddress,\n      balance: ethers.formatUnits(balance, decimals),\n      balanceRaw: balance.toString(),\n      symbol,\n      network: networkConfig.name\n    };\n  } catch (error) {\n    // Console log removido (dados sensÃ­veis)\n    throw error;\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE SEGURANÃ‡A =====\n\n// Verificar se o endereÃ§o estÃ¡ na lista de permissÃµes\nexport const isAddressWhitelisted = (address, whitelist) => {\n  if (!whitelist || !Array.isArray(whitelist)) {\n    return false;\n  }\n\n  return whitelist.some(\n    whitelistedAddress => whitelistedAddress.toLowerCase() === address.toLowerCase()\n  );\n};\n\n// Verificar se o endereÃ§o Ã© um contrato\nexport const isContractAddress = (address, network = 'ethereum') => {\n  try {\n    const networkConfig = SUPPORTED_NETWORKS[network];\n    if (!networkConfig) {\n      throw new Error('Unsupported network');\n    }\n\n    const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);\n    const code = await provider.getCode(address);\n\n    return code !== '0x';\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error checking if address is contract:', error);\n    }\n    return false;\n  }\n};\n\n// ===== FUNÃ‡Ã•ES DE UTILIDADE =====\n\n// Converter valor para Wei\nexport const toWei = (amount, decimals = 18) => {\n  try {\n    return ethers.parseUnits(amount.toString(), decimals);\n  } catch (error) {\n    throw new Error('Invalid amount format');\n  }\n};\n\n// Converter Wei para valor\nexport const fromWei = (amount, decimals = 18) => {\n  try {\n    return ethers.formatUnits(amount, decimals);\n  } catch (error) {\n    throw new Error('Invalid amount format');\n  }\n};\n\n// Formatar endereÃ§o para exibiÃ§Ã£o\nexport const formatAddress = (address, start = 6, end = 4) => {\n  if (!address || address.length < start + end) {\n    return address;\n  }\n\n  return `${address.slice(0, start)}...${address.slice(-end)}`;\n};\n\n// Verificar se o Metamask estÃ¡ disponÃ­vel\nexport const isMetamaskAvailable = () => {\n  return typeof window !== 'undefined' && window.ethereum && window.ethereum.isMetaMask;\n};\n\n// Obter endereÃ§o conectado\nexport const getConnectedAddress = async () => {\n  try {\n    if (!isMetamaskAvailable()) {\n      throw new Error('Metamask not available');\n    }\n\n    const accounts = await window.ethereum.request({ method: 'eth_accounts' });\n    return accounts[0] || null;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error getting connected address:', error);\n    }\n    return null;\n  }\n};\n\n// Conectar carteira\nexport const connectWallet = async () => {\n  try {\n    if (!isMetamaskAvailable()) {\n      throw new Error('Metamask not available');\n    }\n\n    const accounts = await window.ethereum.request({\n      method: 'eth_requestAccounts'\n    });\n\n    return accounts[0] || null;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error connecting wallet:', error);\n    }\n    throw error;\n  }\n};\n\n// Trocar rede\nexport const switchNetwork = async chainId => {\n  try {\n    if (!isMetamaskAvailable()) {\n      throw new Error('Metamask not available');\n    }\n\n    await window.ethereum.request({\n      method: 'wallet_switchEthereumChain',\n      params: [{ chainId: `0x${chainId.toString(16)}` }]\n    });\n\n    return true;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error switching network:', error);\n    }\n    throw error;\n  }\n};\n\nexport default {\n  SUPPORTED_NETWORKS,\n  isValidEthereumAddress,\n  isValidSignature,\n  isValidTransactionHash,\n  generateAuthMessage,\n  verifyMetamaskAuth,\n  createPaymentTransaction,\n  checkTransactionStatus,\n  getWalletBalance,\n  getTransactionHistory,\n  getTokenInfo,\n  getTokenBalance,\n  isAddressWhitelisted,\n  isContractAddress,\n  toWei,\n  fromWei,\n  formatAddress,\n  isMetamaskAvailable,\n  getConnectedAddress,\n  connectWallet,\n  switchNetwork\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\redis.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\security.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\socket.js",
    "messages": [
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 55,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 55,
        "endColumn": 13
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 60,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 60,
        "endColumn": 47
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import { Server } from 'socket.io';\nimport jwt from 'jsonwebtoken';\nimport User from '../models/User.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\n\nimport logger from '../utils/logger.js';\nexport const configureSocket = server => {\n  const io = new Server(server, {\n    cors: {\n      origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n      methods: ['GET', 'POST'],\n      credentials: true\n    },\n    transports: ['websocket', 'polling']\n  });\n\n  // Middleware de autenticaÃ§Ã£o para WebSocket\n  io.use(async (socket, next) => {\n    try {\n      const token = socket.handshake.auth.token || socket.handshake.headers.authorization;\n\n      if (!token) {\n        return next(new Error('Token de autenticaÃ§Ã£o nÃ£o fornecido'));\n      }\n\n      // Remover 'Bearer ' se presente\n      const cleanToken = token.replace('Bearer ', '');\n\n      const decoded = jwt.verify(cleanToken, process.env.JWT_SECRET);\n      const user = await User.findById(decoded.userId).select(\n        '_id name email company.name isAdmin'\n      );\n\n      if (!user) {\n        return next(new Error('UsuÃ¡rio nÃ£o encontrado'));\n      }\n\n      socket.userId = user._id.toString();\n      socket.user = user;\n\n      // Log de conexÃ£o\n      await createSecurityLog({\n        eventType: 'websocket_connection',\n        severity: 'info',\n        userId: user._id,\n        ipAddress: socket.handshake.address,\n        userAgent: socket.handshake.headers['user-agent'],\n        description: `WebSocket conectado para usuÃ¡rio ${user.email}`,\n        details: {\n          socketId: socket.id,\n          transport: socket.conn.transport.name\n        }\n      });\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro na autenticaÃ§Ã£o WebSocket:', error.message);\n      }\n      next(new Error('AutenticaÃ§Ã£o falhou'));\n    }\n  });\n\n  // Gerenciamento de conexÃµes\n  const connectedUsers = new Map();\n\n  io.on('connection', socket => {\n    if (process.env.NODE_ENV !== 'production') {\n      // Console log removido`);\n    }\n    // Adicionar usuÃ¡rio Ã  lista de conectados\n    connectedUsers.set(socket.userId, {\n      socketId: socket.id,\n      user: socket.user,\n      connectedAt: new Date()\n    });\n\n    // Juntar usuÃ¡rio Ã  sala pessoal\n    socket.join(`user_${socket.userId}`);\n\n    // Juntar usuÃ¡rio Ã  sala de notificaÃ§Ãµes se for admin\n    if (socket.user.isAdmin) {\n      socket.join('admin_notifications');\n    }\n\n    // Evento de mensagem privada\n    socket.on('send_private_message', async data => {\n      try {\n        const { receiverId, content, subject, messageType, relatedProduct, relatedFreight } = data;\n\n        // Validar dados\n        if (!receiverId || !content || !subject) {\n          socket.emit('message_error', { message: 'Dados invÃ¡lidos para mensagem' });\n          return;\n        }\n\n        // Verificar se o destinatÃ¡rio estÃ¡ online\n        const receiverSocket = connectedUsers.get(receiverId);\n\n        // Emitir mensagem para o destinatÃ¡rio se estiver online\n        if (receiverSocket) {\n          io.to(receiverSocket.socketId).emit('new_private_message', {\n            senderId: socket.userId,\n            senderName: socket.user.name,\n            senderCompany: socket.user.company?.name,\n            content,\n            subject,\n            messageType,\n            relatedProduct,\n            relatedFreight,\n            timestamp: new Date()\n          });\n        }\n\n        // Confirmar envio para o remetente\n        socket.emit('message_sent', {\n          success: true,\n          message: 'Mensagem enviada com sucesso',\n          timestamp: new Date()\n        });\n\n        // Log de mensagem enviada\n        await createSecurityLog({\n          eventType: 'websocket_message_sent',\n          severity: 'info',\n          userId: socket.userId,\n          ipAddress: socket.handshake.address,\n          description: 'Mensagem privada enviada via WebSocket',\n          details: {\n            receiverId,\n            messageType,\n            socketId: socket.id\n          }\n        });\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('Erro ao enviar mensagem via WebSocket:', error);\n        }\n        socket.emit('message_error', { message: 'Erro interno do servidor' });\n      }\n    });\n\n    // Evento de digitaÃ§Ã£o\n    socket.on('typing_start', data => {\n      const { receiverId } = data;\n      const receiverSocket = connectedUsers.get(receiverId);\n\n      if (receiverSocket) {\n        io.to(receiverSocket.socketId).emit('user_typing', {\n          userId: socket.userId,\n          userName: socket.user.name\n        });\n      }\n    });\n\n    socket.on('typing_stop', data => {\n      const { receiverId } = data;\n      const receiverSocket = connectedUsers.get(receiverId);\n\n      if (receiverSocket) {\n        io.to(receiverSocket.socketId).emit('user_stopped_typing', {\n          userId: socket.userId\n        });\n      }\n    });\n\n    // Evento de leitura de mensagem\n    socket.on('mark_message_read', async data => {\n      try {\n        const { messageId, senderId } = data;\n\n        // Notificar o remetente que a mensagem foi lida\n        const senderSocket = connectedUsers.get(senderId);\n        if (senderSocket) {\n          io.to(senderSocket.socketId).emit('message_read', {\n            messageId,\n            readBy: socket.userId,\n            readAt: new Date()\n          });\n        }\n\n        // Log de leitura\n        await createSecurityLog({\n          eventType: 'websocket_message_read',\n          severity: 'info',\n          userId: socket.userId,\n          description: 'Mensagem marcada como lida via WebSocket',\n          details: {\n            messageId,\n            senderId\n          }\n        });\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('Erro ao marcar mensagem como lida:', error);\n        }\n      }\n    });\n\n    // Evento de presenÃ§a online\n    socket.on('update_presence', data => {\n      const { status, customStatus } = data;\n\n      if (connectedUsers.has(socket.userId)) {\n        const userData = connectedUsers.get(socket.userId);\n        userData.status = status;\n        userData.customStatus = customStatus;\n        userData.lastSeen = new Date();\n\n        // Notificar outros usuÃ¡rios sobre mudanÃ§a de status\n        socket.broadcast.emit('user_presence_changed', {\n          userId: socket.userId,\n          status,\n          customStatus,\n          lastSeen: new Date()\n        });\n      }\n    });\n\n    // Evento de desconexÃ£o\n    socket.on('disconnect', async () => {\n      if (process.env.NODE_ENV !== 'production') {\n        // Console log removido`);\n      }\n      // Remover usuÃ¡rio da lista de conectados\n      connectedUsers.delete(socket.userId);\n\n      // Notificar outros usuÃ¡rios sobre a desconexÃ£o\n      socket.broadcast.emit('user_disconnected', {\n        userId: socket.userId,\n        userName: socket.user.name,\n        disconnectedAt: new Date()\n      });\n\n      // Log de desconexÃ£o\n      await createSecurityLog({\n        eventType: 'websocket_disconnection',\n        severity: 'info',\n        userId: socket.userId,\n        ipAddress: socket.handshake.address,\n        description: 'WebSocket desconectado',\n        details: {\n          socketId: socket.id,\n          connectedUsersCount: connectedUsers.size\n        }\n      });\n    });\n\n    // Evento de erro\n    socket.on('error', async error => {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro no WebSocket:', error);\n      }\n      await createSecurityLog({\n        eventType: 'websocket_error',\n        severity: 'error',\n        userId: socket.userId,\n        ipAddress: socket.handshake.address,\n        description: 'Erro no WebSocket',\n        details: {\n          error: error.message,\n          socketId: socket.id\n        }\n      });\n    });\n  });\n\n  // FunÃ§Ãµes auxiliares para uso em outras partes da aplicaÃ§Ã£o\n  const socketService = {\n    // Enviar notificaÃ§Ã£o para usuÃ¡rio especÃ­fico\n    sendToUser: (userId, event, data) => {\n      const userSocket = connectedUsers.get(userId);\n      if (userSocket) {\n        io.to(userSocket.socketId).emit(event, data);\n        return true;\n      }\n      return false;\n    },\n\n    // Enviar notificaÃ§Ã£o para todos os usuÃ¡rios\n    sendToAll: (event, data) => {\n      io.emit(event, data);\n    },\n\n    // Enviar notificaÃ§Ã£o para admins\n    sendToAdmins: (event, data) => {\n      io.to('admin_notifications').emit(event, data);\n    },\n\n    // Verificar se usuÃ¡rio estÃ¡ online\n    isUserOnline: userId => {\n      return connectedUsers.has(userId);\n    },\n\n    // Obter informaÃ§Ãµes de usuÃ¡rios conectados\n    getConnectedUsers: () => {\n      return Array.from(connectedUsers.values());\n    },\n\n    // Obter contagem de usuÃ¡rios conectados\n    getConnectedUsersCount: () => {\n      return connectedUsers.size;\n    }\n  };\n\n  return { io, socketService };\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\stripe.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\config\\swagger.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\handler.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\health-handler.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\admin\\admin.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\auth\\bootstrap.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'dynamodb' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 6,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const { DynamoDB } = require('aws-sdk');\nconst { MongoClient } = require('mongodb');\nconst jwt = require('jsonwebtoken');\n\nconst logger = require('../../utils/logger.js');\nconst dynamodb = new DynamoDB.DocumentClient();\nconst mongoClient = new MongoClient(process.env.MONGODB_URI);\n\nconst ADMIN_EMAIL = 'luispaulodeoliveira@agrotm.com.br';\n\nexports.handler = async event => {\n  try {\n    // Verificar se Ã© uma requisiÃ§Ã£o HTTP\n    if (!event.httpMethod) {\n      throw new Error('MÃ©todo HTTP nÃ£o especificado');\n    }\n\n    // Configurar CORS\n    const corsHeaders = {\n      'Access-Control-Allow-Origin': process.env.AMPLIFY_DOMAIN || '*',\n      'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n      'Access-Control-Allow-Methods': 'POST,OPTIONS',\n      'Access-Control-Allow-Credentials': true\n    };\n\n    // Handle preflight OPTIONS request\n    if (event.httpMethod === 'OPTIONS') {\n      return {\n        statusCode: 200,\n        headers: corsHeaders,\n        body: JSON.stringify({ message: 'OK' })\n      };\n    }\n\n    if (event.httpMethod !== 'POST') {\n      return {\n        statusCode: 405,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: {\n            code: 'METHOD_NOT_ALLOWED',\n            message: 'MÃ©todo nÃ£o permitido'\n          }\n        })\n      };\n    }\n\n    // Verificar autorizaÃ§Ã£o\n    const authHeader = event.headers.Authorization || event.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return {\n        statusCode: 401,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: {\n            code: 'UNAUTHORIZED',\n            message: 'Token de autorizaÃ§Ã£o nÃ£o fornecido'\n          }\n        })\n      };\n    }\n\n    const token = authHeader.substring(7);\n\n    // Verificar JWT do Cognito\n    let decodedToken;\n    try {\n      decodedToken = jwt.decode(token);\n      if (!decodedToken) {\n        throw new Error('Token invÃ¡lido');\n      }\n    } catch (error) {\n      return {\n        statusCode: 401,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: {\n            code: 'INVALID_TOKEN',\n            message: 'Token invÃ¡lido'\n          }\n        })\n      };\n    }\n\n    const cognitoSub = decodedToken.sub;\n    const { email } = decodedToken;\n\n    if (!cognitoSub || !email) {\n      return {\n        statusCode: 400,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: {\n            code: 'INVALID_TOKEN_DATA',\n            message: 'Dados do token invÃ¡lidos'\n          }\n        })\n      };\n    }\n\n    // Conectar ao MongoDB\n    await mongoClient.connect();\n    const db = mongoClient.db();\n\n    // Verificar se usuÃ¡rio jÃ¡ existe\n    const existingUser = await db.collection('users').findOne({\n      $or: [{ cognitoSub }, { email: email.toLowerCase() }]\n    });\n\n    if (existingUser) {\n      return {\n        statusCode: 409,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: {\n            code: 'USER_ALREADY_EXISTS',\n            message: 'UsuÃ¡rio jÃ¡ existe'\n          }\n        })\n      };\n    }\n\n    // Determinar role baseado no email\n    const role = email.toLowerCase() === ADMIN_EMAIL.toLowerCase() ? 'admin' : 'user';\n\n    // Criar usuÃ¡rio\n    const newUser = {\n      cognitoSub,\n      email: email.toLowerCase(),\n      role,\n      profile: {\n        name: decodedToken.name || '',\n        company: '',\n        phone: ''\n      },\n      plan: {\n        type: null,\n        status: 'inactive',\n        limitAds: 0,\n        limitShipments: null,\n        expiresAt: null\n      },\n      wallets: {},\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    // Inserir usuÃ¡rio\n    const result = await db.collection('users').insertOne(newUser);\n\n    // Criar Ã­ndices se nÃ£o existirem\n    await db.collection('users').createIndex({ email: 1 }, { unique: true });\n    await db.collection('users').createIndex({ cognitoSub: 1 }, { unique: true });\n\n    return {\n      statusCode: 201,\n      headers: corsHeaders,\n      body: JSON.stringify({\n        message: 'UsuÃ¡rio criado com sucesso',\n        user: {\n          id: result.insertedId,\n          email: newUser.email,\n          role: newUser.role,\n          plan: newUser.plan\n        }\n      })\n    };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no bootstrap:', error);\n    }\n    return {\n      statusCode: 500,\n      headers: {\n        'Access-Control-Allow-Origin': process.env.AMPLIFY_DOMAIN || '*',\n        'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n        'Access-Control-Allow-Methods': 'POST,OPTIONS',\n        'Access-Control-Allow-Credentials': true\n      },\n      body: JSON.stringify({\n        error: {\n          code: 'INTERNAL_ERROR',\n          message: 'Erro interno do servidor'\n        }\n      })\n    };\n  } finally {\n    if (mongoClient) {\n      await mongoClient.close();\n    }\n  }\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\auth\\updateProfile.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\messaging\\contact.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\payments\\plans.js",
    "messages": [
      {
        "ruleId": "prefer-destructuring",
        "severity": 2,
        "message": "Use object destructuring.",
        "line": 61,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "preferDestructuring",
        "endLine": 61,
        "endColumn": 35,
        "fix": { "range": [1775, 1801], "text": "{email} = decodedToken" }
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'verifyAdmin' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 71,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 71,
        "endColumn": 18
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 183,
        "column": 13,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 183,
        "endColumn": 31,
        "fix": { "range": [5292, 5310], "text": "planType" }
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 192,
        "column": 11,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 192,
        "endColumn": 29,
        "fix": { "range": [5517, 5535], "text": "planType" }
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 393,
        "column": 11,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 393,
        "endColumn": 29,
        "fix": { "range": [11596, 11614], "text": "planType" }
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 396,
        "column": 13,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 396,
        "endColumn": 27,
        "fix": { "range": [11684, 11698], "text": "txHash" }
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 412,
        "column": 15,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 412,
        "endColumn": 35,
        "fix": { "range": [12122, 12142], "text": "expiresAt" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 6,
    "fixableWarningCount": 0,
    "source": "﻿const { MongoClient } = require('mongodb');\nconst jwt = require('jsonwebtoken');\nconst Stripe = require('stripe');\nconst { ethers } = require('ethers');\n\nconst logger = require('../../utils/logger.js');\nconst mongoClient = new MongoClient(process.env.MONGODB_URI);\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\nconst ADMIN_EMAIL = 'luispaulodeoliveira@agrotm.com.br';\n\n// ConfiguraÃ§Ãµes dos planos\nconst PLANS = {\n  loja: {\n    name: 'Loja',\n    price: 25.0,\n    limitAds: 3,\n    limitShipments: null,\n    features: ['AtÃ© 3 anÃºncios', 'Suporte bÃ¡sico']\n  },\n  agroconecta_basico: {\n    name: 'AgroConecta BÃ¡sico',\n    price: 50.0,\n    limitAds: null, // ilimitado\n    limitShipments: null, // ilimitado\n    features: ['AnÃºncios ilimitados', 'Fretes ilimitados', 'Chat privado (GPT completo)']\n  },\n  fretes_avancado: {\n    name: 'Fretes AvanÃ§ado',\n    price: 149.0,\n    limitAds: null, // ilimitado\n    limitShipments: 30, // mÃ¡ximo 30/mÃªs\n    features: [\n      'AnÃºncios ilimitados',\n      'AtÃ© 30 fretes/mÃªs',\n      'Chat privado (GPT completo)',\n      'Analytics avanÃ§ados'\n    ]\n  }\n};\n\n// FunÃ§Ã£o auxiliar para verificar autorizaÃ§Ã£o\nconst verifyAuth = event => {\n  const authHeader = event.headers.Authorization || event.headers.authorization;\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return { error: 'UNAUTHORIZED', message: 'Token de autorizaÃ§Ã£o nÃ£o fornecido' };\n  }\n\n  const token = authHeader.substring(7);\n  let decodedToken;\n\n  try {\n    decodedToken = jwt.decode(token);\n    if (!decodedToken) {\n      return { error: 'INVALID_TOKEN', message: 'Token invÃ¡lido' };\n    }\n  } catch (error) {\n    return { error: 'INVALID_TOKEN', message: 'Token invÃ¡lido' };\n  }\n\n  const cognitoSub = decodedToken.sub;\n  const email = decodedToken.email;\n\n  if (!cognitoSub || !email) {\n    return { error: 'INVALID_TOKEN_DATA', message: 'Dados do token invÃ¡lidos' };\n  }\n\n  return { cognitoSub, email };\n};\n\n// FunÃ§Ã£o para verificar se Ã© admin\nconst verifyAdmin = email => {\n  return email.toLowerCase() === ADMIN_EMAIL.toLowerCase();\n};\n\nexports.handler = async event => {\n  try {\n    // Configurar CORS\n    const corsHeaders = {\n      'Access-Control-Allow-Origin': process.env.AMPLIFY_DOMAIN || '*',\n      'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n      'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',\n      'Access-Control-Allow-Credentials': true\n    };\n\n    // Handle preflight OPTIONS request\n    if (event.httpMethod === 'OPTIONS') {\n      return {\n        statusCode: 200,\n        headers: corsHeaders,\n        body: JSON.stringify({ message: 'OK' })\n      };\n    }\n\n    // Conectar ao MongoDB\n    await mongoClient.connect();\n    const db = mongoClient.db();\n\n    // GET /plans - Lista de planos disponÃ­veis (pÃºblica)\n    if (event.httpMethod === 'GET') {\n      const plansList = Object.entries(PLANS).map(([key, plan]) => ({\n        id: key,\n        ...plan,\n        priceFormatted: `R$ ${plan.price.toFixed(2).replace('.', ',')}`\n      }));\n\n      return {\n        statusCode: 200,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          plans: plansList\n        })\n      };\n    }\n\n    // POST /payments/stripe/checkout - Criar sessÃ£o de checkout do Stripe\n    if (event.httpMethod === 'POST' && event.path.includes('/stripe/checkout')) {\n      const auth = verifyAuth(event);\n      if (auth.error) {\n        return {\n          statusCode: 401,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: { code: auth.error, message: auth.message }\n          })\n        };\n      }\n\n      // Parse do body\n      let requestBody;\n      try {\n        requestBody = JSON.parse(event.body);\n      } catch (error) {\n        return {\n          statusCode: 400,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: { code: 'INVALID_JSON', message: 'JSON invÃ¡lido' }\n          })\n        };\n      }\n\n      const { planType } = requestBody;\n\n      if (!planType || !PLANS[planType]) {\n        return {\n          statusCode: 400,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: { code: 'INVALID_PLAN', message: 'Tipo de plano invÃ¡lido' }\n          })\n        };\n      }\n\n      const plan = PLANS[planType];\n      const siteUrl = process.env.SITE_URL || 'https://main.d3nvjszcpksd6p.amplifyapp.com';\n\n      try {\n        // Criar sessÃ£o de checkout do Stripe\n        const session = await stripe.checkout.sessions.create({\n          payment_method_types: ['card'],\n          line_items: [\n            {\n              price_data: {\n                currency: 'brl',\n                product_data: {\n                  name: plan.name,\n                  description: plan.features.join(', ')\n                },\n                unit_amount: Math.round(plan.price * 100), // Stripe usa centavos\n                recurring: {\n                  interval: 'month'\n                }\n              },\n              quantity: 1\n            }\n          ],\n          mode: 'subscription',\n          success_url: `${siteUrl}/login?ok=1&plan=${planType}`,\n          cancel_url: `${siteUrl}/planos?cancel=1`,\n          customer_email: auth.email,\n          metadata: {\n            cognitoSub: auth.cognitoSub,\n            planType: planType\n          }\n        });\n\n        // Registrar pagamento pendente no banco\n        const payment = {\n          userId: auth.cognitoSub,\n          method: 'stripe',\n          amountBRL: plan.price,\n          planType: planType,\n          status: 'pending',\n          providerRef: {\n            stripeSessionId: session.id\n          },\n          createdAt: new Date(),\n          updatedAt: new Date()\n        };\n\n        await db.collection('payments').insertOne(payment);\n\n        return {\n          statusCode: 200,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            sessionUrl: session.url,\n            sessionId: session.id\n          })\n        };\n      } catch (stripeError) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('Erro do Stripe:', stripeError);\n        }\n        return {\n          statusCode: 500,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: { code: 'STRIPE_ERROR', message: 'Erro ao criar sessÃ£o de pagamento' }\n          })\n        };\n      }\n    }\n\n    // POST /payments/crypto/submit - Submeter pagamento em cripto\n    if (event.httpMethod === 'POST' && event.path.includes('/crypto/submit')) {\n      const auth = verifyAuth(event);\n      if (auth.error) {\n        return {\n          statusCode: 401,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: { code: auth.error, message: auth.message }\n          })\n        };\n      }\n\n      // Parse do body\n      let requestBody;\n      try {\n        requestBody = JSON.parse(event.body);\n      } catch (error) {\n        return {\n          statusCode: 400,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: { code: 'INVALID_JSON', message: 'JSON invÃ¡lido' }\n          })\n        };\n      }\n\n      const { txHash, planType } = requestBody;\n\n      if (!txHash || !planType || !PLANS[planType]) {\n        return {\n          statusCode: 400,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: {\n              code: 'INVALID_DATA',\n              message: 'Hash da transaÃ§Ã£o e tipo de plano sÃ£o obrigatÃ³rios'\n            }\n          })\n        };\n      }\n\n      // Verificar se jÃ¡ existe pagamento com este hash\n      const existingPayment = await db.collection('payments').findOne({\n        'providerRef.txHash': txHash\n      });\n\n      if (existingPayment) {\n        return {\n          statusCode: 409,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: { code: 'DUPLICATE_TRANSACTION', message: 'TransaÃ§Ã£o jÃ¡ processada' }\n          })\n        };\n      }\n\n      try {\n        // Validar transaÃ§Ã£o on-chain\n        const provider = new ethers.JsonRpcProvider(process.env.CHAIN_RPC_URL);\n        const tx = await provider.getTransaction(txHash);\n        const receipt = await provider.getTransactionReceipt(txHash);\n\n        if (!tx || !receipt) {\n          return {\n            statusCode: 400,\n            headers: corsHeaders,\n            body: JSON.stringify({\n              error: {\n                code: 'TRANSACTION_NOT_FOUND',\n                message: 'TransaÃ§Ã£o nÃ£o encontrada na blockchain'\n              }\n            })\n          };\n        }\n\n        // Verificar se a transaÃ§Ã£o foi confirmada\n        if (receipt.status !== 1) {\n          return {\n            statusCode: 400,\n            headers: corsHeaders,\n            body: JSON.stringify({\n              error: { code: 'TRANSACTION_FAILED', message: 'TransaÃ§Ã£o falhou na blockchain' }\n            })\n          };\n        }\n\n        // Verificar se foi enviada para a carteira do admin\n        const adminWallet = process.env.ADMIN_WALLET?.toLowerCase();\n        if (tx.to?.toLowerCase() !== adminWallet) {\n          return {\n            statusCode: 400,\n            headers: corsHeaders,\n            body: JSON.stringify({\n              error: {\n                code: 'INVALID_RECIPIENT',\n                message: 'TransaÃ§Ã£o enviada para carteira incorreta'\n              }\n            })\n          };\n        }\n\n        // Verificar valor da transaÃ§Ã£o (em ETH)\n        const plan = PLANS[planType];\n        const expectedValue = ethers.parseEther(plan.price.toString()); // Converter para wei\n\n        // Permitir margem de erro de 10%\n        // create a tolerance of 10% using BigNumber arithmetic\n        const expectedBN = expectedValue;\n        const toleranceBN = expectedBN.mul(10).div(100); // 10%\n\n        const txValueBN = ethers.BigNumber.from(tx.value.toString());\n        const diff = txValueBN.gte(expectedBN)\n          ? txValueBN.sub(expectedBN)\n          : expectedBN.sub(txValueBN);\n        if (diff.gt(toleranceBN)) {\n          return {\n            statusCode: 400,\n            headers: corsHeaders,\n            body: JSON.stringify({\n              error: {\n                code: 'INVALID_AMOUNT',\n                message: 'Valor da transaÃ§Ã£o nÃ£o corresponde ao plano'\n              }\n            })\n          };\n        }\n\n        // Verificar confirmaÃ§Ãµes (mÃ­nimo 1)\n        const currentBlock = await provider.getBlockNumber();\n        const confirmations = currentBlock - receipt.blockNumber;\n\n        if (confirmations < 1) {\n          return {\n            statusCode: 400,\n            headers: corsHeaders,\n            body: JSON.stringify({\n              error: {\n                code: 'INSUFFICIENT_CONFIRMATIONS',\n                message: 'TransaÃ§Ã£o precisa de pelo menos 1 confirmaÃ§Ã£o'\n              }\n            })\n          };\n        }\n\n        // Ativar plano do usuÃ¡rio\n        const expiresAt = new Date();\n        expiresAt.setMonth(expiresAt.getMonth() + 1);\n\n        await db.collection('users').updateOne(\n          { cognitoSub: auth.cognitoSub },\n          {\n            $set: {\n              'plan.type': planType,\n              'plan.status': 'active',\n              'plan.limitAds': plan.limitAds,\n              'plan.limitShipments': plan.limitShipments,\n              'plan.expiresAt': expiresAt,\n              updatedAt: new Date()\n            }\n          }\n        );\n\n        // Registrar pagamento bem-sucedido\n        const payment = {\n          userId: auth.cognitoSub,\n          method: 'crypto',\n          amountBRL: plan.price,\n          planType: planType,\n          status: 'succeeded',\n          providerRef: {\n            txHash: txHash\n          },\n          createdAt: new Date(),\n          updatedAt: new Date()\n        };\n\n        await db.collection('payments').insertOne(payment);\n\n        return {\n          statusCode: 200,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            message: 'Pagamento em cripto processado com sucesso',\n            plan: {\n              type: planType,\n              status: 'active',\n              expiresAt: expiresAt\n            }\n          })\n        };\n      } catch (blockchainError) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('Erro na validaÃ§Ã£o blockchain:', blockchainError);\n        }\n        return {\n          statusCode: 500,\n          headers: corsHeaders,\n          body: JSON.stringify({\n            error: {\n              code: 'BLOCKCHAIN_ERROR',\n              message: 'Erro ao validar transaÃ§Ã£o na blockchain'\n            }\n          })\n        };\n      }\n    }\n\n    // MÃ©todo nÃ£o suportado\n    return {\n      statusCode: 405,\n      headers: corsHeaders,\n      body: JSON.stringify({\n        error: { code: 'METHOD_NOT_ALLOWED', message: 'MÃ©todo nÃ£o permitido' }\n      })\n    };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no gerenciamento de planos e pagamentos:', error);\n    }\n    return {\n      statusCode: 500,\n      headers: {\n        'Access-Control-Allow-Origin': process.env.AMPLIFY_DOMAIN || '*',\n        'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n        'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',\n        'Access-Control-Allow-Credentials': true\n      },\n      body: JSON.stringify({\n        error: { code: 'INTERNAL_ERROR', message: 'Erro interno do servidor' }\n      })\n    };\n  } finally {\n    if (mongoClient) {\n      await mongoClient.close();\n    }\n  }\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\payments\\stripe-webhook.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'crypto' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 3,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 13
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'cognitoSub' is not defined.",
        "line": 259,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 259,
        "endColumn": 25
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'planType' is not defined.",
        "line": 261,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 261,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const { MongoClient } = require('mongodb');\nconst Stripe = require('stripe');\nconst crypto = require('crypto');\nconst logger = require('../../utils/logger');\n\nconst mongoClient = new MongoClient(process.env.MONGODB_URI);\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\nconst webhookSecret = process.env.WEBHOOK_SECRET;\n\nexports.handler = async event => {\n  try {\n    // Configurar CORS\n    const corsHeaders = {\n      'Access-Control-Allow-Origin': process.env.AMPLIFY_DOMAIN || '*',\n      'Access-Control-Allow-Headers': 'Content-Type,Stripe-Signature',\n      'Access-Control-Allow-Methods': 'POST,OPTIONS',\n      'Access-Control-Allow-Credentials': true\n    };\n\n    // Handle preflight OPTIONS request\n    if (event.httpMethod === 'OPTIONS') {\n      return {\n        statusCode: 200,\n        headers: corsHeaders,\n        body: JSON.stringify({ message: 'OK' })\n      };\n    }\n\n    if (event.httpMethod !== 'POST') {\n      return {\n        statusCode: 405,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: { code: 'METHOD_NOT_ALLOWED', message: 'MÃ©todo nÃ£o permitido' }\n        })\n      };\n    }\n\n    // Verificar assinatura do webhook\n    const signature = event.headers['Stripe-Signature'] || event.headers['stripe-signature'];\n    if (!signature) {\n      return {\n        statusCode: 400,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: { code: 'MISSING_SIGNATURE', message: 'Assinatura do webhook nÃ£o fornecida' }\n        })\n      };\n    }\n\n    let stripeEvent;\n    try {\n      stripeEvent = stripe.webhooks.constructEvent(event.body, signature, webhookSecret);\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro na verificaÃ§Ã£o da assinatura:', err.message);\n      }\n      return {\n        statusCode: 400,\n        headers: corsHeaders,\n        body: JSON.stringify({\n          error: { code: 'INVALID_SIGNATURE', message: 'Assinatura invÃ¡lida' }\n        })\n      };\n    }\n\n    // Conectar ao MongoDB\n    await mongoClient.connect();\n    const db = mongoClient.db();\n\n    // Verificar idempotÃªncia - evitar processamento duplicado\n    const eventId = stripeEvent.id;\n    const existingEvent = await db.collection('webhook_events').findOne({ eventId });\n\n    if (existingEvent) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Evento jÃ¡ processado: ${eventId}`);\n      }\n      return {\n        statusCode: 200,\n        headers: corsHeaders,\n        body: JSON.stringify({ received: true, message: 'Event already processed' })\n      };\n    }\n\n    // Registrar evento para idempotÃªncia\n    await db.collection('webhook_events').insertOne({\n      eventId,\n      type: stripeEvent.type,\n      processedAt: new Date(),\n      data: stripeEvent.data.object\n    });\n\n    // Processar eventos do Stripe\n    switch (stripeEvent.type) {\n      case 'checkout.session.completed':\n        await handleCheckoutSessionCompleted(db, stripeEvent.data.object);\n        break;\n\n      case 'invoice.payment_succeeded':\n        await handleInvoicePaymentSucceeded(db, stripeEvent.data.object);\n        break;\n\n      case 'invoice.payment_failed':\n        await handleInvoicePaymentFailed(db, stripeEvent.data.object);\n        break;\n\n      case 'customer.subscription.deleted':\n        await handleSubscriptionDeleted(db, stripeEvent.data.object);\n        break;\n\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Evento nÃ£o processado: ${stripeEvent.type}`);\n        }\n    }\n\n    return {\n      statusCode: 200,\n      headers: corsHeaders,\n      body: JSON.stringify({ received: true })\n    };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no webhook do Stripe:', error);\n    }\n    return {\n      statusCode: 500,\n      headers: {\n        'Access-Control-Allow-Origin': process.env.AMPLIFY_DOMAIN || '*',\n        'Access-Control-Allow-Headers': 'Content-Type,Stripe-Signature',\n        'Access-Control-Allow-Methods': 'POST,OPTIONS',\n        'Access-Control-Allow-Credentials': true\n      },\n      body: JSON.stringify({\n        error: { code: 'INTERNAL_ERROR', message: 'Erro interno do servidor' }\n      })\n    };\n  } finally {\n    if (mongoClient) {\n      await mongoClient.close();\n    }\n  }\n};\n\n// FunÃ§Ã£o para processar checkout.session.completed\nasync function handleCheckoutSessionCompleted(db, session) {\n  try {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Processando checkout.session.completed:', session.id);\n    }\n    const { cognitoSub, planType } = session.metadata;\n    if (!cognitoSub || !planType) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Metadados ausentes na sessÃ£o:', session.id);\n      }\n      return;\n    }\n\n    // Buscar usuÃ¡rio\n    const user = await db.collection('users').findOne({ cognitoSub });\n    if (!user) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('UsuÃ¡rio nÃ£o encontrado:', cognitoSub);\n      }\n      return;\n    }\n\n    // Verificar se o pagamento jÃ¡ foi processado\n    const existingPayment = await db.collection('payments').findOne({\n      'providerRef.stripeSessionId': session.id,\n      status: 'succeeded'\n    });\n\n    if (existingPayment) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Pagamento jÃ¡ processado para sessÃ£o: ${session.id}`);\n      }\n      return;\n    }\n\n    // ConfiguraÃ§Ãµes dos planos\n    const PLANS = {\n      loja: {\n        limitAds: 3,\n        limitShipments: null\n      },\n      agroconecta_basico: {\n        limitAds: null,\n        limitShipments: null\n      },\n      fretes_avancado: {\n        limitAds: null,\n        limitShipments: 30\n      }\n    };\n\n    const plan = PLANS[planType];\n    if (!plan) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Plano invÃ¡lido:', planType);\n      }\n      return;\n    }\n\n    // Calcular data de expiraÃ§Ã£o\n    const expiresAt = new Date();\n    expiresAt.setMonth(expiresAt.getMonth() + 1);\n\n    // Atualizar usuÃ¡rio com plano ativo\n    await db.collection('users').updateOne(\n      { cognitoSub },\n      {\n        $set: {\n          'plan.type': planType,\n          'plan.status': 'active',\n          'plan.limitAds': plan.limitAds,\n          'plan.limitShipments': plan.limitShipments,\n          'plan.expiresAt': expiresAt,\n          updatedAt: new Date()\n        }\n      }\n    );\n\n    // Atualizar status do pagamento\n    await db.collection('payments').updateOne(\n      { 'providerRef.stripeSessionId': session.id },\n      {\n        $set: {\n          status: 'succeeded',\n          'providerRef.stripePaymentIntentId': session.payment_intent,\n          processedAt: new Date(),\n          updatedAt: new Date()\n        }\n      }\n    );\n\n    // Registrar log de sucesso\n    await db.collection('payment_logs').insertOne({\n      userId: cognitoSub,\n      sessionId: session.id,\n      planType,\n      status: 'succeeded',\n      amount: session.amount_total / 100,\n      currency: session.currency,\n      processedAt: new Date(),\n      eventType: 'checkout.session.completed'\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Plano ${planType} ativado para usuÃ¡rio ${cognitoSub} - SessÃ£o: ${session.id}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar checkout.session.completed:', error);\n    }\n    // Registrar erro\n    await db.collection('payment_logs').insertOne({\n      userId: cognitoSub,\n      sessionId: session.id,\n      planType,\n      status: 'error',\n      error: error.message,\n      processedAt: new Date(),\n      eventType: 'checkout.session.completed'\n    });\n  }\n}\n\n// FunÃ§Ã£o para processar invoice.payment_succeeded\nasync function handleInvoicePaymentSucceeded(db, invoice) {\n  try {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Processando invoice.payment_succeeded:', invoice.id);\n    }\n    // Buscar assinatura\n    const subscription = await stripe.subscriptions.retrieve(invoice.subscription);\n    if (!subscription) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Assinatura nÃ£o encontrada:', invoice.subscription);\n      }\n      return;\n    }\n\n    // Buscar usuÃ¡rio pelo customer ID ou metadata\n    const user = await db.collection('users').findOne({\n      $or: [\n        { 'stripe.customerId': invoice.customer },\n        { 'stripe.subscriptionId': invoice.subscription }\n      ]\n    });\n\n    if (!user) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('UsuÃ¡rio nÃ£o encontrado para invoice:', invoice.id);\n      }\n      return;\n    }\n\n    // Renovar plano\n    const expiresAt = new Date();\n    expiresAt.setMonth(expiresAt.getMonth() + 1);\n\n    await db.collection('users').updateOne(\n      { _id: user._id },\n      {\n        $set: {\n          'plan.expiresAt': expiresAt,\n          updatedAt: new Date()\n        }\n      }\n    );\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Plano renovado para usuÃ¡rio ${user.cognitoSub}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar invoice.payment_succeeded:', error);\n    }\n  }\n}\n\n// FunÃ§Ã£o para processar invoice.payment_failed\nasync function handleInvoicePaymentFailed(db, invoice) {\n  try {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Processando invoice.payment_failed:', invoice.id);\n    }\n    // Buscar usuÃ¡rio\n    const user = await db.collection('users').findOne({\n      $or: [\n        { 'stripe.customerId': invoice.customer },\n        { 'stripe.subscriptionId': invoice.subscription }\n      ]\n    });\n\n    if (!user) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('UsuÃ¡rio nÃ£o encontrado para invoice failed:', invoice.id);\n      }\n      return;\n    }\n\n    // Marcar plano como expirado\n    await db.collection('users').updateOne(\n      { _id: user._id },\n      {\n        $set: {\n          'plan.status': 'expired',\n          updatedAt: new Date()\n        }\n      }\n    );\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Plano marcado como expirado para usuÃ¡rio ${user.cognitoSub}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar invoice.payment_failed:', error);\n    }\n  }\n}\n\n// FunÃ§Ã£o para processar customer.subscription.deleted\nasync function handleSubscriptionDeleted(db, subscription) {\n  try {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Processando customer.subscription.deleted:', subscription.id);\n    }\n    // Buscar usuÃ¡rio\n    const user = await db.collection('users').findOne({\n      'stripe.subscriptionId': subscription.id\n    });\n\n    if (!user) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('UsuÃ¡rio nÃ£o encontrado para subscription deleted:', subscription.id);\n      }\n      return;\n    }\n\n    // Marcar plano como expirado\n    await db.collection('users').updateOne(\n      { _id: user._id },\n      {\n        $set: {\n          'plan.status': 'expired',\n          updatedAt: new Date()\n        }\n      }\n    );\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Plano marcado como expirado para usuÃ¡rio ${user.cognitoSub}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar customer.subscription.deleted:', error);\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\products\\products.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\lambdas\\shipments\\shipments.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\admin.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'jwt' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 36,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 36,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 67,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 67,
        "endColumn": 13
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 82,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 82,
        "endColumn": 35
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 116,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 116,
        "endColumn": 13
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 121,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 121,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import jwt from 'jsonwebtoken';\nimport User from '../models/User.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para verificar se o usuÃ¡rio Ã© admin\nexport const requireAdmin = async (req, res, next) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar o usuÃ¡rio no banco\n    const user = await User.findById(userId);\n\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se Ã© admin\n    if (!user.isAdmin) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. Apenas administradores podem acessar esta Ã¡rea.'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes do admin ao req\n    req.admin = {\n      id: user._id,\n      email: user.email,\n      name: user.name,\n      permissions: user.adminPermissions || []\n    };\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na verificaÃ§Ã£o de admin:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n};\n\n// Middleware para verificar permissÃµes especÃ­ficas de admin\nexport const requireAdminPermission = permission => {\n  return (req, res, next) => {\n    try {\n      if (!req.admin) {\n        return res.status(401).json({\n          success: false,\n          message: 'UsuÃ¡rio nÃ£o autenticado como admin'\n        });\n      }\n\n      // Verificar se tem a permissÃ£o especÃ­fica\n      if (!req.admin.permissions.includes(permission) && !req.admin.permissions.includes('*')) {\n        return res.status(403).json({\n          success: false,\n          message: `PermissÃ£o '${permission}' necessÃ¡ria para esta aÃ§Ã£o`\n        });\n      }\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro na verificaÃ§Ã£o de permissÃ£o:', error);\n      }\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  };\n};\n\n// Middleware para log de auditoria automÃ¡tico\nexport const auditLog = (action, resource) => {\n  return async (req, res, next) => {\n    try {\n      // Interceptar a resposta para logar apÃ³s sucesso\n      const originalSend = res.send;\n\n      res.send = function (data) {\n        // SÃ³ logar se a resposta foi bem-sucedida\n        if (res.statusCode >= 200 && res.statusCode < 300) {\n          // Log assÃ­ncrono sem bloquear a resposta\n          setImmediate(async () => {\n            try {\n              const AuditLog = (await import('../models/AuditLog.js')).default;\n              await AuditLog.logAction({\n                userId: req.user?.userId,\n                userEmail: req.user?.email,\n                action,\n                resource,\n                resourceId: req.params?.id,\n                details: `Admin action: ${action} on ${resource}`,\n                ip: req.ip,\n                userAgent: req.get('User-Agent')\n              });\n            } catch (logError) {\n              if (process.env.NODE_ENV !== 'production') {\n                logger.error('Erro ao registrar log de auditoria:', logError);\n              }\n            }\n          });\n        }\n\n        // Chamar o mÃ©todo original\n        originalSend.call(this, data);\n      };\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro no middleware de auditoria:', error);\n      }\n      next(error);\n    }\n  };\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\adminAuth.js",
    "messages": [
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 56,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 56,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 118,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 118,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import jwt from 'jsonwebtoken';\nimport auditService from '../services/auditService.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para verificar se o usuÃ¡rio Ã© admin\nconst requireAdmin = async (req, res, next) => {\n  try {\n    // Verificar se o token foi fornecido\n    const token = req.headers.authorization?.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({\n        success: false,\n        message: 'Token de acesso nÃ£o fornecido'\n      });\n    }\n\n    // Verificar se o token Ã© vÃ¡lido\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n\n    // Verificar se o usuÃ¡rio existe e Ã© admin\n    if (!decoded.email || !decoded.role || decoded.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. Apenas administradores podem acessar este recurso.'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes do usuÃ¡rio ao request\n    req.user = {\n      id: decoded.id,\n      email: decoded.email,\n      role: decoded.role\n    };\n\n    // Log da aÃ§Ã£o\n    await auditService.logAdminAccess({\n      userId: decoded.id,\n      resource: req.originalUrl,\n      resourceId: null,\n      sessionInfo: {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        country: req.get('CF-IPCountry') || 'unknown',\n        city: req.get('CF-IPCity') || 'unknown',\n        isp: req.get('CF-IPISP') || 'unknown'\n      },\n      metadata: {\n        endpoint: req.originalUrl,\n        method: req.method,\n        statusCode: 200,\n        responseTime: 0\n      }\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na verificaÃ§Ã£o de admin:', error);\n    }\n    if (error.name === 'JsonWebTokenError') {\n      return res.status(401).json({\n        success: false,\n        message: 'Token invÃ¡lido'\n      });\n    }\n\n    if (error.name === 'TokenExpiredError') {\n      return res.status(401).json({\n        success: false,\n        message: 'Token expirado'\n      });\n    }\n\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n};\n\n// Middleware para validar aÃ§Ãµes administrativas\nconst validateAdminAction = async (req, res, next) => {\n  try {\n    const { action, resourceId, details } = req.body;\n\n    if (!action || !resourceId) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o e ID do recurso sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Log da aÃ§Ã£o administrativa\n    await auditService.logAction({\n      userId: req.user.id,\n      action: `admin_${action.toLowerCase()}`,\n      resource: req.originalUrl,\n      resourceId,\n      afterData: { details: details || `Admin action: ${action}` },\n      sessionInfo: {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        country: req.get('CF-IPCountry') || 'unknown',\n        city: req.get('CF-IPCity') || 'unknown',\n        isp: req.get('CF-IPISP') || 'unknown'\n      },\n      metadata: {\n        endpoint: req.originalUrl,\n        method: req.method,\n        statusCode: 200,\n        responseTime: 0\n      },\n      sensitivityLevel: 'high',\n      containsPII: false\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o da aÃ§Ã£o administrativa:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n};\n\nexport { requireAdmin, validateAdminAction };\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\adminValidation.js",
    "messages": [
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 45,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 45,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import AuditLog from '../models/AuditLog.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para validar aÃ§Ãµes administrativas\nexport const validateAdminAction = async (req, res, next) => {\n  try {\n    const { action, reason } = req.body;\n\n    // Validar se aÃ§Ã£o e motivo foram fornecidos\n    if (!action || !reason) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o e motivo sÃ£o obrigatÃ³rios para operaÃ§Ãµes administrativas'\n      });\n    }\n\n    // Validar se o motivo tem pelo menos 10 caracteres\n    if (reason.trim().length < 10) {\n      return res.status(400).json({\n        success: false,\n        message: 'Motivo deve ter pelo menos 10 caracteres'\n      });\n    }\n\n    // Validar se a aÃ§Ã£o Ã© vÃ¡lida\n    const validActions = ['ban', 'activate', 'update', 'delete', 'export'];\n    if (!validActions.includes(action)) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o administrativa invÃ¡lida'\n      });\n    }\n\n    // Log da validaÃ§Ã£o da aÃ§Ã£o administrativa\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'ADMIN_ACTION_VALIDATED',\n      resource: 'admin_validation',\n      details: `Admin action validated: ${action} - ${reason}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o da aÃ§Ã£o administrativa:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'ADMIN_ACTION_VALIDATION_ERROR',\n      resource: 'admin_validation',\n      details: `Validation error: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'VALIDATION_ERROR',\n      errorMessage: error.message\n    });\n\n    return res.status(500).json({\n      success: false,\n      message: 'Erro na validaÃ§Ã£o da aÃ§Ã£o administrativa'\n    });\n  }\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\audit.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\auth.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\cors.js",
    "messages": [
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 45,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 45,
        "endColumn": 27
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 48,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 48,
        "endColumn": 60
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// =============================================================\n// AGROISYNC â€¢ Middleware CORS Otimizado\n// =============================================================\n\n/**\n * ConfiguraÃ§Ã£o CORS para mÃºltiplas origens\n */\nimport logger from '../utils/logger.js';\n\nconst isProduction =\n  typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production';\n\nfunction getAllowedOriginsForEnv() {\n  if (isProduction) {\n    return ['https://agroisync.com', 'https://www.agroisync.com'];\n  }\n  return [\n    'http://localhost:3000',\n    'http://localhost:3001',\n    'http://127.0.0.1:3000',\n    'http://127.0.0.1:3001'\n  ];\n}\n\nexport const corsOptions = {\n  origin(origin, callback) {\n    const allowedOrigins = getAllowedOriginsForEnv();\n\n    // Permitir requisiÃ§Ãµes sem origin (mobile apps, Postman, etc.)\n    if (!origin) {\n      return callback(null, true);\n    }\n\n    // Verificar se a origem estÃ¡ na lista\n    const isAllowed = allowedOrigins.some(allowedOrigin => {\n      if (typeof allowedOrigin === 'string') {\n        return allowedOrigin === origin;\n      } else if (allowedOrigin instanceof RegExp) {\n        return allowedOrigin.test(origin);\n      }\n      return false;\n    });\n\n    if (isAllowed) {\n      callback(null, true);\n    } else {\n      logger.warn(`CORS: Origem bloqueada: ${origin}`);\n      callback(new Error('Não permitido pelo CORS'), false);\n    }\n  },\n\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'],\n\n  allowedHeaders: [\n    'Origin',\n    'X-Requested-With',\n    'Content-Type',\n    'Accept',\n    'Authorization',\n    'X-CSRF-Token',\n    'X-API-Key',\n    'X-Client-Version',\n    'X-Platform',\n    'Cache-Control',\n    'Pragma'\n  ],\n\n  exposedHeaders: [\n    'X-Total-Count',\n    'X-Page-Count',\n    'X-Current-Page',\n    'X-Per-Page',\n    'X-Rate-Limit-Limit',\n    'X-Rate-Limit-Remaining',\n    'X-Rate-Limit-Reset'\n  ],\n\n  credentials: true, // Permitir cookies\n  maxAge: 86400, // Cache preflight por 24 horas\n  optionsSuccessStatus: 200 // Para browsers legados\n};\n\n/**\n * Middleware CORS customizado para Cloudflare Workers\n */\nexport const corsMiddleware = request => {\n  const origin = request.headers.get('Origin');\n\n  const allowedOrigins = getAllowedOriginsForEnv();\n\n  const isAllowed = !origin || allowedOrigins.includes(origin);\n\n  // Headers CORS\n  const corsHeaders = {\n    'Access-Control-Allow-Origin': isAllowed ? origin : 'https://agroisync.com',\n    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With, X-CSRF-Token',\n    'Access-Control-Allow-Credentials': 'true',\n    'Access-Control-Max-Age': '86400'\n  };\n\n  // Responder a OPTIONS preflight\n  if (request.method === 'OPTIONS') {\n    return new Response(null, {\n      status: 200,\n      headers: corsHeaders\n    });\n  }\n\n  return { corsHeaders, isAllowed };\n};\n\n/**\n * Middleware para adicionar headers de seguranÃ§a\n */\nexport const securityHeaders = (req, res, next) => {\n  // Headers de seguranÃ§a\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n\n  // Content Security Policy\n  res.setHeader(\n    'Content-Security-Policy',\n    [\n      \"default-src 'self'\",\n      \"script-src 'self' 'unsafe-inline' 'unsafe-eval' https://js.stripe.com https://challenges.cloudflare.com\",\n      \"style-src 'self' 'unsafe-inline' https://fonts.googleapis.com\",\n      \"font-src 'self' https://fonts.gstatic.com\",\n      \"img-src 'self' data: https: blob:\",\n      \"connect-src 'self' https://api.stripe.com https://api.cloudflare.com wss: ws:\",\n      'frame-src https://js.stripe.com https://challenges.cloudflare.com',\n      \"object-src 'none'\",\n      \"base-uri 'self'\",\n      \"form-action 'self'\",\n      \"frame-ancestors 'none'\"\n    ].join('; ')\n  );\n\n  next();\n};\n\nexport default {\n  corsOptions,\n  corsMiddleware,\n  securityHeaders\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\csp.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\csrf.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\d1Validation.js",
    "messages": [
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 39,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 39,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 82,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 82,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// =============================================================\n// AGROISYNC â€¢ Middleware de ValidaÃ§Ã£o D1 Database\n// =============================================================\n\nimport logger from '../utils/logger.js';\n\n/**\n * Middleware para validar conexÃ£o com D1 Database\n */\nexport const validateD1Connection = (req, res, next) => {\n  try {\n    // Verificar se req.db estÃ¡ disponÃ­vel\n    if (!req.db) {\n      logger.error('D1 Database nÃ£o disponÃ­vel no request');\n      return res.status(503).json({\n        success: false,\n        error: 'Database nÃ£o disponÃ­vel',\n        code: 'DB_UNAVAILABLE'\n      });\n    }\n\n    // Verificar se req.db tem mÃ©todos necessÃ¡rios\n    const requiredMethods = ['prepare', 'batch', 'exec'];\n    const missingMethods = requiredMethods.filter(method => typeof req.db[method] !== 'function');\n\n    if (missingMethods.length > 0) {\n      logger.error(`MÃ©todos D1 ausentes: ${missingMethods.join(', ')}`);\n      return res.status(503).json({\n        success: false,\n        error: 'Database interface incompleta',\n        code: 'DB_INTERFACE_ERROR',\n        missingMethods\n      });\n    }\n\n    // Adicionar timestamp para debug\n    req.dbTimestamp = Date.now();\n\n    next();\n  } catch (error) {\n    logger.error('Erro na validaÃ§Ã£o D1:', error);\n    return res.status(500).json({\n      success: false,\n      error: 'Erro interno na validaÃ§Ã£o do database',\n      code: 'DB_VALIDATION_ERROR'\n    });\n  }\n};\n\n/**\n * Middleware para testar conexÃ£o D1 com query simples\n */\nexport const testD1Connection = async (req, res, next) => {\n  try {\n    if (!req.db) {\n      return res.status(503).json({\n        success: false,\n        error: 'Database nÃ£o disponÃ­vel',\n        code: 'DB_UNAVAILABLE'\n      });\n    }\n\n    // Executar query de teste simples\n    const result = await req.db.prepare('SELECT 1 as test').first();\n\n    if (!result || result.test !== 1) {\n      logger.error('Teste D1 falhou - resultado invÃ¡lido');\n      return res.status(503).json({\n        success: false,\n        error: 'Database nÃ£o responde corretamente',\n        code: 'DB_TEST_FAILED'\n      });\n    }\n\n    // Adicionar informaÃ§Ãµes de performance\n    req.dbInfo = {\n      connected: true,\n      timestamp: Date.now()\n    };\n\n    logger.info('D1 Database conectado');\n    next();\n  } catch (error) {\n    logger.error('Erro no teste D1:', error);\n    return res.status(503).json({\n      success: false,\n      error: 'Database nÃ£o acessÃ­vel',\n      code: 'DB_CONNECTION_ERROR',\n      details: error.message\n    });\n  }\n};\n\n/**\n * Health check especÃ­fico para D1\n */\nexport const d1HealthCheck = async (req, res) => {\n  try {\n    if (!req.db) {\n      return res.status(503).json({\n        success: false,\n        status: 'unhealthy',\n        error: 'Database nÃ£o disponÃ­vel',\n        timestamp: Date.now()\n      });\n    }\n\n    // Teste bÃ¡sico de conectividade\n    await req.db.prepare('SELECT 1').first();\n\n    // Teste de tabelas crÃ­ticas\n    const tables = await req.db\n      .prepare(\n        `\n      SELECT name FROM sqlite_master \n      WHERE type='table' AND name NOT LIKE 'sqlite_%'\n    `\n      )\n      .all();\n\n    const criticalTables = ['users', 'products', 'freights'];\n    const availableTables = tables.map(t => t.name);\n    const missingTables = criticalTables.filter(t => !availableTables.includes(t));\n\n    const status = missingTables.length === 0 ? 'healthy' : 'degraded';\n\n    return res.status(200).json({\n      success: true,\n      status,\n      tables: {\n        total: tables.length,\n        available: availableTables,\n        missing: missingTables\n      },\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    logger.error('Health check D1 falhou:', error);\n    return res.status(503).json({\n      success: false,\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: Date.now()\n    });\n  }\n};\n\nexport default {\n  validateD1Connection,\n  testD1Connection,\n  d1HealthCheck\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\database.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\documentValidation.js",
    "messages": [
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Parsing error: 'await' is only allowed within async functions and at the top levels of modules.",
        "line": 183,
        "column": 25,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import axios from 'axios';\nimport logger from '../utils/logger.js';\n\n// FunÃ§Ã£o para validar CPF\nexport const validateCPF = cpf => {\n  // Remove caracteres nÃ£o numÃ©ricos\n  cpf = cpf.replace(/[^\\d]/g, '');\n\n  // Verifica se tem 11 dÃ­gitos\n  if (cpf.length !== 11) {\n    return false;\n  }\n\n  // Verifica se todos os dÃ­gitos sÃ£o iguais\n  if (/^(\\d)\\1+$/.test(cpf)) {\n    return false;\n  }\n\n  // ValidaÃ§Ã£o do primeiro dÃ­gito verificador\n  let sum = 0;\n  for (let i = 0; i < 9; i++) {\n    sum += parseInt(cpf.charAt(i, 10), 10) * (10 - i);\n  }\n  let remainder = 11 - (sum % 11);\n  const digit1 = remainder < 2 ? 0 : remainder;\n\n  // ValidaÃ§Ã£o do segundo dÃ­gito verificador\n  sum = 0;\n  for (let i = 0; i < 10; i++) {\n    sum += parseInt(cpf.charAt(i, 10), 10) * (11 - i);\n  }\n  remainder = 11 - (sum % 11);\n  const digit2 = remainder < 2 ? 0 : remainder;\n\n  // Verifica se os dÃ­gitos verificadores estÃ£o corretos\n  return parseInt(cpf.charAt(9, 10), 10) === digit1 && parseInt(cpf.charAt(10, 10), 10) === digit2;\n};\n\n// FunÃ§Ã£o para validar CNPJ\nexport const validateCNPJ = cnpj => {\n  // Remove caracteres nÃ£o numÃ©ricos\n  cnpj = cnpj.replace(/[^\\d]/g, '');\n\n  // Verifica se tem 14 dÃ­gitos\n  if (cnpj.length !== 14) {\n    return false;\n  }\n\n  // Verifica se todos os dÃ­gitos sÃ£o iguais\n  if (/^(\\d)\\1+$/.test(cnpj)) {\n    return false;\n  }\n\n  // ValidaÃ§Ã£o do primeiro dÃ­gito verificador\n  let size = cnpj.length - 2;\n  let numbers = cnpj.substring(0, size);\n  const digits = cnpj.substring(size);\n  let sum = 0;\n  let pos = size - 7;\n\n  for (let i = size; i >= 1; i--) {\n    sum += parseInt(numbers.charAt(size - i, 10), 10) * pos--;\n    if (pos < 2) {\n      pos = 9;\n    }\n  }\n\n  let result = sum % 11 < 2 ? 0 : 11 - (sum % 11);\n  if (result !== parseInt(digits.charAt(0, 10), 10)) {\n    return false;\n  }\n\n  // ValidaÃ§Ã£o do segundo dÃ­gito verificador\n  size = size + 1;\n  numbers = cnpj.substring(0, size);\n  sum = 0;\n  pos = size - 7;\n\n  for (let i = size; i >= 1; i--) {\n    sum += parseInt(numbers.charAt(size - i, 10), 10) * pos--;\n    if (pos < 2) {\n      pos = 9;\n    }\n  }\n\n  result = sum % 11 < 2 ? 0 : 11 - (sum % 11);\n  if (result !== parseInt(digits.charAt(1, 10), 10)) {\n    return false;\n  }\n\n  return true;\n};\n\n// FunÃ§Ã£o para validar documento (CPF ou CNPJ)\nexport const validateDocument = document => {\n  const cleanDoc = document.replace(/[^\\d]/g, '');\n\n  if (cleanDoc.length === 11) {\n    return validateCPF(cleanDoc);\n  } else if (cleanDoc.length === 14) {\n    return validateCNPJ(cleanDoc);\n  }\n\n  return false;\n};\n\n// Middleware para validar CPF/CNPJ na Receita Federal\nexport const validateReceitaFederal = async (req, res, next) => {\n  try {\n    const { cpfCnpj } = req.body;\n\n    if (!cpfCnpj) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF/CNPJ Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Primeiro, validar formato localmente\n    if (!validateDocument(cpfCnpj)) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF/CNPJ invÃ¡lido'\n      });\n    }\n\n    // Se estiver em ambiente de produÃ§Ã£o, validar na Receita Federal\n    if (process.env.NODE_ENV === 'production') {\n      try {\n        // Aqui vocÃª pode integrar com a API da Receita Federal\n        // Por enquanto, vamos simular uma validaÃ§Ã£o\n        const isValid = await validateWithReceitaFederal(cpfCnpj);\n\n        if (!isValid) {\n          return res.status(400).json({\n            success: false,\n            message: 'CPF/CNPJ nÃ£o encontrado na Receita Federal'\n          });\n        }\n      } catch (error) {\n        logger.warn('Erro ao validar na Receita Federal:', error.message);\n      }\n    }\n\n    return next();\n  } catch (error) {\n    logger.error('Erro na validação da Receita Federal:', error);\n    return res.status(500).json({\n      success: false,\n      message: 'Erro na validação do documento'\n    });\n  }\n};\n\n// Função para validar com a Receita Federal (implementar conforme API disponível)\n// eslint-disable-next-line require-await\nfunction validateWithReceitaFederal(_document) {\n  // Stub: implementar integração real quando a API estiver disponível.\n  // Mantemos função para permitir await no chamador.\n  return true;\n}\n\n// Middleware para validar endereÃ§o via API IBGE\nexport const validateAddressIBGE = (req, res, next) => {\n  try {\n    const { address } = req.body;\n\n    if (!address || !address.zipCode) {\n      return next(); // CEP é opcional para validação\n    }\n\n    const cep = address.zipCode.replace(/\\D/g, '');\n\n    if (cep.length !== 8) {\n      return res.status(400).json({\n        success: false,\n        message: 'CEP invÃ¡lido'\n      });\n    }\n\n    try {\n      // Consultar CEP via API IBGE ou ViaCEP\n      const response = await axios.get(`https://viacep.com.br/ws/${cep}/json/`);\n\n      if (response.data.erro) {\n        return res.status(400).json({\n          success: false,\n          message: 'CEP nÃ£o encontrado'\n        });\n      }\n\n      // Atualizar endereÃ§o com dados da API\n      req.body.address = {\n        ...address,\n        street: response.data.logradouro || address.street,\n        neighborhood: response.data.bairro || address.neighborhood,\n        city: response.data.localidade || address.city,\n        state: response.data.uf || address.state,\n        zipCode: cep\n      };\n    } catch (error) {\n      logger.warn('Erro ao consultar CEP:', error.message);\n      // Em caso de erro na API, continuar com dados fornecidos\n    }\n\n    return next();\n  } catch (error) {\n    logger.error('Erro na validação de endereço:', error);\n    return res.status(500).json({\n      success: false,\n      message: 'Erro na validação de endereço'\n    });\n  }\n};\n\n// Middleware para validar documentos obrigatÃ³rios\nexport const validateRequiredDocuments = (req, res, next) => {\n  try {\n    const { documents } = req.body;\n\n    if (!documents || !Array.isArray(documents) || documents.length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Pelo menos um documento Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Validar se cada documento tem os campos obrigatÃ³rios\n    for (const doc of documents) {\n      if (!doc.type || !doc.filename || !doc.url) {\n        return res.status(400).json({\n          success: false,\n          message: 'Todos os documentos devem ter tipo, nome do arquivo e URL'\n        });\n      }\n\n      // Validar tipo de documento\n      const validTypes = ['cpf', 'cnpj', 'ie', 'address_proof', 'identity', 'other'];\n      if (!validTypes.includes(doc.type)) {\n        return res.status(400).json({\n          success: false,\n          message: 'Tipo de documento invÃ¡lido'\n        });\n      }\n    }\n\n    return next();\n  } catch (error) {\n    logger.error('Erro na validação de documentos:', error);\n    return res.status(500).json({\n      success: false,\n      message: 'Erro na validação de documentos'\n    });\n  }\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\errorHandler.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'next' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 3,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const logger = require('../utils/logger');\n\nconst errorHandler = (err, req, res, next) => {\n  let error = { ...err };\n  error.message = err.message;\n\n  // Log do erro\n  logger.error('Erro capturado:', {\n    message: err.message,\n    stack: err.stack,\n    url: req.originalUrl,\n    method: req.method,\n    ip: req.ip,\n    userAgent: req.get('User-Agent')\n  });\n\n  // Erro de validaÃ§Ã£o do Mongoose\n  if (err.name === 'ValidationError') {\n    const message = Object.values(err.errors)\n      .map(val => val.message)\n      .join(', ');\n    error = {\n      message,\n      statusCode: 400\n    };\n  }\n\n  // Erro de cast do Mongoose (ID invÃ¡lido)\n  if (err.name === 'CastError') {\n    const message = 'Recurso nÃ£o encontrado';\n    error = {\n      message,\n      statusCode: 404\n    };\n  }\n\n  // Erro de duplicaÃ§Ã£o do Mongoose\n  if (err.code === 11000) {\n    const field = Object.keys(err.keyValue)[0];\n    const message = `${field} jÃ¡ existe`;\n    error = {\n      message,\n      statusCode: 400\n    };\n  }\n\n  // Erro JWT\n  if (err.name === 'JsonWebTokenError') {\n    const message = 'Token invÃ¡lido';\n    error = {\n      message,\n      statusCode: 401\n    };\n  }\n\n  // Erro JWT expirado\n  if (err.name === 'TokenExpiredError') {\n    const message = 'Token expirado';\n    error = {\n      message,\n      statusCode: 401\n    };\n  }\n\n  // Erro de limite de taxa\n  if (err.statusCode === 429) {\n    const message = 'Muitas tentativas. Tente novamente mais tarde.';\n    error = {\n      message,\n      statusCode: 429\n    };\n  }\n\n  // Erro de upload de arquivo\n  if (err.code === 'LIMIT_FILE_SIZE') {\n    const message = 'Arquivo muito grande';\n    error = {\n      message,\n      statusCode: 400\n    };\n  }\n\n  // Erro de tipo de arquivo\n  if (err.code === 'LIMIT_UNEXPECTED_FILE') {\n    const message = 'Tipo de arquivo nÃ£o permitido';\n    error = {\n      message,\n      statusCode: 400\n    };\n  }\n\n  // Erro de conexÃ£o com banco de dados\n  if (err.name === 'MongoNetworkError') {\n    const message = 'Erro de conexÃ£o com o banco de dados';\n    error = {\n      message,\n      statusCode: 503\n    };\n  }\n\n  // Erro de timeout\n  if (err.name === 'MongoTimeoutError') {\n    const message = 'Timeout na operaÃ§Ã£o do banco de dados';\n    error = {\n      message,\n      statusCode: 504\n    };\n  }\n\n  // Erro de Stripe\n  if (err.type && err.type.startsWith('Stripe')) {\n    const message = 'Erro no processamento do pagamento';\n    error = {\n      message,\n      statusCode: 400\n    };\n  }\n\n  // Erro de Web3/Ethereum\n  if (err.code && err.code.startsWith('UNPREDICTABLE_GAS_LIMIT')) {\n    const message = 'Erro na transaÃ§Ã£o blockchain';\n    error = {\n      message,\n      statusCode: 400\n    };\n  }\n\n  // Status code padrÃ£o\n  const statusCode = error.statusCode || 500;\n\n  // Resposta de erro\n  res.status(statusCode).json({\n    success: false,\n    message: error.message || 'Erro interno do servidor',\n    ...(process.env.NODE_ENV === 'development' && {\n      stack: err.stack,\n      error: err\n    })\n  });\n};\n\nmodule.exports = errorHandler;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\logging.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\metamaskAuth.js",
    "messages": [
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 50,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 50,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 92,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 92,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 95,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 95,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const logger = require('../utils/logger');\n\n/**\n * Middleware para validar a ID da Metamask nas requisiÃ§Ãµes\n * Este middleware verifica se o header 'x-metamask-id' estÃ¡ presente\n * e se corresponde ao ID autorizado\n */\nconst validateMetamaskId = (req, res, next) => {\n  try {\n    // Obter a ID da Metamask do header\n    const metamaskId = req.headers['x-metamask-id'];\n\n    // ID da Metamask autorizada (deve ser configurada via variÃ¡vel de ambiente)\n    const authorizedMetamaskId =\n      process.env.METAMASK_ID || '0x5Ea5C5970e8AE23A5336d631707CF31C5916E8b1';\n\n    // Verificar se o header estÃ¡ presente\n    if (!metamaskId) {\n      logger.warn(`RequisiÃ§Ã£o sem Metamask ID: ${req.method} ${req.originalUrl} - IP: ${req.ip}`);\n\n      return res.status(401).json({\n        success: false,\n        error: 'Metamask ID nÃ£o fornecido',\n        message: 'Header x-metamask-id Ã© obrigatÃ³rio para autenticaÃ§Ã£o'\n      });\n    }\n\n    // Verificar se a ID corresponde Ã  autorizada\n    if (metamaskId !== authorizedMetamaskId) {\n      logger.warn(\n        `Tentativa de acesso com Metamask ID invÃ¡lido: ${metamaskId} - IP: ${req.ip} - URL: ${req.originalUrl}`\n      );\n\n      return res.status(403).json({\n        success: false,\n        error: 'Metamask ID invÃ¡lido',\n        message: 'ID da Metamask nÃ£o autorizado para acessar este recurso'\n      });\n    }\n\n    // ID vÃ¡lida, continuar\n    logger.info(\n      `RequisiÃ§Ã£o autenticada com Metamask ID: ${metamaskId} - ${req.method} ${req.originalUrl}`\n    );\n\n    // Adicionar informaÃ§Ãµes da Metamask ao request para uso posterior\n    req.metamaskId = metamaskId;\n    req.isAuthenticated = true;\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de validaÃ§Ã£o da Metamask ID:', error);\n\n    return res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor durante validaÃ§Ã£o da Metamask ID'\n    });\n  }\n};\n\n/**\n * Middleware opcional para validar a ID da Metamask\n * NÃ£o falha se a ID nÃ£o estiver presente, mas valida se estiver\n */\nconst optionalMetamaskAuth = (req, res, next) => {\n  try {\n    const metamaskId = req.headers['x-metamask-id'];\n    const authorizedMetamaskId =\n      process.env.METAMASK_ID || '0x5Ea5C5970e8AE23A5336d631707CF31C5916E8b1';\n\n    if (metamaskId) {\n      if (metamaskId !== authorizedMetamaskId) {\n        logger.warn(\n          `Metamask ID invÃ¡lido em requisiÃ§Ã£o opcional: ${metamaskId} - IP: ${req.ip}`\n        );\n\n        return res.status(403).json({\n          success: false,\n          error: 'Metamask ID invÃ¡lido',\n          message: 'ID da Metamask nÃ£o autorizado'\n        });\n      }\n\n      req.metamaskId = metamaskId;\n      req.isAuthenticated = true;\n      logger.info(`RequisiÃ§Ã£o opcional autenticada com Metamask ID: ${metamaskId}`);\n    } else {\n      req.isAuthenticated = false;\n      logger.info('RequisiÃ§Ã£o sem autenticaÃ§Ã£o Metamask (opcional)');\n    }\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware opcional de validaÃ§Ã£o da Metamask ID:', error);\n    next();\n  }\n};\n\n/**\n * Middleware para registrar tentativas de acesso\n */\nconst logMetamaskAccess = (req, res, next) => {\n  const metamaskId = req.headers['x-metamask-id'];\n  const ip = req.ip || req.connection.remoteAddress;\n  const userAgent = req.get('User-Agent');\n  const timestamp = new Date().toISOString();\n\n  logger.info(\n    `Tentativa de acesso - Metamask ID: ${metamaskId || 'N/A'} - IP: ${ip} - User-Agent: ${userAgent} - Timestamp: ${timestamp}`\n  );\n\n  next();\n};\n\nmodule.exports = {\n  validateMetamaskId,\n  optionalMetamaskAuth,\n  logMetamaskAccess\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\notFound.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\notificationTriggers.js",
    "messages": [
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 10,
        "column": 60,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 10,
        "endColumn": 62
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 34,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 34,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 37,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 37,
        "endColumn": 11
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 42,
        "column": 56,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 42,
        "endColumn": 58
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 61,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 61,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 64,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 64,
        "endColumn": 11
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 69,
        "column": 58,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 69,
        "endColumn": 60
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 92,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 92,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 95,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 95,
        "endColumn": 11
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 100,
        "column": 61,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 100,
        "endColumn": 63
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 119,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 119,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 122,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 122,
        "endColumn": 11
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 127,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 127,
        "endColumn": 61
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 146,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 146,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 149,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 149,
        "endColumn": 11
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 154,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 154,
        "endColumn": 55
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 178,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 178,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 181,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 181,
        "endColumn": 11
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 186,
        "column": 66,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 186,
        "endColumn": 68
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 205,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 205,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 208,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 208,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 217,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 217,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 220,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 220,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 23,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import notificationService from '../services/notificationService.js';\nimport logger from '../utils/logger.js';\n\n/**\n * Middleware para disparar notificaÃ§Ãµes automÃ¡ticas\n * Este middleware deve ser usado apÃ³s operaÃ§Ãµes que geram eventos\n */\n\n// Middleware para notificar nova transaÃ§Ã£o\nexport const notifyNewTransaction = async (req, res, next) => {\n  try {\n    // Salvar a resposta original\n    const originalJson = res.json;\n\n    // Sobrescrever o mÃ©todo json para interceptar a resposta\n    res.json = function (data) {\n      // Se a transaÃ§Ã£o foi criada com sucesso, disparar notificaÃ§Ã£o\n      if (data.success && data.data && data.data._id) {\n        // Disparar notificaÃ§Ã£o de forma assÃ­ncrona (nÃ£o bloquear a resposta)\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyNewTransaction(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de nova transaÃ§Ã£o:', error);\n          }\n        });\n      }\n\n      // Restaurar o mÃ©todo original e chamar\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de transaÃ§Ã£o:', error);\n    next();\n  }\n};\n\n// Middleware para notificar nova mensagem\nexport const notifyNewMessage = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data._id) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyNewMessage(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de nova mensagem:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de mensagem:', error);\n    next();\n  }\n};\n\n// Middleware para notificar mudanÃ§a de status\nexport const notifyStatusChange = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.oldStatus && data.data.newStatus) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyStatusChange(\n              data.data.transaction,\n              data.data.oldStatus,\n              data.data.newStatus\n            );\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de mudanÃ§a de status:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de mudanÃ§a de status:', error);\n    next();\n  }\n};\n\n// Middleware para notificar pagamento recebido\nexport const notifyPaymentReceived = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.status === 'COMPLETED') {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyPaymentReceived(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de pagamento recebido:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de pagamento:', error);\n    next();\n  }\n};\n\n// Middleware para notificar falha no pagamento\nexport const notifyPaymentFailed = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.status === 'FAILED') {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyPaymentFailed(data.data);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de falha no pagamento:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de falha no pagamento:', error);\n    next();\n  }\n};\n\n// Middleware para notificar boas-vindas (apÃ³s registro)\nexport const notifyWelcome = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (\n        data.success &&\n        data.data &&\n        data.data.user &&\n        data.data.requiresEmailVerification === false\n      ) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyWelcome(data.data.user);\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de boas-vindas:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de boas-vindas:', error);\n    next();\n  }\n};\n\n// Middleware para notificar verificaÃ§Ã£o necessÃ¡ria\nexport const notifyVerificationRequired = async (req, res, next) => {\n  try {\n    const originalJson = res.json;\n\n    res.json = function (data) {\n      if (data.success && data.data && data.data.requiresEmailVerification === true) {\n        setImmediate(async () => {\n          try {\n            await notificationService.notifyVerificationRequired(data.data.user, 'email');\n          } catch (error) {\n            logger.error('Erro ao disparar notificaÃ§Ã£o de verificaÃ§Ã£o necessÃ¡ria:', error);\n          }\n        });\n      }\n\n      res.json = originalJson;\n      return originalJson.call(this, data);\n    };\n\n    next();\n  } catch (error) {\n    logger.error('Erro no middleware de notificaÃ§Ã£o de verificaÃ§Ã£o necessÃ¡ria:', error);\n    next();\n  }\n};\n\n// Middleware para verificar planos expirando (executar periodicamente)\nexport const checkExpiringPlans = (req, res, next) => {\n  try {\n    // Este middleware pode ser usado para verificar planos expirando\n    // em rotas especÃ­ficas ou executado periodicamente\n    next();\n  } catch (error) {\n    logger.error('Erro ao verificar planos expirando:', error);\n    next();\n  }\n};\n\n// FunÃ§Ã£o para verificar planos expirando (executar via cron job)\nexport const checkExpiringPlansJob = () => {\n  try {\n    // Esta funÃ§Ã£o deve ser executada diariamente via cron job\n    // para verificar usuÃ¡rios com planos expirando\n    if (process.env.NODE_ENV !== 'production') {\n      logger.info('Verificando planos expirando...');\n    }\n    // Implementar lÃ³gica para buscar usuÃ¡rios com planos expirando\n    // e disparar notificaÃ§Ãµes apropriadas\n  } catch (error) {\n    logger.error('Erro ao verificar planos expirando:', error);\n  }\n};\n\nexport default {\n  notifyNewTransaction,\n  notifyNewMessage,\n  notifyStatusChange,\n  notifyPaymentReceived,\n  notifyPaymentFailed,\n  notifyWelcome,\n  notifyVerificationRequired,\n  checkExpiringPlans,\n  checkExpiringPlansJob\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\privacyMiddleware.js",
    "messages": [
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 41,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 41,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 46,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 46,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 88,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 88,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 125,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 125,
        "endColumn": 13
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Parsing error: 'await' is only allowed within async functions and at the top levels of modules.",
        "line": 148,
        "column": 19,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import { createAuditLog } from '../utils/securityLogger.js';\nimport User from '../models/User.js';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport Message from '../models/Message.js';\nimport Transaction from '../models/Transaction.js';\nimport Payment from '../models/Payment.js';\n\nimport logger from '../utils/logger.js';\n// ===== MIDDLEWARE DE PRIVACIDADE LGPD =====\n\n/**\n * Middleware para verificar consentimento LGPD\n */\nexport const checkGDPRConsent = (req, res, next) => {\n  try {\n    if (!req.user) {\n      return next();\n    }\n\n    // Verificar se usuÃ¡rio deu consentimento LGPD\n    if (!req.user.gdprConsent) {\n      return res.status(403).json({\n        success: false,\n        message: 'Consentimento LGPD necessÃ¡rio para continuar',\n        requiresConsent: true,\n        consentUrl: '/privacy/consent'\n      });\n    }\n\n    // Verificar se consentimento nÃ£o expirou\n    if (req.user.gdprConsentExpiry && new Date() > new Date(req.user.gdprConsentExpiry)) {\n      return res.status(403).json({\n        success: false,\n        message: 'Consentimento LGPD expirado. Renove seu consentimento.',\n        requiresConsent: true,\n        consentUrl: '/privacy/consent'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na verificaÃ§Ã£o LGPD:', error);\n    }\n    next();\n  }\n};\n\n/**\n * Middleware para registrar consentimento LGPD\n */\nexport const recordGDPRConsent = async (req, res, next) => {\n  try {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o autenticado'\n      });\n    }\n\n    const { consent, preferences } = req.body;\n\n    if (!consent) {\n      return res.status(400).json({\n        success: false,\n        message: 'Consentimento Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Atualizar usuÃ¡rio com consentimento\n    const user = await User.findById(req.user.userId);\n    user.gdprConsent = consent;\n    user.gdprConsentDate = new Date();\n    user.gdprConsentExpiry = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // 1 ano\n    user.gdprPreferences = preferences || {};\n\n    await user.save();\n\n    // Log do consentimento\n    await createAuditLog('GDPR_CONSENT_GIVEN', 'user_privacy', req, req.user.userId, {\n      consent,\n      preferences,\n      ipAddress: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao registrar consentimento LGPD:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao registrar consentimento'\n    });\n  }\n};\n\n/**\n * Middleware para verificar se dados podem ser processados\n */\nexport const canProcessData = dataType => {\n  return async (req, res, next) => {\n    try {\n      if (!req.user) {\n        return res.status(401).json({\n          success: false,\n          message: 'UsuÃ¡rio nÃ£o autenticado'\n        });\n      }\n\n      const user = await User.findById(req.user.userId);\n\n      // Verificar se usuÃ¡rio deu consentimento para o tipo de dado\n      if (!user.gdprConsent || !user.gdprPreferences[dataType]) {\n        return res.status(403).json({\n          success: false,\n          message: `Consentimento necessÃ¡rio para processamento de ${dataType}`,\n          requiresConsent: true,\n          dataType\n        });\n      }\n\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro na verificaÃ§Ã£o de processamento de dados:', error);\n      }\n      return res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  };\n};\n\n// ===== FUNÃ‡Ã•ES DE EXPORTAÃ‡ÃƒO DE DADOS =====\n\n/**\n * Exportar dados do usuÃ¡rio (Direito de Portabilidade)\n */\nexport const exportUserData = (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar todos os dados do usuÃ¡rio\n    const user = await User.findById(userId).select('-password -resetToken -resetTokenExpiry');\n    const products = await Product.find({ seller: userId });\n    const freights = await Freight.find({ carrier: userId });\n    const messages = await Message.find({\n      $or: [{ sender: userId }, { recipient: userId }]\n    });\n    const transactions = await Transaction.find({\n      $or: [{ buyer: userId }, { seller: userId }]\n    });\n    const payments = await Payment.find({ userId });\n\n    // Estruturar dados para exportaÃ§Ã£o\n    const exportData = {\n      user: {\n        profile: {\n          email: user.email,\n          name: user.name,\n          phone: user.phone,\n          cpf: user.cpf,\n          cnpj: user.cnpj,\n          role: user.role,\n          createdAt: user.createdAt,\n          lastLogin: user.lastLogin\n        },\n        preferences: user.preferences,\n        gdprConsent: {\n          consent: user.gdprConsent,\n          date: user.gdprConsentDate,\n          preferences: user.gdprPreferences\n        }\n      },\n      products: products.map(p => ({\n        id: p._id,\n        name: p.name,\n        description: p.description,\n        price: p.price,\n        category: p.category,\n        location: p.location,\n        createdAt: p.createdAt,\n        status: p.status\n      })),\n      freights: freights.map(f => ({\n        id: f._id,\n        origin: f.origin,\n        destination: f.destination,\n        price: f.price,\n        vehicle: f.vehicle,\n        createdAt: f.createdAt,\n        status: f.status\n      })),\n      messages: messages.map(m => ({\n        id: m._id,\n        content: m.content,\n        sender: m.sender,\n        recipient: m.recipient,\n        timestamp: m.timestamp,\n        read: m.read\n      })),\n      transactions: transactions.map(t => ({\n        id: t._id,\n        product: t.product,\n        buyer: t.buyer,\n        seller: t.seller,\n        amount: t.amount,\n        status: t.status,\n        createdAt: t.createdAt\n      })),\n      payments: payments.map(p => ({\n        id: p._id,\n        amount: p.amount,\n        method: p.method,\n        status: p.status,\n        createdAt: p.createdAt\n      })),\n      exportInfo: {\n        exportedAt: new Date(),\n        dataTypes: ['profile', 'products', 'freights', 'messages', 'transactions', 'payments'],\n        format: 'JSON',\n        version: '1.0'\n      }\n    };\n\n    // Log da exportaÃ§Ã£o\n    await createAuditLog('DATA_EXPORT_REQUESTED', 'user_data', req, userId, {\n      dataTypes: exportData.exportInfo.dataTypes,\n      exportFormat: 'JSON'\n    });\n\n    res.json({\n      success: true,\n      message: 'Dados exportados com sucesso',\n      data: exportData\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na exportaÃ§Ã£o de dados:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao exportar dados'\n    });\n  }\n};\n\n/**\n * Excluir dados do usuÃ¡rio (Direito ao Esquecimento)\n */\nexport const deleteUserData = async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { dataTypes, reason } = req.body;\n\n    if (!dataTypes || !Array.isArray(dataTypes)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipos de dados para exclusÃ£o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    if (!reason || reason.trim().length < 10) {\n      return res.status(400).json({\n        success: false,\n        message: 'Motivo da exclusÃ£o deve ter pelo menos 10 caracteres'\n      });\n    }\n\n    const deletionResults = {};\n\n    // Excluir produtos\n    if (dataTypes.includes('products')) {\n      const result = await Product.deleteMany({ seller: userId });\n      deletionResults.products = result.deletedCount;\n    }\n\n    // Excluir fretes\n    if (dataTypes.includes('freights')) {\n      const result = await Freight.deleteMany({ carrier: userId });\n      deletionResults.freights = result.deletedCount;\n    }\n\n    // Excluir mensagens\n    if (dataTypes.includes('messages')) {\n      const result = await Message.deleteMany({\n        $or: [{ sender: userId }, { recipient: userId }]\n      });\n      deletionResults.messages = result.deletedCount;\n    }\n\n    // Excluir transaÃ§Ãµes\n    if (dataTypes.includes('transactions')) {\n      const result = await Transaction.deleteMany({\n        $or: [{ buyer: userId }, { seller: userId }]\n      });\n      deletionResults.transactions = result.deletedCount;\n    }\n\n    // Excluir pagamentos\n    if (dataTypes.includes('payments')) {\n      const result = await Payment.deleteMany({ userId });\n      deletionResults.payments = result.deletedCount;\n    }\n\n    // Anonimizar perfil se solicitado\n    if (dataTypes.includes('profile')) {\n      await User.findByIdAndUpdate(userId, {\n        name: '[REMOVIDO]',\n        email: `removed_${Date.now()}@deleted.com`,\n        phone: '[REMOVIDO]',\n        cpf: '[REMOVIDO]',\n        cnpj: '[REMOVIDO]',\n        isActive: false,\n        gdprConsent: false,\n        dataDeletedAt: new Date(),\n        deletionReason: reason\n      });\n      deletionResults.profile = 'anonymized';\n    }\n\n    // Log da exclusÃ£o\n    await createAuditLog('DATA_DELETION_REQUESTED', 'user_data', req, userId, {\n      dataTypes,\n      reason,\n      deletionResults,\n      ipAddress: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'Dados excluÃ­dos com sucesso',\n      deletionResults,\n      dataTypes\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na exclusÃ£o de dados:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao excluir dados'\n    });\n  }\n};\n\n/**\n * Obter status de privacidade do usuÃ¡rio\n */\nexport const getPrivacyStatus = async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const user = await User.findById(userId).select(\n      'gdprConsent gdprConsentDate gdprConsentExpiry gdprPreferences dataDeletedAt'\n    );\n\n    const privacyStatus = {\n      hasConsent: !!user.gdprConsent,\n      consentDate: user.gdprConsentDate,\n      consentExpiry: user.gdprConsentExpiry,\n      preferences: user.gdprPreferences || {},\n      isDataDeleted: !!user.dataDeletedAt,\n      dataDeletedAt: user.dataDeletedAt,\n      rights: {\n        rightToAccess: true,\n        rightToPortability: true,\n        rightToRectification: true,\n        rightToErasure: true,\n        rightToRestriction: true,\n        rightToObject: true\n      }\n    };\n\n    res.json({\n      success: true,\n      privacyStatus\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter status de privacidade:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao obter status de privacidade'\n    });\n  }\n};\n\n/**\n * Atualizar preferÃªncias de privacidade\n */\nexport const updatePrivacyPreferences = (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { preferences } = req.body;\n\n    if (!preferences || typeof preferences !== 'object') {\n      return res.status(400).json({\n        success: false,\n        message: 'PreferÃªncias de privacidade sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    // Validar preferÃªncias\n    const validPreferences = [\n      'marketing_emails',\n      'push_notifications',\n      'sms_notifications',\n      'data_sharing',\n      'analytics_tracking',\n      'third_party_cookies'\n    ];\n\n    const validatedPreferences = {};\n    validPreferences.forEach(pref => {\n      if (Object.prototype.hasOwnProperty.call(preferences, pref)) {\n        validatedPreferences[pref] = !!preferences[pref];\n      }\n    });\n\n    // Atualizar usuÃ¡rio\n    await User.findByIdAndUpdate(userId, {\n      gdprPreferences: validatedPreferences,\n      gdprConsentDate: new Date()\n    });\n\n    // Log da atualizaÃ§Ã£o\n    await createAuditLog('PRIVACY_PREFERENCES_UPDATED', 'user_privacy', req, userId, {\n      preferences: validatedPreferences\n    });\n\n    res.json({\n      success: true,\n      message: 'PreferÃªncias de privacidade atualizadas',\n      preferences: validatedPreferences\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao atualizar preferÃªncias de privacidade:', error);\n    }\n    return res.status(500).json({\n      success: false,\n      message: 'Erro ao atualizar preferÃªncias'\n    });\n  }\n};\n\nexport default {\n  checkGDPRConsent,\n  recordGDPRConsent,\n  canProcessData,\n  exportUserData,\n  deleteUserData,\n  getPrivacyStatus,\n  updatePrivacyPreferences\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\rateLimit.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'req' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 186,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 186,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const rateLimit = require('express-rate-limit');\n\n/**\n * Middleware de rate limiting configurÃ¡vel\n * @param {Object} options - OpÃ§Ãµes de configuraÃ§Ã£o\n * @param {number} options.windowMs - Janela de tempo em milissegundos\n * @param {number} options.max - MÃ¡ximo de requests por janela\n * @param {string} options.message - Mensagem de erro personalizada\n * @param {boolean} options.standardHeaders - Incluir headers padrÃ£o\n * @param {boolean} options.legacyHeaders - Incluir headers legados\n * @returns {Function} Middleware de rate limiting\n */\nconst createRateLimit = (options = {}) => {\n  const defaultOptions = {\n    windowMs: 15 * 60 * 1000, // 15 minutos por padrÃ£o\n    max: 100, // 100 requests por padrÃ£o\n    message: {\n      success: false,\n      message: 'Muitas requisiÃ§Ãµes. Tente novamente mais tarde.',\n      retryAfter: Math.ceil(options.windowMs / 1000)\n    },\n    standardHeaders: true, // Retorna `RateLimit-*` headers\n    legacyHeaders: false, // Retorna `X-RateLimit-*` headers\n    handler: (req, res) => {\n      res.status(429).json(\n        options.message || {\n          success: false,\n          message: 'Muitas requisiÃ§Ãµes. Tente novamente mais tarde.'\n        }\n      );\n    },\n    skip: req => {\n      // Pular rate limiting para IPs locais em desenvolvimento\n      if (process.env.NODE_ENV === 'development') {\n        const localIPs = ['127.0.0.1', '::1', 'localhost'];\n        return localIPs.includes(req.ip);\n      }\n      return false;\n    },\n    keyGenerator: req => {\n      // Usar IP do cliente ou user ID se autenticado\n      return req.user ? req.user.userId : req.ip;\n    }\n  };\n\n  return rateLimit({ ...defaultOptions, ...options });\n};\n\n// Rate limiters prÃ©-configurados para diferentes cenÃ¡rios\n\n/**\n * Rate limiter para APIs pÃºblicas (mais permissivo)\n */\nconst publicAPILimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 200, // 200 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes atingido para APIs pÃºblicas. Tente novamente em 15 minutos.'\n  }\n});\n\n/**\n * Rate limiter para autenticaÃ§Ã£o (mais restritivo)\n */\nconst authLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 10, // 10 tentativas de login por 15 minutos\n  message: {\n    success: false,\n    message: 'Muitas tentativas de login. Tente novamente em 15 minutos.',\n    security: 'Sua conta pode ser temporariamente bloqueada por seguranÃ§a.'\n  }\n});\n\n/**\n * Rate limiter para pagamentos (muito restritivo)\n */\nconst paymentLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 5, // 5 tentativas de pagamento por 15 minutos\n  message: {\n    success: false,\n    message: 'Muitas tentativas de pagamento. Tente novamente em 15 minutos.',\n    security: 'Por seguranÃ§a, suas tentativas de pagamento foram limitadas.'\n  }\n});\n\n/**\n * Rate limiter para uploads de arquivos\n */\nconst uploadLimiter = createRateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hora\n  max: 20, // 20 uploads por hora\n  message: {\n    success: false,\n    message: 'Limite de uploads atingido. Tente novamente em 1 hora.'\n  }\n});\n\n/**\n * Rate limiter para mensagens (moderado)\n */\nconst messagingLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 50, // 50 mensagens por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de mensagens atingido. Tente novamente em 15 minutos.'\n  }\n});\n\n/**\n * Rate limiter para busca e consultas (moderado)\n */\nconst searchLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 100, // 100 buscas por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de buscas atingido. Tente novamente em 15 minutos.'\n  }\n});\n\n/**\n * Rate limiter para webhooks (muito permissivo para serviÃ§os externos)\n */\nconst webhookLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 1000, // 1000 webhooks por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de webhooks atingido.'\n  },\n  skip: req => {\n    // Pular rate limiting para webhooks de serviÃ§os confiÃ¡veis\n    const trustedWebhooks = ['stripe.com', 'github.com', 'gitlab.com', 'bitbucket.org'];\n\n    const origin = req.get('Origin') || req.get('User-Agent') || '';\n    return trustedWebhooks.some(trusted => origin.includes(trusted));\n  }\n});\n\n/**\n * Rate limiter para admin (muito permissivo)\n */\nconst adminLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 500, // 500 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes admin atingido.'\n  },\n  skip: req => {\n    // Pular rate limiting para usuÃ¡rios admin\n    return req.user && req.user.role === 'admin';\n  }\n});\n\n/**\n * Rate limiter para usuÃ¡rios premium (mais permissivo)\n */\nconst premiumLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 300, // 300 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes atingido para usuÃ¡rios premium.'\n  },\n  skip: req => {\n    // Pular rate limiting para usuÃ¡rios premium\n    return req.user && req.user.isPaid && req.user.planActive;\n  }\n});\n\n/**\n * Rate limiter para desenvolvimento (muito permissivo)\n */\nconst devLimiter = createRateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 1000, // 1000 requests por 15 minutos\n  message: {\n    success: false,\n    message: 'Limite de requisiÃ§Ãµes atingido em desenvolvimento.'\n  },\n  skip: req => {\n    // Pular rate limiting em desenvolvimento\n    return process.env.NODE_ENV === 'development';\n  }\n});\n\n/**\n * Rate limiter personalizado baseado em headers especÃ­ficos\n */\nconst headerBasedLimiter = (headerName, maxRequests) => {\n  return createRateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutos\n    max: maxRequests,\n    keyGenerator: req => {\n      return req.get(headerName) || req.ip;\n    },\n    message: {\n      success: false,\n      message: `Limite de requisiÃ§Ãµes atingido para ${headerName}.`\n    }\n  });\n};\n\n/**\n * Rate limiter para diferentes tipos de usuÃ¡rio\n */\nconst userTypeLimiter = {\n  guest: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 50,\n    message: {\n      success: false,\n      message:\n        'Limite de requisiÃ§Ãµes para visitantes atingido. FaÃ§a login para aumentar o limite.'\n    }\n  }),\n\n  basic: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 150,\n    message: {\n      success: false,\n      message: 'Limite de requisiÃ§Ãµes para usuÃ¡rios bÃ¡sicos atingido.'\n    }\n  }),\n\n  premium: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 300,\n    message: {\n      success: false,\n      message: 'Limite de requisiÃ§Ãµes para usuÃ¡rios premium atingido.'\n    }\n  }),\n\n  admin: createRateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 500,\n    message: {\n      success: false,\n      message: 'Limite de requisiÃ§Ãµes para administradores atingido.'\n    }\n  })\n};\n\n/**\n * FunÃ§Ã£o para aplicar rate limiting baseado no tipo de usuÃ¡rio\n */\nconst applyUserTypeLimiting = (req, res, next) => {\n  let limiter;\n\n  if (!req.user) {\n    limiter = userTypeLimiter.guest;\n  } else if (req.user.role === 'admin') {\n    limiter = userTypeLimiter.admin;\n  } else if (req.user.isPaid && req.user.planActive) {\n    limiter = userTypeLimiter.premium;\n  } else {\n    limiter = userTypeLimiter.basic;\n  }\n\n  limiter(req, res, next);\n};\n\nmodule.exports = {\n  createRateLimit,\n  publicAPILimiter,\n  authLimiter,\n  paymentLimiter,\n  uploadLimiter,\n  messagingLimiter,\n  searchLimiter,\n  webhookLimiter,\n  adminLimiter,\n  premiumLimiter,\n  devLimiter,\n  headerBasedLimiter,\n  userTypeLimiter,\n  applyUserTypeLimiting\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\rateLimiter.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\requirePaidAccess.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'createSecurityLog' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 3,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 27
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 74,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 74,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import User from '../models/User.js';\nimport AuditLog from '../models/AuditLog.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\n\nimport logger from '../utils/logger.js';\n// Middleware para verificar se o usuÃ¡rio tem acesso pago\nconst requirePaidAccess = serviceType => {\n  return async (req, res, next) => {\n    try {\n      const userId = req.user.id;\n\n      // Verificar se o usuÃ¡rio existe\n      const user = await User.findById(userId);\n      if (!user) {\n        return res.status(404).json({\n          success: false,\n          message: 'UsuÃ¡rio nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se tem plano ativo\n      const hasActivePlan =\n        user.subscriptions &&\n        ((user.subscriptions.store && user.subscriptions.store.status === 'active') ||\n          (user.subscriptions.agroconecta && user.subscriptions.agroconecta.status === 'active'));\n\n      // Verificar se tem pagamento recente (Ãºltimos 30 dias)\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const recentPayment =\n        user.payments &&\n        user.payments.some(\n          payment => payment.status === 'completed' && new Date(payment.createdAt) >= thirtyDaysAgo\n        );\n\n      if (!hasActivePlan && !recentPayment) {\n        // Log da tentativa de acesso sem pagamento\n        await AuditLog.logAction({\n          userId,\n          userEmail: user.email,\n          action: 'PAID_ACCESS_DENIED',\n          resource: req.originalUrl,\n          details: `Attempted to access ${serviceType} without paid access`,\n          ip: req.ip,\n          userAgent: req.get('User-Agent'),\n          isSuspicious: false,\n          riskLevel: 'LOW'\n        });\n\n        return res.status(403).json({\n          success: false,\n          message: 'ðŸ”’ Para acessar este serviÃ§o, finalize o pagamento de sua assinatura.',\n          requiresPayment: true,\n          plans: {\n            store: 'R$25/mÃªs - Mensageria de Produtos',\n            agroconecta: 'R$50/mÃªs - Mensageria de Fretes'\n          }\n        });\n      }\n\n      // Log do acesso bem-sucedido\n      await AuditLog.logAction({\n        userId,\n        userEmail: user.email,\n        action: 'PAID_ACCESS_GRANTED',\n        resource: req.originalUrl,\n        details: `Accessed ${serviceType} with paid access`,\n        ip: req.ip,\n        userAgent: req.get('User-Agent')\n      });\n\n      req.userHasPaidAccess = true;\n      next();\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao verificar acesso pago:', error);\n      }\n      // Log do erro\n      await AuditLog.logAction({\n        userId: req.user?.id || 'unknown',\n        userEmail: req.user?.email || 'unknown',\n        action: 'PAID_ACCESS_ERROR',\n        resource: req.originalUrl,\n        details: `Error checking paid access: ${error.message}`,\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        isSuspicious: false,\n        riskLevel: 'LOW'\n      });\n\n      return res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  };\n};\n\n// Middleware especÃ­fico para mensageria de produtos\nconst requireProductMessagingAccess = requirePaidAccess('product_messaging');\n\n// Middleware especÃ­fico para mensageria de fretes\nconst requireFreightMessagingAccess = requirePaidAccess('freight_messaging');\n\n// Middleware para serviÃ§os premium\nconst requireServiceAccess = requirePaidAccess('premium_service');\n\nexport {\n  requirePaidAccess,\n  requireProductMessagingAccess,\n  requireFreightMessagingAccess,\n  requireServiceAccess\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\security.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'express' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 15
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'body' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 14
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'validationResult' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 32
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'AuditLog' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 9,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 18
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Parsing error: 'await' is only allowed within async functions and at the top levels of modules.",
        "line": 207,
        "column": 8,
        "nodeType": null
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 232,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 232,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 237,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 237,
        "endColumn": 11
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 246,
        "column": 27,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 246,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [6609, 6609], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 283,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 283,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 314,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 314,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 319,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 319,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 351,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 351,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 356,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 356,
        "endColumn": 11
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'payload' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 401,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 401,
        "endColumn": 18
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 414,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 414,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 449,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 449,
        "endColumn": 11
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 479,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 479,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport rateLimit from 'express-rate-limit';\nimport helmet from 'helmet';\nimport xss from 'xss-clean';\nimport hpp from 'hpp';\nimport mongoSanitize from 'express-mongo-sanitize';\nimport cors from 'cors';\nimport { body, validationResult } from 'express-validator';\nimport { AuditLog } from '../models/AuditLog.js';\nimport { SecurityLog } from '../models/SecurityLog.js';\n\nimport logger from '../utils/logger.js';\n// ===== CONFIGURAÃ‡Ã•ES DE SEGURANÃ‡A =====\n\nconst securityConfig = {\n  // Rate Limiting\n  rateLimit: {\n    windowMs: 15 * 60 * 1000, // 15 minutos\n    max: {\n      public: 100,\n      authenticated: 500,\n      admin: 1000,\n      critical: 10\n    },\n    message: {\n      success: false,\n      message: 'Muitas tentativas. Tente novamente em 15 minutos.',\n      retryAfter: '15 minutos'\n    }\n  },\n\n  // CORS\n  cors: {\n    origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n    allowedHeaders: [\n      'Origin',\n      'X-Requested-With',\n      'Content-Type',\n      'Accept',\n      'Authorization',\n      'X-CSRF-Token',\n      'X-API-Key'\n    ]\n  },\n\n  // Helmet\n  helmet: {\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\n          \"'self'\",\n          \"'unsafe-inline'\",\n          'https://fonts.googleapis.com',\n          'https://cdn.jsdelivr.net'\n        ],\n        fontSrc: [\"'self'\", 'https://fonts.gstatic.com', 'https://cdn.jsdelivr.net'],\n        scriptSrc: [\"'self'\", \"'unsafe-inline'\", 'https://cdn.jsdelivr.net'],\n        imgSrc: [\"'self'\", 'data:', 'https:', 'blob:'],\n        connectSrc: [\"'self'\", 'https://api.github.com', 'wss:'],\n        frameSrc: [\"'none'\"],\n        objectSrc: [\"'none'\"],\n        upgradeInsecureRequests: []\n      }\n    },\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true,\n      preload: true\n    },\n    noSniff: true,\n    referrerPolicy: { policy: 'strict-origin-when-cross-origin' }\n  }\n};\n\n// ===== MIDDLEWARE DE RATE LIMITING =====\n\nexport const createRateLimiter = (max = 100, windowMs = 15 * 60 * 1000) => {\n  return rateLimit({\n    windowMs,\n    max,\n    message: securityConfig.rateLimit.message,\n    standardHeaders: true,\n    legacyHeaders: false,\n    handler: async (req, res) => {\n      // Log de rate limiting\n      await SecurityLog.create({\n        eventType: 'rate_limit_exceeded',\n        severity: 'medium',\n        description: `Rate limit exceeded: ${max} requests in ${windowMs}ms`,\n        ipAddress: req.ip,\n        userAgent: req.get('User-Agent'),\n        requestMethod: req.method,\n        requestUrl: req.originalUrl,\n        details: {\n          limit: max,\n          windowMs,\n          userAgent: req.get('User-Agent')\n        }\n      });\n\n      res.status(429).json(securityConfig.rateLimit.message);\n    }\n  });\n};\n\n// Rate limiters especÃ­ficos\nexport const publicRateLimit = createRateLimiter(securityConfig.rateLimit.max.public);\nexport const authenticatedRateLimit = createRateLimiter(securityConfig.rateLimit.max.authenticated);\nexport const adminRateLimit = createRateLimiter(securityConfig.rateLimit.max.admin);\nexport const criticalRateLimit = createRateLimiter(securityConfig.rateLimit.max.critical);\n\n// ===== MIDDLEWARE DE SEGURANÃ‡A PRINCIPAL =====\n\nexport const securityMiddleware = [\n  // CORS\n  cors(securityConfig.cors),\n\n  // Helmet para headers de seguranÃ§a\n  helmet(securityConfig.helmet),\n\n  // ProteÃ§Ã£o contra XSS\n  xss(),\n\n  // ProteÃ§Ã£o contra HTTP Parameter Pollution\n  hpp(),\n\n  // ProteÃ§Ã£o contra NoSQL Injection\n  mongoSanitize(),\n\n  // Middleware de detecÃ§Ã£o de ataques\n  detectAttackPatterns,\n\n  // Middleware de validaÃ§Ã£o de entrada\n  validateInput,\n\n  // Middleware de sanitizaÃ§Ã£o\n  sanitizeData,\n\n  // Middleware de logging de seguranÃ§a\n  securityLogging\n];\n\n// ===== DETECÃ‡ÃƒO DE PADRÃ•ES DE ATAQUE =====\n\nexport const detectAttackPatterns = (req, res, next) => {\n  try {\n    const attackPatterns = [\n      // SQL Injection\n      /(\\b(union|select|insert|update|delete|drop|create|alter|exec|execute|script|javascript|vbscript|onload|onerror|onclick)\\b)/i,\n\n      // XSS\n      /<script|javascript:|vbscript:|onload|onerror|onclick|onmouseover/i,\n\n      // Command Injection\n      /(\\b(cmd|command|exec|system|eval|setTimeout|setInterval)\\b)/i,\n\n      // Path Traversal\n      /\\.\\.\\/|\\.\\.\\\\|\\.\\.%2f|\\.\\.%5c/i,\n\n      // LDAP Injection\n      /(\\b(\\(|\\)|\\*|\\||&)\\b)/i,\n\n      // NoSQL Injection\n      /(\\$where|\\$ne|\\$gt|\\$lt|\\$regex)/i,\n\n      // Template Injection\n      /(\\{\\{.*\\}\\}|\\{%.*%\\})/i,\n\n      // Code Injection\n      /(\\beval\\s*\\(|\\bFunction\\s*\\(|\\bnew\\s+Function)/i\n    ];\n\n    const requestData = JSON.stringify({\n      url: req.originalUrl,\n      method: req.method,\n      body: req.body,\n      query: req.query,\n      params: req.params,\n      headers: req.headers\n    });\n\n    let attackDetected = false;\n    let attackType = '';\n\n    attackPatterns.forEach((pattern, index) => {\n      if (pattern.test(requestData)) {\n        attackDetected = true;\n        const attackTypes = [\n          'SQL_INJECTION',\n          'XSS',\n          'COMMAND_INJECTION',\n          'PATH_TRAVERSAL',\n          'LDAP_INJECTION',\n          'NOSQL_INJECTION',\n          'TEMPLATE_INJECTION',\n          'CODE_INJECTION'\n        ];\n        attackType = attackTypes[index] || 'UNKNOWN_ATTACK';\n      }\n    });\n\n    if (attackDetected) {\n      // Log do ataque detectado\n      await SecurityLog.create({\n        eventType: 'suspicious_activity',\n        severity: 'high',\n        description: `Ataque detectado: ${attackType}`,\n        ipAddress: req.ip,\n        userAgent: req.get('User-Agent'),\n        requestMethod: req.method,\n        requestUrl: req.originalUrl,\n        requestHeaders: req.headers,\n        requestBody: requestData.substring(0, 1000),\n        details: {\n          attackType,\n          requestData: requestData.substring(0, 500),\n          userAgent: req.get('User-Agent')\n        }\n      });\n\n      // Bloquear requisiÃ§Ã£o\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado: padrÃ£o suspeito detectado',\n        code: 'ATTACK_DETECTED'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na detecÃ§Ã£o de ataques:', error);\n    }\n    next();\n  }\n};\n\n// ===== VALIDAÃ‡ÃƒO DE ENTRADA =====\n\nexport const validateInput = (req, res, next) => {\n  try {\n    // Validar tamanho do body\n    const contentLength = parseInt(req.get('content-length', 10, 10) || '0');\n    const maxSize = 10 * 1024 * 1024; // 10MB\n\n    if (contentLength > maxSize) {\n      return res.status(413).json({\n        success: false,\n        message: 'Payload muito grande',\n        code: 'PAYLOAD_TOO_LARGE'\n      });\n    }\n\n    // Validar Content-Type\n    const contentType = req.get('content-type');\n    if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {\n      if (!contentType || !contentType.includes('application/json')) {\n        return res.status(400).json({\n          success: false,\n          message: 'Content-Type deve ser application/json',\n          code: 'INVALID_CONTENT_TYPE'\n        });\n      }\n    }\n\n    // Sanitizar query parameters\n    if (req.query) {\n      for (const key in req.query) {\n        if (typeof req.query[key] === 'string') {\n          req.query[key] = sanitizeString(req.query[key]);\n        }\n      }\n    }\n\n    // Sanitizar body\n    if (req.body) {\n      req.body = sanitizeObject(req.body);\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o de entrada:', error);\n    }\n    res.status(400).json({\n      success: false,\n      message: 'Erro na validaÃ§Ã£o de entrada',\n      code: 'VALIDATION_ERROR'\n    });\n  }\n};\n\n// ===== SANITIZAÃ‡ÃƒO DE DADOS =====\n\nexport const sanitizeData = (req, res, next) => {\n  try {\n    // Sanitizar headers suspeitos\n    const suspiciousHeaders = ['x-forwarded-for', 'x-real-ip', 'x-cluster-client-ip'];\n\n    suspiciousHeaders.forEach(header => {\n      if (req.headers[header]) {\n        req.headers[header] = sanitizeString(req.headers[header]);\n      }\n    });\n\n    // Sanitizar User-Agent\n    if (req.headers['user-agent']) {\n      req.headers['user-agent'] = sanitizeString(req.headers['user-agent']);\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na sanitizaÃ§Ã£o:', error);\n    }\n    next();\n  }\n};\n\n// ===== LOGGING DE SEGURANÃ‡A =====\n\nexport const securityLogging = (req, res, next) => {\n  try {\n    // Log de requisiÃ§Ã£o\n    const logEntry = {\n      eventType: 'api_request',\n      severity: 'low',\n      description: `${req.method} ${req.originalUrl}`,\n      ipAddress: req.ip,\n      userAgent: req.get('User-Agent'),\n      requestMethod: req.method,\n      requestUrl: req.originalUrl,\n      requestHeaders: req.headers,\n      details: {\n        timestamp: new Date().toISOString(),\n        userAgent: req.get('User-Agent'),\n        referer: req.get('referer')\n      }\n    };\n\n    // Adicionar informaÃ§Ãµes do usuÃ¡rio se autenticado\n    if (req.user) {\n      logEntry.userId = req.user.id;\n      logEntry.details.userEmail = req.user.email;\n    }\n\n    await SecurityLog.create(logEntry);\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no logging de seguranÃ§a:', error);\n    }\n    next();\n  }\n};\n\n// ===== FUNÃ‡Ã•ES AUXILIARES =====\n\nfunction sanitizeString(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n\n  return (\n    str\n      .replace(/[<>]/g, '') // Remover < e >\n      .replace(/javascript:/gi, '') // Remover javascript:\n      .replace(/on\\w+=/gi, '') // Remover event handlers\n      // Remover caracteres de controle, usando a classe POSIX-equivalente para maior compatibilidade\n      .replace(/[^\\x20-\\x7E\\n\\r\\t]/g, '')\n      .trim()\n  );\n}\n\nfunction sanitizeObject(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => sanitizeObject(item));\n  }\n\n  const sanitized = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const cleanKey = sanitizeString(key);\n    sanitized[cleanKey] = typeof value === 'string' ? sanitizeString(value) : sanitizeObject(value);\n  }\n\n  return sanitized;\n}\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO DE WEBHOOK =====\n\nexport const validateStripeWebhook = (req, res, next) => {\n  try {\n    const signature = req.get('stripe-signature');\n    const payload = JSON.stringify(req.body);\n\n    if (!signature) {\n      return res.status(400).json({\n        success: false,\n        message: 'Stripe signature missing',\n        code: 'MISSING_SIGNATURE'\n      });\n    }\n\n    // Aqui vocÃª implementaria a verificaÃ§Ã£o real da assinatura do Stripe\n    // Por enquanto, apenas validar se existe\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o do webhook Stripe:', error);\n    }\n    res.status(400).json({\n      success: false,\n      message: 'Webhook invÃ¡lido',\n      code: 'INVALID_WEBHOOK'\n    });\n  }\n};\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO DE CSRF =====\n\nexport const validateCSRF = (req, res, next) => {\n  try {\n    // Verificar se Ã© uma requisiÃ§Ã£o que precisa de CSRF\n    const csrfRequiredMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];\n\n    if (!csrfRequiredMethods.includes(req.method)) {\n      return next();\n    }\n\n    const csrfToken = req.get('X-CSRF-Token');\n    const sessionToken = req.session?.csrfToken;\n\n    if (!csrfToken || !sessionToken || csrfToken !== sessionToken) {\n      return res.status(403).json({\n        success: false,\n        message: 'Token CSRF invÃ¡lido',\n        code: 'INVALID_CSRF'\n      });\n    }\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o CSRF:', error);\n    }\n    res.status(403).json({\n      success: false,\n      message: 'Erro na validaÃ§Ã£o CSRF',\n      code: 'CSRF_ERROR'\n    });\n  }\n};\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO DE API KEY =====\n\nexport const validateAPIKey = (req, res, next) => {\n  try {\n    const apiKey = req.get('X-API-Key');\n\n    if (!apiKey) {\n      return res.status(401).json({\n        success: false,\n        message: 'API Key obrigatÃ³ria',\n        code: 'MISSING_API_KEY'\n      });\n    }\n\n    // Aqui vocÃª implementaria a validaÃ§Ã£o real da API Key\n    // Por enquanto, apenas verificar se existe\n\n    next();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na validaÃ§Ã£o da API Key:', error);\n    }\n    res.status(401).json({\n      success: false,\n      message: 'API Key invÃ¡lida',\n      code: 'INVALID_API_KEY'\n    });\n  }\n};\n\nexport default {\n  securityMiddleware,\n  createRateLimiter,\n  publicRateLimit,\n  authenticatedRateLimit,\n  adminRateLimit,\n  criticalRateLimit,\n  detectAttackPatterns,\n  validateInput,\n  sanitizeData,\n  securityLogging,\n  validateStripeWebhook,\n  validateCSRF,\n  validateAPIKey\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\sessionCapture.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\middleware\\validation.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\AuditLog.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Chat.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'id' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 7,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// Modelo Chat - arquivo temporÃ¡rio para deploy\nexport default class Chat {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n\n  static findById(id) {\n    return null;\n  }\n\n  static create(data) {\n    return new Chat(data);\n  }\n\n  save() {\n    return this;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Client.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\ContactMessage.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Conversation.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Escrow.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\EscrowTransaction.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Freight.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\FreightOrder.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'id' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 7,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 21
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'userId' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 11,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 11,
        "endColumn": 27
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async method 'save' has no 'await' expression.",
        "line": 19,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 19,
        "endColumn": 13
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async method 'update' has no 'await' expression.",
        "line": 23,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 23,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// Modelo FreightOrder - arquivo temporÃ¡rio para deploy\nexport default class FreightOrder {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n\n  static findById(id) {\n    return null;\n  }\n\n  static findByUser(userId) {\n    return [];\n  }\n\n  static create(data) {\n    return new FreightOrder(data);\n  }\n\n  async save() {\n    return this;\n  }\n\n  async update(data) {\n    Object.assign(this, data);\n    return this;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Message.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\News.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Notification.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Partner.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\PartnershipMessage.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\PasswordResetD1.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Payment.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\PrivateMessage.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Product.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\RefreshToken.js",
    "messages": [
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async function has no 'await' expression.",
        "line": 95,
        "column": 50,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 95,
        "endColumn": 65
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import mongoose from 'mongoose';\n\nconst refreshTokenSchema = new mongoose.Schema(\n  {\n    userId: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true\n    },\n    token: {\n      type: String,\n      required: true,\n      unique: true,\n      index: true\n    },\n    jwtToken: {\n      type: String,\n      required: true\n    },\n    expiresAt: {\n      type: Date,\n      required: true,\n      index: { expireAfterSeconds: 0 } // TTL index\n    },\n    userAgent: {\n      type: String,\n      default: null\n    },\n    ipAddress: {\n      type: String,\n      default: null\n    },\n    isActive: {\n      type: Boolean,\n      default: true,\n      index: true\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now\n    },\n    lastUsedAt: {\n      type: Date,\n      default: null\n    },\n    revokedAt: {\n      type: Date,\n      default: null\n    }\n  },\n  {\n    timestamps: true\n  }\n);\n\n// Ãndices compostos para performance\nrefreshTokenSchema.index({ userId: 1, isActive: 1 });\nrefreshTokenSchema.index({ token: 1, isActive: 1 });\nrefreshTokenSchema.index({ expiresAt: 1, isActive: 1 });\n\n// MÃ©todo para verificar se o token estÃ¡ vÃ¡lido\nrefreshTokenSchema.methods.isValid = function () {\n  return this.isActive && this.expiresAt > new Date();\n};\n\n// MÃ©todo para revogar o token\nrefreshTokenSchema.methods.revoke = function () {\n  this.isActive = false;\n  this.revokedAt = new Date();\n  return this.save();\n};\n\n// MÃ©todo estÃ¡tico para limpar tokens expirados\nrefreshTokenSchema.statics.cleanupExpired = async function () {\n  const result = await this.deleteMany({\n    $or: [\n      { expiresAt: { $lt: new Date() } },\n      { isActive: false, revokedAt: { $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } }\n    ]\n  });\n  return result.deletedCount;\n};\n\n// MÃ©todo estÃ¡tico para revogar todos os tokens de um usuÃ¡rio\nrefreshTokenSchema.statics.revokeUserTokens = async function (userId) {\n  const result = await this.updateMany(\n    { userId, isActive: true },\n    { isActive: false, revokedAt: new Date() }\n  );\n  return result.modifiedCount;\n};\n\n// MÃ©todo estÃ¡tico para obter tokens ativos de um usuÃ¡rio\nrefreshTokenSchema.statics.getActiveUserTokens = async function (userId) {\n  return this.find({\n    userId,\n    isActive: true,\n    expiresAt: { $gt: new Date() }\n  }).sort({ createdAt: -1 });\n};\n\n// Middleware para atualizar lastUsedAt\nrefreshTokenSchema.pre('save', function (next) {\n  if (this.isModified('lastUsedAt') && this.lastUsedAt) {\n    this.lastUsedAt = new Date();\n  }\n  next();\n});\n\nconst RefreshToken = mongoose.model('RefreshToken', refreshTokenSchema);\n\nexport default RefreshToken;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Registration.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'bcrypt' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 2,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 13
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 969,
        "column": 12,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 969,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [16958, 16958], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 975,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 975,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [17130, 17130], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 981,
        "column": 12,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 981,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [17243, 17243], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 987,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 987,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [17412, 17412], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 1005,
        "column": 12,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 1005,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [17742, 17742], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 1012,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 1012,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [17934, 17934], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 1020,
        "column": 12,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 1020,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [18064, 18064], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 1027,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 1027,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [18255, 18255], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\n\n// Schema para cadastros de AgroConecta\nconst agroConectaSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da empresa\n    companyName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cnpj: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n    ie: {\n      type: String,\n      trim: true\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Dados do veÃ­culo\n    vehicle: {\n      plate: {\n        type: String,\n        required: true,\n        unique: true,\n        trim: true\n      },\n      type: {\n        type: String,\n        required: true,\n        enum: ['truck', 'tractor', 'van', 'pickup']\n      },\n      capacity: {\n        type: Number,\n        required: true,\n        min: 0\n      },\n      license: {\n        type: String,\n        required: true,\n        enum: ['B', 'C', 'D', 'E']\n      },\n      year: {\n        type: Number,\n        min: 1900,\n        max: new Date().getFullYear() + 1\n      },\n      model: {\n        type: String,\n        trim: true\n      },\n      brand: {\n        type: String,\n        trim: true\n      }\n    },\n\n    // ServiÃ§os oferecidos\n    services: [\n      {\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        unit: {\n          type: String,\n          default: 'km',\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalJobs: {\n        type: Number,\n        default: 0\n      },\n      completedJobs: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      cnpj: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Schema para cadastros de Loja\nconst lojaSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da empresa\n    companyName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cnpj: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n    ie: {\n      type: String,\n      trim: true\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Produtos\n    products: [\n      {\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        category: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        quantity: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        unit: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        image: {\n          type: String,\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        },\n        isAvailable: {\n          type: Boolean,\n          default: true\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalSales: {\n        type: Number,\n        default: 0\n      },\n      completedOrders: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      cnpj: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Schema para cadastros de Marketplace\nconst marketplaceSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da empresa\n    companyName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cnpj: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n    ie: {\n      type: String,\n      trim: true\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Produtos/ServiÃ§os\n    offerings: [\n      {\n        type: {\n          type: String,\n          required: true,\n          enum: ['product', 'service']\n        },\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        category: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        quantity: {\n          type: Number,\n          default: 1,\n          min: 0\n        },\n        unit: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        image: {\n          type: String,\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        },\n        isAvailable: {\n          type: Boolean,\n          default: true\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalTransactions: {\n        type: Number,\n        default: 0\n      },\n      completedOrders: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      cnpj: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Schema para cadastros de Fazenda\nconst fazendaSchema = new mongoose.Schema(\n  {\n    // Dados bÃ¡sicos\n    name: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true\n    },\n    phone: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    cpf: {\n      type: String,\n      required: true,\n      unique: true,\n      trim: true\n    },\n\n    // Dados da fazenda\n    farmName: {\n      type: String,\n      required: true,\n      trim: true\n    },\n    farmSize: {\n      type: Number,\n      required: true,\n      min: 0\n    },\n    farmType: {\n      type: String,\n      enum: ['agriculture', 'livestock', 'mixed'],\n      default: 'agriculture'\n    },\n\n    // EndereÃ§o\n    address: {\n      cep: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      street: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      number: {\n        type: String,\n        trim: true\n      },\n      complement: {\n        type: String,\n        trim: true\n      },\n      neighborhood: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      city: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      state: {\n        type: String,\n        required: true,\n        trim: true\n      },\n      country: {\n        type: String,\n        default: 'Brasil',\n        trim: true\n      },\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // Produtos da fazenda\n    products: [\n      {\n        id: {\n          type: String,\n          required: true\n        },\n        name: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        category: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        description: {\n          type: String,\n          trim: true\n        },\n        price: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        quantity: {\n          type: Number,\n          required: true,\n          min: 0\n        },\n        unit: {\n          type: String,\n          required: true,\n          trim: true\n        },\n        harvestDate: {\n          type: Date\n        },\n        image: {\n          type: String,\n          trim: true\n        },\n        isCustom: {\n          type: Boolean,\n          default: false\n        },\n        isAvailable: {\n          type: Boolean,\n          default: true\n        }\n      }\n    ],\n\n    // Plano e configuraÃ§Ãµes\n    plan: {\n      type: String,\n      required: true,\n      enum: ['basic', 'standard', 'premium'],\n      default: 'basic'\n    },\n    isPublic: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n\n    // Dados de pagamento\n    payment: {\n      stripeCustomerId: {\n        type: String,\n        trim: true\n      },\n      subscriptionId: {\n        type: String,\n        trim: true\n      },\n      lastPayment: {\n        type: Date\n      },\n      nextPayment: {\n        type: Date\n      }\n    },\n\n    // EstatÃ­sticas\n    stats: {\n      totalHarvests: {\n        type: Number,\n        default: 0\n      },\n      totalSales: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0,\n        min: 0,\n        max: 5\n      },\n      reviews: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // Metadados\n    autoFilled: {\n      cpf: {\n        type: Boolean,\n        default: false\n      },\n      address: {\n        type: Boolean,\n        default: false\n      }\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Middleware para validaÃ§Ã£o de dados\nagroConectaSchema.pre('save', function (next) {\n  // Validar CPF\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  // Validar CNPJ\n  if (this.cnpj && !this.isValidCNPJ(this.cnpj)) {\n    return next(new Error('CNPJ invÃ¡lido'));\n  }\n\n  next();\n});\n\nlojaSchema.pre('save', function (next) {\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  if (this.cnpj && !this.isValidCNPJ(this.cnpj)) {\n    return next(new Error('CNPJ invÃ¡lido'));\n  }\n\n  next();\n});\n\nmarketplaceSchema.pre('save', function (next) {\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  if (this.cnpj && !this.isValidCNPJ(this.cnpj)) {\n    return next(new Error('CNPJ invÃ¡lido'));\n  }\n\n  next();\n});\n\nfazendaSchema.pre('save', function (next) {\n  if (this.cpf && !this.isValidCPF(this.cpf)) {\n    return next(new Error('CPF invÃ¡lido'));\n  }\n\n  next();\n});\n\n// MÃ©todos de validaÃ§Ã£o\nagroConectaSchema.methods.isValidCPF = function (cpf) {\n  cpf = cpf.replace(/[^\\d]/g, '');\n\n  if (cpf.length !== 11 || /^(\\d)\\1+$/.test(cpf)) {\n    return false;\n  }\n\n  let sum = 0;\n  for (let i = 0; i < 9; i++) {\n    sum += parseInt(cpf.charAt(i, 10, 10)) * (10 - i);\n  }\n  let remainder = (sum * 10) % 11;\n  if (remainder === 10 || remainder === 11) {\n    remainder = 0;\n  }\n  if (remainder !== parseInt(cpf.charAt(9, 10, 10))) {\n    return false;\n  }\n\n  sum = 0;\n  for (let i = 0; i < 10; i++) {\n    sum += parseInt(cpf.charAt(i, 10, 10)) * (11 - i);\n  }\n  remainder = (sum * 10) % 11;\n  if (remainder === 10 || remainder === 11) {\n    remainder = 0;\n  }\n  if (remainder !== parseInt(cpf.charAt(10, 10, 10))) {\n    return false;\n  }\n\n  return true;\n};\n\nagroConectaSchema.methods.isValidCNPJ = function (cnpj) {\n  cnpj = cnpj.replace(/[^\\d]/g, '');\n\n  if (cnpj.length !== 14 || /^(\\d)\\1+$/.test(cnpj)) {\n    return false;\n  }\n\n  let sum = 0;\n  let weight = 2;\n\n  for (let i = 11; i >= 0; i--) {\n    sum += parseInt(cnpj.charAt(i, 10, 10)) * weight;\n    weight = weight === 9 ? 2 : weight + 1;\n  }\n\n  let remainder = sum % 11;\n  const digit1 = remainder < 2 ? 0 : 11 - remainder;\n\n  if (digit1 !== parseInt(cnpj.charAt(12, 10, 10))) {\n    return false;\n  }\n\n  sum = 0;\n  weight = 2;\n\n  for (let i = 12; i >= 0; i--) {\n    sum += parseInt(cnpj.charAt(i, 10, 10)) * weight;\n    weight = weight === 9 ? 2 : weight + 1;\n  }\n\n  remainder = sum % 11;\n  const digit2 = remainder < 2 ? 0 : 11 - remainder;\n\n  return digit2 === parseInt(cnpj.charAt(13, 10, 10));\n};\n\n// Aplicar os mesmos mÃ©todos para os outros schemas\nlojaSchema.methods.isValidCPF = agroConectaSchema.methods.isValidCPF;\nlojaSchema.methods.isValidCNPJ = agroConectaSchema.methods.isValidCNPJ;\nmarketplaceSchema.methods.isValidCPF = agroConectaSchema.methods.isValidCPF;\nmarketplaceSchema.methods.isValidCNPJ = agroConectaSchema.methods.isValidCNPJ;\nfazendaSchema.methods.isValidCPF = agroConectaSchema.methods.isValidCPF;\n\n// Ãndices para otimizaÃ§Ã£o\nagroConectaSchema.index({ email: 1 });\nagroConectaSchema.index({ cpf: 1 });\nagroConectaSchema.index({ cnpj: 1 });\nagroConectaSchema.index({ 'address.city': 1, 'address.state': 1 });\nagroConectaSchema.index({ 'vehicle.type': 1 });\nagroConectaSchema.index({ plan: 1, isPublic: 1 });\n\nlojaSchema.index({ email: 1 });\nlojaSchema.index({ cpf: 1 });\nlojaSchema.index({ cnpj: 1 });\nlojaSchema.index({ 'address.city': 1, 'address.state': 1 });\nlojaSchema.index({ plan: 1, isPublic: 1 });\n\nmarketplaceSchema.index({ email: 1 });\nmarketplaceSchema.index({ cpf: 1 });\nmarketplaceSchema.index({ cnpj: 1 });\nmarketplaceSchema.index({ 'address.city': 1, 'address.state': 1 });\nmarketplaceSchema.index({ plan: 1, isPublic: 1 });\n\nfazendaSchema.index({ email: 1 });\nfazendaSchema.index({ cpf: 1 });\nfazendaSchema.index({ 'address.city': 1, 'address.state': 1 });\nfazendaSchema.index({ plan: 1, isPublic: 1 });\n\nconst AgroConecta = mongoose.model('AgroConecta', agroConectaSchema);\nconst Loja = mongoose.model('Loja', lojaSchema);\nconst Marketplace = mongoose.model('Marketplace', marketplaceSchema);\nconst Fazenda = mongoose.model('Fazenda', fazendaSchema);\n\nmodule.exports = {\n  AgroConecta,\n  Loja,\n  Marketplace,\n  Fazenda\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\SecurityLog.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\StakingPool.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\StakingRecord.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Transaction.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\TransactionMessage.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'reason' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 244,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 244,
        "endColumn": 65
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'userId' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 275,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 275,
        "endColumn": 64
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import mongoose from 'mongoose';\n\nconst transactionMessageSchema = new mongoose.Schema(\n  {\n    // ID da transaÃ§Ã£o relacionada\n    transactionId: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'Transaction',\n      required: true,\n      index: true\n    },\n\n    // UsuÃ¡rio que enviou a mensagem\n    from: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true\n    },\n\n    // UsuÃ¡rio que recebeu a mensagem\n    to: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true\n    },\n\n    // ConteÃºdo da mensagem\n    body: {\n      type: String,\n      required: true,\n      trim: true,\n      maxlength: [2000, 'Mensagem nÃ£o pode ter mais de 2000 caracteres']\n    },\n\n    // Tipo da mensagem\n    type: {\n      type: String,\n      enum: ['text', 'image', 'file', 'location', 'system'],\n      default: 'text'\n    },\n\n    // Anexos (opcional)\n    attachments: [\n      {\n        name: String,\n        type: String,\n        size: Number,\n        url: String,\n        thumbnail: String\n      }\n    ],\n\n    // Status da mensagem\n    status: {\n      type: String,\n      enum: ['sent', 'delivered', 'read', 'failed'],\n      default: 'sent',\n      index: true\n    },\n\n    // Metadados\n    metadata: {\n      // Coordenadas se for mensagem de localizaÃ§Ã£o\n      coordinates: {\n        lat: Number,\n        lng: Number,\n        address: String\n      },\n      // InformaÃ§Ãµes do arquivo se for anexo\n      fileInfo: {\n        originalName: String,\n        mimeType: String,\n        size: Number\n      }\n    },\n\n    // Timestamps\n    createdAt: {\n      type: Date,\n      default: Date.now,\n      index: true\n    },\n\n    // Quando foi entregue\n    deliveredAt: Date,\n\n    // Quando foi lida\n    readAt: Date,\n\n    // UsuÃ¡rios que leram a mensagem\n    readBy: [\n      {\n        userId: {\n          type: mongoose.Schema.Types.ObjectId,\n          ref: 'User'\n        },\n        readAt: {\n          type: Date,\n          default: Date.now\n        }\n      }\n    ],\n\n    // Mensagem pai (para respostas)\n    parentMessage: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'TransactionMessage'\n    },\n\n    // Mensagens filhas (respostas)\n    replies: [\n      {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'TransactionMessage'\n      }\n    ],\n\n    // Flags e moderaÃ§Ã£o\n    isFlagged: {\n      type: Boolean,\n      default: false\n    },\n\n    flaggedReason: String,\n\n    flaggedBy: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User'\n    },\n\n    flaggedAt: Date,\n\n    // Soft delete\n    isDeleted: {\n      type: Boolean,\n      default: false\n    },\n\n    deletedAt: Date,\n\n    deletedBy: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User'\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// Ãndices para performance\ntransactionMessageSchema.index({ transactionId: 1, createdAt: -1 });\ntransactionMessageSchema.index({ from: 1, createdAt: -1 });\ntransactionMessageSchema.index({ to: 1, createdAt: -1 });\ntransactionMessageSchema.index({ status: 1, createdAt: -1 });\ntransactionMessageSchema.index({ 'readBy.userId': 1 });\ntransactionMessageSchema.index({ isDeleted: 1 });\n\n// Middleware para atualizar timestamps\ntransactionMessageSchema.pre('save', function (next) {\n  if (this.isModified('status')) {\n    if (this.status === 'delivered' && !this.deliveredAt) {\n      this.deliveredAt = new Date();\n    }\n    if (this.status === 'read' && !this.readAt) {\n      this.readAt = new Date();\n    }\n  }\n  next();\n});\n\n// Virtual para verificar se a mensagem foi lida\ntransactionMessageSchema.virtual('isRead').get(function () {\n  return this.status === 'read';\n});\n\n// Virtual para verificar se a mensagem foi entregue\ntransactionMessageSchema.virtual('isDelivered').get(function () {\n  return this.status === 'delivered' || this.status === 'read';\n});\n\n// Virtual para verificar se a mensagem falhou\ntransactionMessageSchema.virtual('isFailed').get(function () {\n  return this.status === 'failed';\n});\n\n// Virtual para verificar se tem anexos\ntransactionMessageSchema.virtual('hasAttachments').get(function () {\n  return this.attachments && this.attachments.length > 0;\n});\n\n// Virtual para verificar se Ã© imagem\ntransactionMessageSchema.virtual('isImage').get(function () {\n  return this.type === 'image';\n});\n\n// Virtual para verificar se Ã© arquivo\ntransactionMessageSchema.virtual('isFile').get(function () {\n  return this.type === 'file';\n});\n\n// Virtual para verificar se Ã© localizaÃ§Ã£o\ntransactionMessageSchema.virtual('isLocation').get(function () {\n  return this.type === 'location';\n});\n\n// Virtual para verificar se Ã© sistema\ntransactionMessageSchema.virtual('isSystem').get(function () {\n  return this.type === 'system';\n});\n\n// MÃ©todo para marcar como entregue\ntransactionMessageSchema.methods.markAsDelivered = function () {\n  this.status = 'delivered';\n  this.deliveredAt = new Date();\n  return this.save();\n};\n\n// MÃ©todo para marcar como lida\ntransactionMessageSchema.methods.markAsRead = function (userId) {\n  if (this.status !== 'read') {\n    this.status = 'read';\n    this.readAt = new Date();\n  }\n\n  // Adicionar usuÃ¡rio Ã  lista de leitores se nÃ£o estiver\n  const alreadyRead = this.readBy.find(reader => reader.userId.toString() === userId.toString());\n\n  if (!alreadyRead) {\n    this.readBy.push({\n      userId,\n      readAt: new Date()\n    });\n  }\n\n  return this.save();\n};\n\n// MÃ©todo para marcar como falhou\ntransactionMessageSchema.methods.markAsFailed = function (reason = 'Erro de entrega') {\n  this.status = 'failed';\n  return this.save();\n};\n\n// MÃ©todo para verificar se foi lida por um usuÃ¡rio especÃ­fico\ntransactionMessageSchema.methods.isReadBy = function (userId) {\n  return this.readBy.some(reader => reader.userId.toString() === userId.toString());\n};\n\n// MÃ©todo para obter dados pÃºblicos (sem informaÃ§Ãµes sensÃ­veis)\ntransactionMessageSchema.methods.getPublicData = function () {\n  return {\n    id: this._id,\n    transactionId: this.transactionId,\n    from: this.from,\n    to: this.to,\n    body: this.body,\n    type: this.type,\n    status: this.status,\n    hasAttachments: this.hasAttachments,\n    createdAt: this.createdAt,\n    deliveredAt: this.deliveredAt,\n    readAt: this.readAt,\n    isRead: this.isRead,\n    isDelivered: this.isDelivered,\n    isFailed: this.isFailed\n  };\n};\n\n// MÃ©todo para obter dados completos (para usuÃ¡rios autorizados)\ntransactionMessageSchema.methods.getFullData = function (userId) {\n  const baseData = this.getPublicData();\n\n  // Adicionar anexos se existirem\n  if (this.attachments && this.attachments.length > 0) {\n    baseData.attachments = this.attachments;\n  }\n\n  // Adicionar metadados se existirem\n  if (this.metadata) {\n    baseData.metadata = this.metadata;\n  }\n\n  // Adicionar informaÃ§Ãµes de leitura\n  baseData.readBy = this.readBy;\n\n  // Adicionar informaÃ§Ãµes de resposta\n  if (this.parentMessage) {\n    baseData.parentMessage = this.parentMessage;\n  }\n\n  if (this.replies && this.replies.length > 0) {\n    baseData.replies = this.replies;\n  }\n\n  return baseData;\n};\n\n// MÃ©todo para obter dados de exibiÃ§Ã£o (para UI)\ntransactionMessageSchema.methods.getDisplayData = function (currentUserId) {\n  const baseData = this.getPublicData();\n\n  // Adicionar flag se Ã© mensagem do usuÃ¡rio atual\n  baseData.isOwnMessage = this.from.toString() === currentUserId.toString();\n\n  // Adicionar informaÃ§Ãµes de anexos para exibiÃ§Ã£o\n  if (this.attachments && this.attachments.length > 0) {\n    baseData.attachments = this.attachments.map(attachment => ({\n      name: attachment.name,\n      type: attachment.type,\n      size: attachment.size,\n      url: attachment.url,\n      thumbnail: attachment.thumbnail,\n      isImage: attachment.type.startsWith('image/'),\n      isFile: !attachment.type.startsWith('image/')\n    }));\n  }\n\n  // Adicionar metadados de localizaÃ§Ã£o se aplicÃ¡vel\n  if (this.type === 'location' && this.metadata?.coordinates) {\n    baseData.location = {\n      lat: this.metadata.coordinates.lat,\n      lng: this.metadata.coordinates.lng,\n      address: this.metadata.coordinates.address\n    };\n  }\n\n  return baseData;\n};\n\n// MÃ©todos estÃ¡ticos para consultas comuns\n\n// Buscar mensagens de uma transaÃ§Ã£o\ntransactionMessageSchema.statics.findByTransaction = function (transactionId, options = {}) {\n  const { limit = 50, skip = 0, sort = { createdAt: -1 }, includeDeleted = false } = options;\n\n  const query = { transactionId };\n\n  if (!includeDeleted) {\n    query.isDeleted = false;\n  }\n\n  return this.find(query)\n    .sort(sort)\n    .skip(skip)\n    .limit(limit)\n    .populate('from', 'name email phone')\n    .populate('to', 'name email phone')\n    .populate('parentMessage')\n    .populate('replies');\n};\n\n// Buscar mensagens nÃ£o lidas de um usuÃ¡rio\ntransactionMessageSchema.statics.findUnreadByUser = function (userId, transactionId = null) {\n  const query = {\n    to: userId,\n    status: { $ne: 'read' },\n    isDeleted: false\n  };\n\n  if (transactionId) {\n    query.transactionId = transactionId;\n  }\n\n  return this.find(query)\n    .populate('from', 'name email phone')\n    .populate('transactionId', 'type itemDetails')\n    .sort({ createdAt: -1 });\n};\n\n// Buscar mensagens de um usuÃ¡rio\ntransactionMessageSchema.statics.findByUser = function (userId, options = {}) {\n  const {\n    limit = 50,\n    skip = 0,\n    sort = { createdAt: -1 },\n    includeDeleted = false,\n    transactionId = null\n  } = options;\n\n  const query = {\n    $or: [{ from: userId }, { to: userId }],\n    isDeleted: false\n  };\n\n  if (transactionId) {\n    query.transactionId = transactionId;\n  }\n\n  if (includeDeleted) {\n    delete query.isDeleted;\n  }\n\n  return this.find(query)\n    .sort(sort)\n    .skip(skip)\n    .limit(limit)\n    .populate('from', 'name email phone')\n    .populate('to', 'name email phone')\n    .populate('transactionId', 'type itemDetails');\n};\n\n// EstatÃ­sticas de mensagens\ntransactionMessageSchema.statics.getStats = async function (userId = null) {\n  const matchStage = userId ? { $or: [{ from: userId }, { to: userId }] } : {};\n\n  const stats = await this.aggregate([\n    { $match: { ...matchStage, isDeleted: false } },\n    {\n      $group: {\n        _id: null,\n        totalMessages: { $sum: 1 },\n        textMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'text'] }, 1, 0] }\n        },\n        imageMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'image'] }, 1, 0] }\n        },\n        fileMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'file'] }, 1, 0] }\n        },\n        locationMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'location'] }, 1, 0] }\n        },\n        systemMessages: {\n          $sum: { $cond: [{ $eq: ['$type', 'system'] }, 1, 0] }\n        },\n        sentMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] }\n        },\n        deliveredMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'delivered'] }, 1, 0] }\n        },\n        readMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'read'] }, 1, 0] }\n        },\n        failedMessages: {\n          $sum: { $cond: [{ $eq: ['$status', 'failed'] }, 1, 0] }\n        }\n      }\n    }\n  ]);\n\n  return (\n    stats[0] || {\n      totalMessages: 0,\n      textMessages: 0,\n      imageMessages: 0,\n      fileMessages: 0,\n      locationMessages: 0,\n      systemMessages: 0,\n      sentMessages: 0,\n      deliveredMessages: 0,\n      readMessages: 0,\n      failedMessages: 0\n    }\n  );\n};\n\n// Buscar conversas ativas de um usuÃ¡rio\ntransactionMessageSchema.statics.findActiveConversations = function (userId, limit = 20) {\n  return this.aggregate([\n    {\n      $match: {\n        $or: [{ from: userId }, { to: userId }],\n        isDeleted: false\n      }\n    },\n    {\n      $group: {\n        _id: '$transactionId',\n        lastMessage: { $last: '$$ROOT' },\n        messageCount: { $sum: 1 },\n        unreadCount: {\n          $sum: {\n            $cond: [{ $and: [{ $eq: ['$to', userId] }, { $ne: ['$status', 'read'] }] }, 1, 0]\n          }\n        }\n      }\n    },\n    {\n      $sort: { 'lastMessage.createdAt': -1 }\n    },\n    {\n      $limit: limit\n    },\n    {\n      $lookup: {\n        from: 'transactions',\n        localField: '_id',\n        foreignField: '_id',\n        as: 'transaction'\n      }\n    },\n    {\n      $unwind: '$transaction'\n    },\n    {\n      $lookup: {\n        from: 'users',\n        localField: 'lastMessage.from',\n        foreignField: '_id',\n        as: 'fromUser'\n      }\n    },\n    {\n      $unwind: '$fromUser'\n    },\n    {\n      $lookup: {\n        from: 'users',\n        localField: 'lastMessage.to',\n        foreignField: '_id',\n        as: 'toUser'\n      }\n    },\n    {\n      $unwind: '$toUser'\n    }\n  ]);\n};\n\nconst TransactionMessage = mongoose.model('TransactionMessage', transactionMessageSchema);\n\nexport default TransactionMessage;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\User.js",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Argument expression expected.",
        "line": 488,
        "column": 69,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import mongoose from 'mongoose';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\n\nimport logger from '../utils/logger.js';\nconst userSchema = new mongoose.Schema(\n  {\n    // InformaÃ§Ãµes bÃ¡sicas\n    name: {\n      type: String,\n      required: [true, 'Nome Ã© obrigatÃ³rio'],\n      trim: true,\n      maxlength: [100, 'Nome nÃ£o pode ter mais de 100 caracteres']\n    },\n    email: {\n      type: String,\n      required: [true, 'E-mail Ã© obrigatÃ³rio'],\n      unique: true,\n      lowercase: true,\n      trim: true,\n      match: [/^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/, 'E-mail invÃ¡lido']\n    },\n    password: {\n      type: String,\n      required: [true, 'Senha Ã© obrigatÃ³ria'],\n      minlength: [8, 'Senha deve ter pelo menos 8 caracteres'],\n      select: false,\n      validate: {\n        validator(password) {\n          // ValidaÃ§Ã£o de senha forte\n          const strongPasswordRegex =\n            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/;\n          return strongPasswordRegex.test(password);\n        },\n        message:\n          'Senha deve conter pelo menos: 8 caracteres, 1 letra minÃºscula, 1 maiÃºscula, 1 nÃºmero e 1 caractere especial'\n      }\n    },\n    phone: {\n      type: String,\n      trim: true,\n      match: [/^\\+?[\\d\\s\\-()]+$/, 'Telefone invÃ¡lido']\n    },\n\n    // InformaÃ§Ãµes de perfil\n    avatar: {\n      type: String,\n      default: null\n    },\n    bio: {\n      type: String,\n      maxlength: [500, 'Biografia nÃ£o pode ter mais de 500 caracteres']\n    },\n    location: {\n      address: String,\n      city: String,\n      state: String,\n      country: {\n        type: String,\n        default: 'Brasil'\n      },\n      zipCode: String,\n      coordinates: {\n        lat: Number,\n        lng: Number\n      }\n    },\n\n    // InformaÃ§Ãµes de negÃ³cio\n    businessType: {\n      type: String,\n      enum: ['producer', 'buyer', 'transporter', 'all'],\n      default: 'all'\n    },\n    businessName: String,\n    businessDocument: String, // CPF/CNPJ\n    businessLicense: String,\n\n    // Dados PII criptografados\n    piiData: {\n      // Documentos pessoais\n      cpf: {\n        type: String,\n        default: null\n      },\n      cnpj: {\n        type: String,\n        default: null\n      },\n      rg: {\n        type: String,\n        default: null\n      },\n      passport: {\n        type: String,\n        default: null\n      },\n\n      // InformaÃ§Ãµes financeiras\n      bankAccount: {\n        type: String,\n        default: null\n      },\n      creditCard: {\n        type: String,\n        default: null\n      },\n\n      // InformaÃ§Ãµes fiscais\n      taxId: {\n        type: String,\n        default: null\n      },\n      businessId: {\n        type: String,\n        default: null\n      },\n\n      // Metadados de criptografia\n      encryptionMetadata: {\n        algorithm: {\n          type: String,\n          default: 'aes-256-gcm'\n        },\n        keyVersion: {\n          type: String,\n          default: '1.0'\n        },\n        lastEncrypted: {\n          type: Date,\n          default: null\n        }\n      }\n    },\n\n    // ConfiguraÃ§Ãµes de conta\n    isEmailVerified: {\n      type: Boolean,\n      default: false\n    },\n    emailVerificationToken: String,\n    emailVerificationExpires: Date,\n    verificationCode: String,\n    codeExpires: Date,\n\n    isPhoneVerified: {\n      type: Boolean,\n      default: false\n    },\n    phoneVerificationCode: String,\n    phoneVerificationExpires: Date,\n\n    // 2FA\n    twoFactorEnabled: {\n      type: Boolean,\n      default: false\n    },\n    twoFactorSecret: String,\n    twoFactorBackupCodes: [String],\n\n    // PermissÃµes de administrador\n    isAdmin: {\n      type: Boolean,\n      default: false\n    },\n    adminPermissions: [\n      {\n        type: String,\n        enum: [\n          'users_read',\n          'users_write',\n          'users_delete',\n          'products_read',\n          'products_write',\n          'products_delete',\n          'payments_read',\n          'payments_write',\n          'payments_refund',\n          'registrations_read',\n          'registrations_write',\n          'registrations_approve',\n          'system_settings',\n          'system_backup',\n          'system_logs',\n          'system_maintenance',\n          'audit_logs',\n          'admin_users',\n          'admin_roles',\n          '*' // Super admin\n        ]\n      }\n    ],\n    adminRole: {\n      type: String,\n      enum: ['super_admin', 'admin', 'moderator', 'support'],\n      default: null\n    },\n    adminNotes: {\n      type: String,\n      maxlength: [1000, 'Notas administrativas nÃ£o podem ter mais de 1000 caracteres']\n    },\n\n    // Plano e pagamentos\n    plan: {\n      type: String,\n      enum: ['free', 'basic', 'pro', 'enterprise'],\n      default: 'free'\n    },\n    planExpiresAt: Date,\n    subscriptionId: String,\n    paymentMethod: String,\n\n    // ConfiguraÃ§Ãµes de privacidade\n    privacySettings: {\n      profileVisibility: {\n        type: String,\n        enum: ['public', 'private', 'contacts'],\n        default: 'public'\n      },\n      showEmail: {\n        type: Boolean,\n        default: false\n      },\n      showPhone: {\n        type: Boolean,\n        default: false\n      },\n      showLocation: {\n        type: Boolean,\n        default: true\n      },\n      allowMessages: {\n        type: Boolean,\n        default: true\n      },\n      allowNotifications: {\n        type: Boolean,\n        default: true\n      }\n    },\n\n    // ConfiguraÃ§Ãµes de notificaÃ§Ã£o\n    notificationSettings: {\n      email: {\n        type: Boolean,\n        default: true\n      },\n      sms: {\n        type: Boolean,\n        default: false\n      },\n      push: {\n        type: Boolean,\n        default: true\n      },\n      marketing: {\n        type: Boolean,\n        default: false\n      }\n    },\n\n    // Status da conta\n    isActive: {\n      type: Boolean,\n      default: true\n    },\n    isSuspended: {\n      type: Boolean,\n      default: false\n    },\n    suspensionReason: String,\n    suspensionExpiresAt: Date,\n\n    // LGPD e consentimentos\n    lgpdConsent: {\n      type: Boolean,\n      default: false\n    },\n    lgpdConsentDate: Number,\n    dataProcessingConsent: {\n      type: Boolean,\n      default: false\n    },\n    marketingConsent: {\n      type: Boolean,\n      default: false\n    },\n\n    // Metadados de seguranÃ§a\n    lastLoginAt: Date,\n    lastLoginIp: String,\n    loginAttempts: {\n      type: Number,\n      default: 0\n    },\n    lockUntil: Date,\n    passwordChangedAt: Date,\n    passwordResetToken: String,\n    passwordResetExpires: Date,\n\n    // EstatÃ­sticas\n    stats: {\n      totalProducts: {\n        type: Number,\n        default: 0\n      },\n      totalTransactions: {\n        type: Number,\n        default: 0\n      },\n      totalRevenue: {\n        type: Number,\n        default: 0\n      },\n      reputation: {\n        type: Number,\n        default: 0\n      },\n      rating: {\n        type: Number,\n        default: 0\n      }\n    },\n\n    // ConfiguraÃ§Ãµes de idioma\n    language: {\n      type: String,\n      default: 'pt-BR',\n      enum: ['pt-BR', 'en-US', 'es-ES', 'zh-CN']\n    },\n    timezone: {\n      type: String,\n      default: 'America/Sao_Paulo'\n    },\n\n    // Metadados\n    metadata: {\n      type: mongoose.Schema.Types.Mixed,\n      default: {}\n    }\n  },\n  {\n    timestamps: true,\n    toJSON: {\n      transform(doc, ret) {\n        // Remover campos sensÃ­veis do JSON\n        delete ret.password;\n        delete ret.twoFactorSecret;\n        delete ret.twoFactorBackupCodes;\n        delete ret.passwordResetToken;\n        delete ret.emailVerificationToken;\n        delete ret.phoneVerificationCode;\n        delete ret.piiData;\n        delete ret.adminNotes;\n        delete ret.metadata;\n        return ret;\n      }\n    }\n  }\n);\n\n// Ãndices para performance e seguranÃ§a\nuserSchema.index({ email: 1 });\nuserSchema.index({ phone: 1 });\nuserSchema.index({ isActive: 1 });\nuserSchema.index({ isAdmin: 1 });\nuserSchema.index({ plan: 1 });\nuserSchema.index({ createdAt: -1 });\nuserSchema.index({ lastLoginAt: -1 });\n\n// Middleware para hash da senha antes de salvar\nuserSchema.pre('save', async function (next) {\n  // SÃ³ hash se a senha foi modificada\n  if (!this.isModified('password')) {\n    return next();\n  }\n\n  try {\n    // Hash da senha com salt rounds alto para seguranÃ§a\n    const saltRounds = 12;\n    this.password = await bcrypt.hash(this.password, saltRounds);\n    this.passwordChangedAt = new Date();\n    return next();\n  } catch (error) {\n    return next(error);\n  }\n});\n\n// Middleware para atualizar timestamp de mudanÃ§a de senha\nuserSchema.pre('save', function (next) {\n  if (!this.isModified('password') || this.isNew) {\n    return next();\n  }\n  this.passwordChangedAt = Date.now() - 1000;\n  return next();\n});\n\n// MÃ©todo para verificar senha\nuserSchema.methods.comparePassword = async function (candidatePassword) {\n  return await bcrypt.compare(candidatePassword, this.password);\n};\n\n// MÃ©todo para gerar token JWT\nuserSchema.methods.generateAuthToken = function () {\n  const payload = {\n    userId: this._id,\n    email: this.email,\n    isAdmin: this.isAdmin,\n    adminRole: this.adminRole,\n    plan: this.plan\n  };\n\n  return jwt.sign(payload, process.env.JWT_SECRET, {\n    expiresIn: process.env.JWT_EXPIRES_IN || '24h',\n    issuer: 'agroisync',\n    audience: 'agroisync-users'\n  });\n};\n\n// MÃ©todo para gerar token de verificaÃ§Ã£o de email\nuserSchema.methods.generateEmailVerificationToken = function () {\n  const token = jwt.sign({ userId: this._id, type: 'email_verification' }, process.env.JWT_SECRET, {\n    expiresIn: '24h'\n  });\n\n  this.emailVerificationToken = token;\n  this.emailVerificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000);\n\n  return token;\n};\n\n// MÃ©todo para gerar cÃ³digo de verificaÃ§Ã£o de telefone\nuserSchema.methods.generatePhoneVerificationCode = function () {\n  const code = Math.floor(100000 + Math.random() * 900000).toString();\n  this.phoneVerificationCode = code;\n  this.phoneVerificationExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutos\n  return code;\n};\n\n// MÃ©todo para gerar token de reset de senha\nuserSchema.methods.generatePasswordResetToken = function () {\n  const token = jwt.sign({ userId: this._id, type: 'password_reset' }, process.env.JWT_SECRET, {\n    expiresIn: '1h'\n  });\n\n  this.passwordResetToken = token;\n  this.passwordResetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1 hora\n\n  return token;\n};\n\n// MÃ©todo para verificar se a conta estÃ¡ bloqueada\nuserSchema.methods.isLocked = function () {\n  return !!(this.lockUntil && this.lockUntil > Date.now());\n};\n\n// MÃ©todo para incrementar tentativas de login\nuserSchema.methods.incLoginAttempts = function () {\n  // Se temos tentativas anteriores e nÃ£o estÃ¡ bloqueado, incrementar\n  if (this.lockUntil && this.lockUntil < Date.now()) {\n    return this.updateOne({\n      $unset: { lockUntil: 1 },\n      $set: { loginAttempts: 1 }\n    });\n  }\n\n  const updates = { $inc: { loginAttempts: 1 } };\n\n  // Bloquear conta apÃ³s 5 tentativas por 2 horas\n  if (this.loginAttempts + 1 >= 5 && !this.isLocked()) {\n    updates.$set = { lockUntil: Date.now() + 2 * 60 * 60 * 1000 }; // 2 horas\n  }\n\n  return this.updateOne(updates);\n};\n\n// MÃ©todo para resetar tentativas de login\nuserSchema.methods.resetLoginAttempts = function () {\n  return this.updateOne({\n    $unset: { loginAttempts: 1, lockUntil: 1 }\n  });\n};\n\n// MÃ©todo para verificar se mudou senha apÃ³s o token JWT\nuserSchema.methods.changedPasswordAfter = function (JWTTimestamp) {\n  if (this.passwordChangedAt) {\n    const changedTimestamp = parseInt(this.passwordChangedAt.getTime(, 10) / 1000, 10);\n    return JWTTimestamp < changedTimestamp;\n  }\n  return false;\n};\n\n// MÃ©todos para criptografia de dados PII\nuserSchema.methods.encryptPIIData = function (data) {\n  const algorithm = 'aes-256-gcm';\n  const key = process.env.PII_ENCRYPTION_KEY || 'default-pii-key-change-in-production';\n\n  try {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher(algorithm, key);\n    cipher.setAAD(Buffer.from('pii-data', 'utf8'));\n\n    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n\n    const authTag = cipher.getAuthTag();\n\n    return {\n      encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex'),\n      algorithm,\n      keyVersion: '1.0'\n    };\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao criptografar dados PII:', error);\n    }\n    throw error;\n  }\n};\n\nuserSchema.methods.decryptPIIData = function (encryptedData) {\n  const key = process.env.PII_ENCRYPTION_KEY || 'default-pii-key-change-in-production';\n\n  try {\n    const decipher = crypto.createDecipher(encryptedData.algorithm, key);\n    decipher.setAAD(Buffer.from('pii-data', 'utf8'));\n    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));\n\n    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n\n    return JSON.parse(decrypted);\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao descriptografar dados PII:', error);\n    }\n    throw error;\n  }\n};\n\nuserSchema.methods.setPIIData = function (field, value) {\n  if (!this.piiData) {\n    this.piiData = {};\n  }\n\n  if (value) {\n    const encrypted = this.encryptPIIData(value);\n    this.piiData[field] = encrypted;\n    this.piiData.encryptionMetadata.lastEncrypted = new Date();\n  } else {\n    this.piiData[field] = null;\n  }\n\n  return this;\n};\n\nuserSchema.methods.getPIIData = function (field) {\n  if (!this.piiData || !this.piiData[field]) {\n    return null;\n  }\n\n  try {\n    return this.decryptPIIData(this.piiData[field]);\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Erro ao descriptografar campo PII ${field}:`, error);\n    }\n    return null;\n  }\n};\n\nuserSchema.methods.hasPIIData = function (field) {\n  return !!(this.piiData && this.piiData[field]);\n};\n\n// MÃ©todo estÃ¡tico para buscar usuÃ¡rio por email\nuserSchema.statics.findByEmail = function (email) {\n  return this.findOne({ email: email.toLowerCase() });\n};\n\n// MÃ©todo estÃ¡tico para buscar usuÃ¡rios ativos\nuserSchema.statics.findActive = function () {\n  return this.find({ isActive: true, isSuspended: false });\n};\n\n// MÃ©todo estÃ¡tico para buscar administradores\nuserSchema.statics.findAdmins = function () {\n  return this.find({ isAdmin: true, isActive: true });\n};\n\n// MÃ©todo para sanitizar dados antes de retornar\nuserSchema.methods.sanitize = function () {\n  const user = this.toObject();\n  delete user.password;\n  delete user.twoFactorSecret;\n  delete user.twoFactorBackupCodes;\n  delete user.passwordResetToken;\n  delete user.emailVerificationToken;\n  delete user.phoneVerificationCode;\n  delete user.piiData;\n  return user;\n};\n\nconst User = mongoose.model('User', userSchema);\n\nexport default User;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\UserD1.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\UserReputation.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\models\\Vehicle.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\addressValidation.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'validationResult' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 2,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport addressValidationService from '../services/addressValidationService.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/address/validate:\n *   post:\n *     summary: Validar endereÃ§o internacional\n *     tags: [Address]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - country\n *             properties:\n *               country:\n *                 type: string\n *                 description: CÃ³digo do paÃ­s (BR, CN, US, etc.)\n *               zipCode:\n *                 type: string\n *                 description: CEP/CÃ³digo postal\n *               address:\n *                 type: string\n *                 description: EndereÃ§o completo\n *               city:\n *                 type: string\n *                 description: Cidade\n *               state:\n *                 type: string\n *                 description: Estado/ProvÃ­ncia\n *               province:\n *                 type: string\n *                 description: ProvÃ­ncia (para China)\n *     responses:\n *       200:\n *         description: Resultado da validaÃ§Ã£o\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post(\n  '/validate',\n  [\n    body('country').notEmpty().withMessage('PaÃ­s Ã© obrigatÃ³rio'),\n    body('zipCode').optional().isLength({ min: 5, max: 10 }).withMessage('CEP invÃ¡lido'),\n    body('address').optional().isLength({ min: 5 }).withMessage('EndereÃ§o muito curto'),\n    body('city').optional().isLength({ min: 2 }).withMessage('Cidade invÃ¡lida'),\n    body('state').optional().isLength({ min: 2 }).withMessage('Estado invÃ¡lido')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { country, zipCode, address, city, state, province } = req.body;\n\n      const validationResult = await addressValidationService.validateAddress({\n        country,\n        zipCode,\n        address,\n        city,\n        state,\n        province\n      });\n\n      logger.info(`ValidaÃ§Ã£o de endereÃ§o realizada para paÃ­s: ${country}`);\n\n      res.status(200).json({\n        success: true,\n        data: validationResult\n      });\n    } catch (error) {\n      logger.error('Erro na validaÃ§Ã£o de endereÃ§o:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/address/countries:\n *   get:\n *     summary: Listar paÃ­ses suportados\n *     tags: [Address]\n *     responses:\n *       200:\n *         description: Lista de paÃ­ses suportados\n */\nrouter.get('/countries', (req, res) => {\n  try {\n    const countries = addressValidationService.getSupportedCountries();\n\n    res.status(200).json({\n      success: true,\n      data: {\n        countries\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao listar paÃ­ses:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/address/format/{country}:\n *   get:\n *     summary: Obter formato de endereÃ§o por paÃ­s\n *     tags: [Address]\n *     parameters:\n *       - in: path\n *         name: country\n *         required: true\n *         schema:\n *           type: string\n *           description: CÃ³digo do paÃ­s\n *     responses:\n *       200:\n *         description: Formato de endereÃ§o\n *       404:\n *         description: PaÃ­s nÃ£o suportado\n */\nrouter.get('/format/:country', (req, res) => {\n  try {\n    const { country } = req.params;\n    const format = addressValidationService.getAddressFormat(country.toUpperCase());\n\n    if (!format) {\n      return res.status(404).json({\n        success: false,\n        message: 'PaÃ­s nÃ£o suportado'\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        country: country.toUpperCase(),\n        format\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter formato de endereÃ§o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/address/format:\n *   post:\n *     summary: Formatar endereÃ§o para exibiÃ§Ã£o\n *     tags: [Address]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - addressData\n *             properties:\n *               addressData:\n *                 type: object\n *                 properties:\n *                   street:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   zipCode:\n *                     type: string\n *                   country:\n *                     type: string\n *     responses:\n *       200:\n *         description: EndereÃ§o formatado\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post('/format', (req, res) => {\n  try {\n    const { addressData } = req.body;\n\n    if (!addressData) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados do endereÃ§o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const formattedAddress = addressValidationService.formatAddress(addressData);\n\n    res.status(200).json({\n      success: true,\n      data: {\n        formattedAddress\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao formatar endereÃ§o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\admin.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\ai.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\analytics.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\api.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\apis-externas.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\auditLogs.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'offset' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 22,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 22,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport auth from '../middleware/auth.js';\nimport adminAuth from '../middleware/adminAuth.js';\nimport auditService from '../services/auditService.js';\nimport { captureSessionInfo, captureRequestMetadata } from '../middleware/sessionCapture.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Middleware para capturar informaÃ§Ãµes de sessÃ£o\nrouter.use(captureSessionInfo);\nrouter.use(captureRequestMetadata);\n\n/**\n * @route GET /api/audit-logs\n * @desc Obter logs de auditoria do usuÃ¡rio\n * @access Private\n */\nrouter.get('/', auth, async (req, res) => {\n  try {\n    const { limit = 100, page = 1 } = req.query;\n    const offset = (page - 1) * limit;\n\n    const logs = await auditService.getUserAuditLogs(req.user.id, parseInt(limit, 10, 10));\n\n    res.json({\n      success: true,\n      data: logs,\n      pagination: {\n        page: parseInt(page, 10, 10),\n        limit: parseInt(limit, 10, 10),\n        total: logs.length\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter logs de auditoria:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/pii-access\n * @desc Obter logs de acesso a dados PII\n * @access Private (Admin)\n */\nrouter.get('/pii-access', adminAuth, async (req, res) => {\n  try {\n    const { userId, limit = 100 } = req.query;\n\n    const logs = await auditService.getPIIAccessLogs(userId || null, parseInt(limit, 10, 10));\n\n    res.json({\n      success: true,\n      data: logs\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter logs de acesso PII:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/stats\n * @desc Obter estatÃ­sticas de auditoria\n * @access Private (Admin)\n */\nrouter.get('/stats', adminAuth, async (req, res) => {\n  try {\n    const { startDate, endDate } = req.query;\n\n    if (!startDate || !endDate) {\n      return res.status(400).json({\n        success: false,\n        message: 'Data de inÃ­cio e fim sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    const stats = await auditService.getAuditStats(new Date(startDate), new Date(endDate));\n\n    res.json({\n      success: true,\n      data: stats\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas de auditoria:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/expiring\n * @desc Obter logs prÃ³ximos do vencimento\n * @access Private (Admin)\n */\nrouter.get('/expiring', adminAuth, async (req, res) => {\n  try {\n    const logs = await auditService.getExpiringLogs();\n\n    res.json({\n      success: true,\n      data: logs\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter logs prÃ³ximos do vencimento:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route POST /api/audit-logs/export\n * @desc Exportar logs de auditoria\n * @access Private (Admin)\n */\nrouter.post('/export', adminAuth, async (req, res) => {\n  try {\n    const { startDate, endDate, userId, action, resource, containsPII } = req.body;\n\n    if (!startDate || !endDate) {\n      return res.status(400).json({\n        success: false,\n        message: 'Data de inÃ­cio e fim sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    const logs = await auditService.exportAuditLogs({\n      startDate: new Date(startDate),\n      endDate: new Date(endDate),\n      userId,\n      action,\n      resource,\n      containsPII\n    });\n\n    res.json({\n      success: true,\n      data: logs,\n      exportedAt: new Date(),\n      totalRecords: logs.length\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao exportar logs de auditoria:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route DELETE /api/audit-logs/cleanup\n * @desc Limpar logs expirados\n * @access Private (Admin)\n */\nrouter.delete('/cleanup', adminAuth, async (req, res) => {\n  try {\n    const deletedCount = await auditService.cleanExpiredLogs();\n\n    res.json({\n      success: true,\n      message: `${deletedCount} logs expirados foram removidos`,\n      deletedCount\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao limpar logs expirados:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/:id/verify\n * @desc Verificar integridade de um log especÃ­fico\n * @access Private (Admin)\n */\nrouter.get('/:id/verify', adminAuth, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const isValid = await auditService.verifyLogIntegrity(id);\n\n    res.json({\n      success: true,\n      data: {\n        logId: id,\n        isValid\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar integridade do log:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @route GET /api/audit-logs/:id\n * @desc Obter detalhes de um log especÃ­fico\n * @access Private (Admin)\n */\nrouter.get('/:id', adminAuth, async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // Importar modelo AuditLog\n    const AuditLog = (await import('../models/AuditLog.js')).default;\n    const log = await AuditLog.findById(id);\n\n    if (!log) {\n      return res.status(404).json({\n        success: false,\n        message: 'Log nÃ£o encontrado'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: log\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter log especÃ­fico:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\auth.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\chat.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 11
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'cloudflareService' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 13,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 13,
        "endColumn": 24
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 25,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 25,
        "endColumn": 27
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 27,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 27,
        "endColumn": 16
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 54,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 54,
        "endColumn": 21
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 56,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 56,
        "endColumn": 61
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'chat' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 416,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 416,
        "endColumn": 60
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const express = require('express');\nconst { body, validationResult } = require('express-validator');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs').promises;\nconst { v4: uuidv4 } = require('uuid');\nconst Chat = require('../models/Chat');\nconst User = require('../models/User');\nconst FreightOrder = require('../models/FreightOrder');\nconst { auth } = require('../middleware/auth');\nconst logger = require('../utils/logger');\nconst openaiService = require('../services/openaiService');\nconst cloudflareService = require('../services/cloudflareService');\n\nconst router = express.Router();\n\n// ConfiguraÃ§Ã£o do multer para upload de arquivos\nconst storage = multer.diskStorage({\n  destination: async (req, file, cb) => {\n    const userId = req.user?.id || 'anonymous';\n    const uploadPath = path.join('uploads', 'chats', userId);\n\n    try {\n      await fs.mkdir(uploadPath, { recursive: true });\n      cb(null, uploadPath);\n    } catch (error) {\n      cb(error);\n    }\n  },\n  filename: (req, file, cb) => {\n    const uniqueName = `${uuidv4()}-${file.originalname}`;\n    cb(null, uniqueName);\n  }\n});\n\nconst upload = multer({\n  storage,\n  limits: {\n    fileSize: 10 * 1024 * 1024, // 10MB\n    files: 5\n  },\n  fileFilter: (req, file, cb) => {\n    const allowedTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'image/webp',\n      'audio/mpeg',\n      'audio/wav',\n      'audio/ogg'\n    ];\n\n    if (allowedTypes.includes(file.mimetype)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Tipo de arquivo nÃ£o permitido'), false);\n    }\n  }\n});\n\n/**\n * @swagger\n * /api/chat/send:\n *   post:\n *     summary: Enviar mensagem para o chatbot\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         multipart/form-data:\n *           schema:\n *             type: object\n *             required:\n *               - message\n *             properties:\n *               message:\n *                 type: string\n *               conversationId:\n *                 type: string\n *               attachments:\n *                 type: array\n *                 items:\n *                   type: string\n *                   format: binary\n *     responses:\n *       200:\n *         description: Mensagem enviada com sucesso\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post(\n  '/send',\n  auth,\n  upload.array('attachments', 5),\n  [\n    body('message').notEmpty().withMessage('Mensagem Ã© obrigatÃ³ria'),\n    body('conversationId').optional().isString()\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { message, conversationId } = req.body;\n      const userId = req.user.id;\n      const attachments = req.files || [];\n\n      // Buscar ou criar conversa\n      let chat;\n      if (conversationId) {\n        chat = await Chat.findByConversationId(conversationId);\n        if (!chat || (chat.userId && chat.userId.toString() !== userId)) {\n          return res.status(404).json({\n            success: false,\n            message: 'Conversa nÃ£o encontrada'\n          });\n        }\n      } else {\n        chat = await Chat.createConversation(userId, 'general');\n      }\n\n      // Processar anexos\n      const processedAttachments = [];\n      for (const file of attachments) {\n        const attachment = {\n          type: file.mimetype.startsWith('image/') ? 'image' : 'voice',\n          url: `/uploads/chats/${userId}/${file.filename}`,\n          filename: file.originalname,\n          size: file.size,\n          mimeType: file.mimetype\n        };\n\n        // Se for imagem, gerar caption com IA\n        if (attachment.type === 'image') {\n          try {\n            const caption = await openaiService.generateImageCaption(file.path);\n            attachment.caption = caption;\n            attachment.altText = caption;\n          } catch (error) {\n            logger.error('Erro ao gerar caption da imagem:', error);\n            attachment.caption = 'Imagem enviada';\n            attachment.altText = 'Imagem enviada pelo usuÃ¡rio';\n          }\n        }\n\n        processedAttachments.push(attachment);\n      }\n\n      // Adicionar mensagem do usuÃ¡rio\n      await chat.addMessage('user', message, {\n        attachments: processedAttachments,\n        status: 'delivered'\n      });\n\n      // Verificar se Ã© comando especial (logÃ­stica)\n      const isLogisticsCommand = await handleLogisticsCommand(message, userId, chat);\n\n      let aiResponse = '';\n      if (!isLogisticsCommand) {\n        // Gerar resposta da IA\n        aiResponse = await openaiService.generateResponse(chat.messages, userId);\n      } else {\n        aiResponse = isLogisticsCommand;\n      }\n\n      // Adicionar resposta da IA\n      await chat.addMessage('assistant', aiResponse, {\n        status: 'delivered'\n      });\n\n      logger.info(`Mensagem enviada na conversa ${chat.conversationId} por usuÃ¡rio ${userId}`);\n\n      res.status(200).json({\n        success: true,\n        message: 'Mensagem enviada com sucesso',\n        data: {\n          conversationId: chat.conversationId,\n          userMessage: {\n            role: 'user',\n            text: message,\n            attachments: processedAttachments,\n            timestamp: new Date()\n          },\n          aiResponse: {\n            role: 'assistant',\n            text: aiResponse,\n            timestamp: new Date()\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao enviar mensagem:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/chat/{conversationId}:\n *   get:\n *     summary: Obter histÃ³rico da conversa\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: conversationId\n *         required: true\n *         schema:\n *           type: string\n *     responses:\n *       200:\n *         description: HistÃ³rico da conversa\n *       404:\n *         description: Conversa nÃ£o encontrada\n */\nrouter.get('/:conversationId', auth, async (req, res) => {\n  try {\n    const { conversationId } = req.params;\n    const userId = req.user.id;\n\n    const chat = await Chat.findByConversationId(conversationId);\n\n    if (!chat || (chat.userId && chat.userId.toString() !== userId)) {\n      return res.status(404).json({\n        success: false,\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        conversationId: chat.conversationId,\n        messages: chat.messages,\n        settings: chat.settings,\n        stats: chat.stats,\n        createdAt: chat.createdAt,\n        updatedAt: chat.updatedAt\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter conversa:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/chat/conversations:\n *   get:\n *     summary: Listar conversas do usuÃ¡rio\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       200:\n *         description: Lista de conversas\n */\nrouter.get('/', auth, async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const conversations = await Chat.findByUserId(userId);\n\n    res.status(200).json({\n      success: true,\n      data: {\n        conversations: conversations.map(chat => ({\n          conversationId: chat.conversationId,\n          context: chat.context,\n          lastMessage: chat.lastMessage,\n          messageCount: chat.messageCount,\n          lastActivityAt: chat.stats.lastActivityAt,\n          createdAt: chat.createdAt\n        }))\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao listar conversas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/chat/upload:\n *   post:\n *     summary: Upload de arquivo para chat\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         multipart/form-data:\n *           schema:\n *             type: object\n *             properties:\n *               file:\n *                 type: string\n *                 format: binary\n *     responses:\n *       200:\n *         description: Arquivo enviado com sucesso\n */\nrouter.post('/upload', auth, upload.single('file'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhum arquivo enviado'\n      });\n    }\n\n    const userId = req.user.id;\n    const fileUrl = `/uploads/chats/${userId}/${req.file.filename}`;\n\n    // Se for imagem, gerar caption\n    let caption = null;\n    if (req.file.mimetype.startsWith('image/')) {\n      try {\n        caption = await openaiService.generateImageCaption(req.file.path);\n      } catch (error) {\n        logger.error('Erro ao gerar caption:', error);\n      }\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        url: fileUrl,\n        filename: req.file.originalname,\n        size: req.file.size,\n        mimeType: req.file.mimetype,\n        caption\n      }\n    });\n  } catch (error) {\n    logger.error('Erro no upload:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/chat/voice:\n *   post:\n *     summary: Processar Ã¡udio de voz\n *     tags: [Chat]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         multipart/form-data:\n *           schema:\n *             type: object\n *             properties:\n *               audio:\n *                 type: string\n *                 format: binary\n *     responses:\n *       200:\n *         description: Ãudio processado com sucesso\n */\nrouter.post('/voice', auth, upload.single('audio'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhum arquivo de Ã¡udio enviado'\n      });\n    }\n\n    // Transcrever Ã¡udio usando OpenAI Whisper\n    const transcription = await openaiService.transcribeAudio(req.file.path);\n\n    res.status(200).json({\n      success: true,\n      data: {\n        transcription,\n        audioUrl: `/uploads/chats/${req.user.id}/${req.file.filename}`\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao processar Ã¡udio:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// FunÃ§Ã£o auxiliar para lidar com comandos de logÃ­stica\nasync function handleLogisticsCommand(message, userId, chat) {\n  const lowerMessage = message.toLowerCase();\n\n  // Verificar se Ã© comando de criaÃ§Ã£o de frete\n  if (lowerMessage.includes('criar frete') || lowerMessage.includes('criar pedido de frete')) {\n    try {\n      // Extrair informaÃ§Ãµes do comando usando IA\n      const freightInfo = await openaiService.extractFreightInfo(message);\n\n      if (freightInfo) {\n        // Criar pedido de frete\n        const freightOrder = new FreightOrder({\n          buyerId: userId,\n          sellerId: freightInfo.sellerId || userId, // Por enquanto, mesmo usuÃ¡rio\n          origin: freightInfo.origin,\n          destination: freightInfo.destination,\n          pickupDate: freightInfo.pickupDate,\n          deliveryDateEstimate: freightInfo.deliveryDateEstimate,\n          items: freightInfo.items,\n          pricing: freightInfo.pricing\n        });\n\n        await freightOrder.save();\n\n        return `âœ… Pedido de frete criado com sucesso!\\n\\nðŸ“‹ **Detalhes do Pedido:**\\n- NÃºmero: ${freightOrder.orderNumber}\\n- Origem: ${freightOrder.origin.city}, ${freightOrder.origin.state}\\n- Destino: ${freightOrder.destination.city}, ${freightOrder.destination.state}\\n- Data de coleta: ${freightOrder.pickupDate.toLocaleDateString('pt-BR')}\\n- PreÃ§o total: R$ ${freightOrder.pricing.totalPrice.toFixed(2)}\\n\\nðŸš› O pedido estÃ¡ aguardando aceitaÃ§Ã£o de transportadores.`;\n      }\n    } catch (error) {\n      logger.error('Erro ao criar pedido de frete:', error);\n      return 'âŒ Erro ao criar pedido de frete. Tente novamente ou use o formulÃ¡rio da plataforma.';\n    }\n  }\n\n  // Verificar se Ã© comando de rastreamento\n  if (lowerMessage.includes('rastrear') || lowerMessage.includes('status do frete')) {\n    try {\n      // Extrair nÃºmero do pedido da mensagem\n      const orderNumber = message.match(/FR-\\d+-\\w+/)?.[0];\n\n      if (orderNumber) {\n        const freightOrder = await FreightOrder.findOne({ orderNumber });\n\n        if (freightOrder) {\n          const lastEvent = freightOrder.trackingEvents[freightOrder.trackingEvents.length - 1];\n          return `ðŸ“¦ **Status do Frete ${orderNumber}:**\\n\\nðŸš› Status atual: ${freightOrder.status}\\nðŸ“ Ãšltima localizaÃ§Ã£o: ${lastEvent?.location?.city || 'NÃ£o informada'}\\nðŸ“… Ãšltima atualizaÃ§Ã£o: ${lastEvent?.timestamp?.toLocaleString('pt-BR') || 'NÃ£o disponÃ­vel'}\\n\\nðŸ’¡ Para mais detalhes, acesse a pÃ¡gina do pedido na plataforma.`;\n        } else {\n          return 'âŒ Pedido de frete nÃ£o encontrado. Verifique o nÃºmero do pedido.';\n        }\n      }\n    } catch (error) {\n      logger.error('Erro ao rastrear frete:', error);\n      return 'âŒ Erro ao consultar status do frete. Tente novamente.';\n    }\n  }\n\n  return null; // NÃ£o Ã© comando especial\n}\n\nmodule.exports = router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\clients.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 4,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 12
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'requireAdmin' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 6,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 22
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'createSecurityLog' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport Client from '../models/Client.js';\nimport User from '../models/User.js';\nimport { authenticateToken, adminAuth } from '../middleware/auth.js';\nimport { requireAdmin } from '../middleware/adminAuth.js';\nimport { getClientIP } from '../utils/ipUtils.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\nimport { logSecurityEvent } from '../services/auditService.js';\nimport {\n  validateReceitaFederal,\n  validateAddressIBGE,\n  validateRequiredDocuments\n} from '../middleware/documentValidation.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Middleware de validaÃ§Ã£o para criaÃ§Ã£o/atualizaÃ§Ã£o de cliente\nconst validateClientData = [\n  body('name')\n    .trim()\n    .isLength({ min: 2, max: 100 })\n    .withMessage('Nome deve ter entre 2 e 100 caracteres'),\n  body('email').isEmail().normalizeEmail().withMessage('Email invÃ¡lido'),\n  body('cpfCnpj').trim().isLength({ min: 11, max: 18 }).withMessage('CPF/CNPJ invÃ¡lido'),\n  body('phone').trim().isLength({ min: 10, max: 15 }).withMessage('Telefone invÃ¡lido'),\n  body('address.street').trim().isLength({ min: 5, max: 200 }).withMessage('EndereÃ§o invÃ¡lido'),\n  body('address.city').trim().isLength({ min: 2, max: 100 }).withMessage('Cidade invÃ¡lida'),\n  body('address.state').trim().isLength({ min: 2, max: 2 }).withMessage('Estado invÃ¡lido'),\n  body('address.zipCode').trim().isLength({ min: 8, max: 9 }).withMessage('CEP invÃ¡lido'),\n  body('documents').isArray({ min: 1 }).withMessage('Pelo menos um documento Ã© obrigatÃ³rio')\n];\n\n// GET /api/clients - Listar clientes (admin vÃª todos, usuÃ¡rio vÃª apenas os seus)\nrouter.get('/', authenticateToken, async (req, res) => {\n  try {\n    const query = {};\n\n    // Se nÃ£o for admin, sÃ³ mostra os clientes do usuÃ¡rio\n    if (!req.user.isAdmin) {\n      query.userId = req.user._id;\n    }\n\n    const clients = await Client.find(query)\n      .populate('userId', 'name email')\n      .sort({ createdAt: -1 });\n\n    res.json({\n      success: true,\n      data: clients,\n      count: clients.length\n    });\n  } catch (error) {\n    logger.error('Erro ao listar clientes:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/clients/:id - Obter cliente especÃ­fico\nrouter.get('/:id', authenticateToken, async (req, res) => {\n  try {\n    const client = await Client.findById(req.params.id).populate('userId', 'name email');\n\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se usuÃ¡rio tem permissÃ£o para ver este cliente\n    if (!req.user.isAdmin && client.userId._id.toString() !== req.user._id.toString()) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: client\n    });\n  } catch (error) {\n    logger.error('Erro ao obter cliente:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/clients - Criar novo cliente\nrouter.post(\n  '/',\n  authenticateToken,\n  validateClientData,\n  validateReceitaFederal,\n  validateAddressIBGE,\n  validateRequiredDocuments,\n  async (req, res) => {\n    try {\n      // Verificar erros de validaÃ§Ã£o\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      // Verificar se CPF/CNPJ jÃ¡ existe\n      const existingClient = await Client.findOne({ cpfCnpj: req.body.cpfCnpj });\n      if (existingClient) {\n        return res.status(400).json({\n          success: false,\n          message: 'CPF/CNPJ jÃ¡ cadastrado'\n        });\n      }\n\n      // Verificar se email jÃ¡ existe\n      const existingEmail = await Client.findOne({ email: req.body.email });\n      if (existingEmail) {\n        return res.status(400).json({\n          success: false,\n          message: 'Email jÃ¡ cadastrado'\n        });\n      }\n\n      // Criar cliente\n      const clientData = {\n        ...req.body,\n        userId: req.user._id\n      };\n\n      const client = new Client(clientData);\n      await client.save();\n\n      // Log de seguranÃ§a\n      await logSecurityEvent(\n        'client_created',\n        req.user._id,\n        getClientIP(req),\n        req.headers['user-agent'],\n        { clientId: client._id }\n      );\n\n      res.status(201).json({\n        success: true,\n        message: 'Cliente criado com sucesso',\n        data: client\n      });\n    } catch (error) {\n      logger.error('Erro ao criar cliente:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// PUT /api/clients/:id - Atualizar cliente\nrouter.put(\n  '/:id',\n  authenticateToken,\n  validateClientData,\n  validateReceitaFederal,\n  validateAddressIBGE,\n  validateRequiredDocuments,\n  async (req, res) => {\n    try {\n      // Verificar erros de validaÃ§Ã£o\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const client = await Client.findById(req.params.id);\n      if (!client) {\n        return res.status(404).json({\n          success: false,\n          message: 'Cliente nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se usuÃ¡rio tem permissÃ£o para editar este cliente\n      if (!req.user.isAdmin && client.userId.toString() !== req.user._id.toString()) {\n        return res.status(403).json({\n          success: false,\n          message: 'Acesso negado'\n        });\n      }\n\n      // Verificar se CPF/CNPJ jÃ¡ existe em outro cliente\n      if (req.body.cpfCnpj && req.body.cpfCnpj !== client.cpfCnpj) {\n        const existingClient = await Client.findOne({ cpfCnpj: req.body.cpfCnpj });\n        if (existingClient) {\n          return res.status(400).json({\n            success: false,\n            message: 'CPF/CNPJ jÃ¡ cadastrado'\n          });\n        }\n      }\n\n      // Verificar se email jÃ¡ existe em outro cliente\n      if (req.body.email && req.body.email !== client.email) {\n        const existingEmail = await Client.findOne({ email: req.body.email });\n        if (existingEmail) {\n          return res.status(400).json({\n            success: false,\n            message: 'Email jÃ¡ cadastrado'\n          });\n        }\n      }\n\n      // Atualizar cliente\n      const updatedClient = await Client.findByIdAndUpdate(req.params.id, req.body, {\n        new: true,\n        runValidators: true\n      });\n\n      // Log de seguranÃ§a\n      await logSecurityEvent(\n        'client_updated',\n        req.user._id,\n        getClientIP(req),\n        req.headers['user-agent'],\n        { clientId: client._id }\n      );\n\n      res.json({\n        success: true,\n        message: 'Cliente atualizado com sucesso',\n        data: updatedClient\n      });\n    } catch (error) {\n      logger.error('Erro ao atualizar cliente:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// DELETE /api/clients/:id - Deletar cliente\nrouter.delete('/:id', authenticateToken, async (req, res) => {\n  try {\n    const client = await Client.findById(req.params.id);\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se usuÃ¡rio tem permissÃ£o para deletar este cliente\n    if (!req.user.isAdmin && client.userId.toString() !== req.user._id.toString()) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    await Client.findByIdAndDelete(req.params.id);\n\n    // Log de seguranÃ§a\n    await logSecurityEvent(\n      'client_deleted',\n      req.user._id,\n      getClientIP(req),\n      req.headers['user-agent'],\n      { clientId: client._id }\n    );\n\n    res.json({\n      success: true,\n      message: 'Cliente deletado com sucesso'\n    });\n  } catch (error) {\n    logger.error('Erro ao deletar cliente:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/clients/:id/validate-documents - Validar documentos (admin)\nrouter.patch('/:id/validate-documents', adminAuth, async (req, res) => {\n  try {\n    const client = await Client.findById(req.params.id);\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    client.isDocumentValidated = true;\n    await client.save();\n\n    // Log de seguranÃ§a\n    await logSecurityEvent(\n      'client_documents_validated',\n      req.user._id,\n      getClientIP(req),\n      req.headers['user-agent'],\n      { clientId: client._id }\n    );\n\n    res.json({\n      success: true,\n      message: 'Documentos validados com sucesso',\n      data: client\n    });\n  } catch (error) {\n    logger.error('Erro ao validar documentos:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/clients/:id/verify-payment - Verificar pagamento (admin)\nrouter.patch('/:id/verify-payment', adminAuth, async (req, res) => {\n  try {\n    const { paymentStatus, transactionId } = req.body;\n\n    if (\n      !paymentStatus ||\n      !['pending', 'approved', 'rejected', 'cancelled'].includes(paymentStatus)\n    ) {\n      return res.status(400).json({\n        success: false,\n        message: 'Status de pagamento invÃ¡lido'\n      });\n    }\n\n    const client = await Client.findById(req.params.id);\n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        message: 'Cliente nÃ£o encontrado'\n      });\n    }\n\n    client.paymentStatus = paymentStatus;\n    if (transactionId) {\n      client.transactionId = transactionId;\n    }\n\n    if (paymentStatus === 'approved') {\n      client.isPaymentVerified = true;\n    }\n\n    await client.save();\n\n    // Log de seguranÃ§a\n    await logSecurityEvent(\n      'client_payment_verified',\n      req.user._id,\n      getClientIP(req),\n      req.headers['user-agent'],\n      { clientId: client._id, paymentStatus, transactionId }\n    );\n\n    res.json({\n      success: true,\n      message: 'Pagamento verificado com sucesso',\n      data: client\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar pagamento:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/clients/stats/overview - EstatÃ­sticas gerais (admin)\nrouter.get('/stats/overview', adminAuth, async (req, res) => {\n  try {\n    const stats = await Client.aggregate([\n      {\n        $group: {\n          _id: null,\n          total: { $sum: 1 },\n          validated: { $sum: { $cond: ['$isDocumentValidated', 1, 0] } },\n          paymentVerified: { $sum: { $cond: ['$isPaymentVerified', 1, 0] } },\n          active: { $sum: { $cond: ['$isActive', 1, 0] } }\n        }\n      }\n    ]);\n\n    const paymentStats = await Client.aggregate([\n      {\n        $group: {\n          _id: '$paymentStatus',\n          count: { $sum: 1 }\n        }\n      }\n    ]);\n\n    const monthlyStats = await Client.aggregate([\n      {\n        $group: {\n          _id: {\n            year: { $year: '$createdAt' },\n            month: { $month: '$createdAt' }\n          },\n          count: { $sum: 1 }\n        }\n      },\n      { $sort: { '_id.year': -1, '_id.month': -1 } },\n      { $limit: 12 }\n    ]);\n\n    res.json({\n      success: true,\n      data: {\n        overview: stats[0] || { total: 0, validated: 0, paymentVerified: 0, active: 0 },\n        paymentStatus: paymentStats,\n        monthlyGrowth: monthlyStats\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter estatÃ­sticas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\contact.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'phone' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 18,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 18,
        "endColumn": 47
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'company' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 18,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 18,
        "endColumn": 56
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'phone' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 78,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 78,
        "endColumn": 10
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'website' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 79,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 79,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport ContactMessage from '../models/ContactMessage.js';\nimport PartnershipMessage from '../models/PartnershipMessage.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\nimport { sanitizeInput } from '../utils/sanitizer.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO =====\n\n// ValidaÃ§Ã£o para mensagens de contato\nconst validateContactMessage = (req, res, next) => {\n  const { name, email, subject, message, phone, company, category } = req.body;\n\n  if (!name || !email || !subject || !message) {\n    return res.status(400).json({\n      success: false,\n      message: 'Nome, email, assunto e mensagem sÃ£o obrigatÃ³rios'\n    });\n  }\n\n  // Validar email\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Formato de email invÃ¡lido'\n    });\n  }\n\n  // Validar tamanhos\n  if (name.trim().length < 2 || name.trim().length > 100) {\n    return res.status(400).json({\n      success: false,\n      message: 'Nome deve ter entre 2 e 100 caracteres'\n    });\n  }\n\n  if (subject.trim().length < 5 || subject.trim().length > 200) {\n    return res.status(400).json({\n      success: false,\n      message: 'Assunto deve ter entre 5 e 200 caracteres'\n    });\n  }\n\n  if (message.trim().length < 10 || message.trim().length > 2000) {\n    return res.status(400).json({\n      success: false,\n      message: 'Mensagem deve ter entre 10 e 2000 caracteres'\n    });\n  }\n\n  // Validar categoria\n  const validCategories = ['general', 'support', 'business', 'technical', 'other'];\n  if (category && !validCategories.includes(category)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Categoria invÃ¡lida'\n    });\n  }\n\n  next();\n};\n\n// ValidaÃ§Ã£o para mensagens de parceria\nconst validatePartnershipMessage = (req, res, next) => {\n  const {\n    company,\n    contactPerson,\n    email,\n    partnershipType,\n    description,\n    phone,\n    website,\n    budget,\n    timeline\n  } = req.body;\n\n  if (!company || !contactPerson || !email || !partnershipType || !description) {\n    return res.status(400).json({\n      success: false,\n      message:\n        'Empresa, pessoa de contato, email, tipo de parceria e descriÃ§Ã£o sÃ£o obrigatÃ³rios'\n    });\n  }\n\n  // Validar email\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Formato de email invÃ¡lido'\n    });\n  }\n\n  // Validar tamanhos\n  if (company.trim().length < 2 || company.trim().length > 100) {\n    return res.status(400).json({\n      success: false,\n      message: 'Nome da empresa deve ter entre 2 e 100 caracteres'\n    });\n  }\n\n  if (contactPerson.trim().length < 2 || contactPerson.trim().length > 100) {\n    return res.status(400).json({\n      success: false,\n      message: 'Nome da pessoa de contato deve ter entre 2 e 100 caracteres'\n    });\n  }\n\n  if (description.trim().length < 20 || description.trim().length > 2000) {\n    return res.status(400).json({\n      success: false,\n      message: 'DescriÃ§Ã£o deve ter entre 20 e 2000 caracteres'\n    });\n  }\n\n  // Validar tipo de parceria\n  const validPartnershipTypes = [\n    'technology',\n    'distribution',\n    'marketing',\n    'research',\n    'investment',\n    'other'\n  ];\n  if (!validPartnershipTypes.includes(partnershipType)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Tipo de parceria invÃ¡lido'\n    });\n  }\n\n  // Validar orÃ§amento se fornecido\n  if (budget) {\n    const validBudgets = [\n      'under_10k',\n      '10k_50k',\n      '50k_100k',\n      '100k_500k',\n      'over_500k',\n      'negotiable'\n    ];\n    if (!validBudgets.includes(budget)) {\n      return res.status(400).json({\n        success: false,\n        message: 'OrÃ§amento invÃ¡lido'\n      });\n    }\n  }\n\n  // Validar timeline se fornecido\n  if (timeline) {\n    const validTimelines = ['immediate', '1_3_months', '3_6_months', '6_12_months', 'over_1_year'];\n    if (!validTimelines.includes(timeline)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Timeline invÃ¡lido'\n      });\n    }\n  }\n\n  next();\n};\n\n// ===== ROTAS PÃšBLICAS =====\n\n// POST /api/contact - Enviar mensagem de contato\nrouter.post('/', validateContactMessage, async (req, res) => {\n  try {\n    const { name, email, subject, message, phone, company, category } = req.body;\n\n    // Sanitizar inputs\n    const sanitizedData = {\n      name: sanitizeInput(name),\n      email: sanitizeInput(email).toLowerCase(),\n      subject: sanitizeInput(subject),\n      message: sanitizeInput(message),\n      phone: phone ? sanitizeInput(phone) : undefined,\n      company: company ? sanitizeInput(company) : undefined,\n      category: category || 'general'\n    };\n\n    // Criar mensagem de contato\n    const contactMessage = new ContactMessage(sanitizedData);\n    await contactMessage.save();\n\n    // Log de seguranÃ§a\n    await createSecurityLog('data_modification', 'low', 'Contact message sent', req, null, {\n      email: sanitizedData.email,\n      category: sanitizedData.category\n    });\n\n    res.status(201).json({\n      success: true,\n      message: 'Mensagem de contato enviada com sucesso',\n      data: {\n        id: contactMessage._id,\n        submittedAt: contactMessage.createdAt\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error sending contact message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error sending contact message: ${error.message}`,\n      req\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/contact/partnership - Enviar solicitaÃ§Ã£o de parceria\nrouter.post('/partnership', validatePartnershipMessage, async (req, res) => {\n  try {\n    const {\n      company,\n      contactPerson,\n      email,\n      partnershipType,\n      description,\n      phone,\n      website,\n      budget,\n      timeline,\n      goals\n    } = req.body;\n\n    // Sanitizar inputs\n    const sanitizedData = {\n      company: sanitizeInput(company),\n      contactPerson: sanitizeInput(contactPerson),\n      email: sanitizeInput(email).toLowerCase(),\n      partnershipType: sanitizeInput(partnershipType),\n      description: sanitizeInput(description),\n      phone: phone ? sanitizeInput(phone) : undefined,\n      website: website ? sanitizeInput(website) : undefined,\n      budget: budget || 'negotiable',\n      timeline: timeline || '3_6_months',\n      goals: goals ? sanitizeInput(goals) : undefined\n    };\n\n    // Criar mensagem de parceria\n    const partnershipMessage = new PartnershipMessage(sanitizedData);\n    await partnershipMessage.save();\n\n    // Log de seguranÃ§a\n    await createSecurityLog('data_modification', 'low', 'Partnership inquiry sent', req, null, {\n      email: sanitizedData.email,\n      company: sanitizedData.company,\n      partnershipType: sanitizedData.partnershipType\n    });\n\n    res.status(201).json({\n      success: true,\n      message: 'SolicitaÃ§Ã£o de parceria enviada com sucesso',\n      data: {\n        id: partnershipMessage._id,\n        submittedAt: partnershipMessage.createdAt\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error sending partnership inquiry:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error sending partnership inquiry: ${error.message}`,\n      req\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS ADMIN (PROTEGIDAS) =====\n\n// GET /api/contact/admin/messages - Listar mensagens de contato (admin only)\nrouter.get('/admin/messages', async (req, res) => {\n  try {\n    // Verificar se Ã© admin (serÃ¡ feito pelo middleware de autenticaÃ§Ã£o)\n    const { page = 1, limit = 20, status, category, priority } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = {};\n    if (status) {\n      query.status = status;\n    }\n    if (category) {\n      query.category = category;\n    }\n    if (priority) {\n      query.priority = priority;\n    }\n\n    const messages = await ContactMessage.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .lean();\n\n    const total = await ContactMessage.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        messages,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching contact messages:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/contact/admin/partnerships - Listar mensagens de parceria (admin only)\nrouter.get('/admin/partnerships', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, status, partnershipType, budget } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = {};\n    if (status) {\n      query.status = status;\n    }\n    if (partnershipType) {\n      query.partnershipType = partnershipType;\n    }\n    if (budget) {\n      query.budget = budget;\n    }\n\n    const messages = await PartnershipMessage.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .lean();\n\n    const total = await PartnershipMessage.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        messages,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership messages:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/contact/admin/messages/:id - Obter mensagem de contato especÃ­fica\nrouter.get('/admin/messages/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    const message = await ContactMessage.findById(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching contact message:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/contact/admin/partnerships/:id - Obter mensagem de parceria especÃ­fica\nrouter.get('/admin/partnerships/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    const message = await PartnershipMessage.findById(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem de parceria nÃ£o encontrada'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership message:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/contact/admin/messages/:id/status - Atualizar status da mensagem de contato\nrouter.put('/admin/messages/:id/status', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { status, adminNotes, assignedTo } = req.body;\n\n    const message = await ContactMessage.findById(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Atualizar campos\n    if (status) {\n      message.status = status;\n    }\n    if (adminNotes) {\n      message.adminNotes = adminNotes;\n    }\n    if (assignedTo) {\n      message.assignedTo = assignedTo;\n    }\n\n    // Atualizar timestamps especÃ­ficos\n    if (status === 'read' && !message.isRead) {\n      message.isRead = true;\n      message.readAt = new Date();\n    }\n\n    if (status === 'replied' && !message.repliedAt) {\n      message.repliedAt = new Date();\n    }\n\n    await message.save();\n\n    res.json({\n      success: true,\n      message: 'Status da mensagem atualizado com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating contact message status:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/contact/admin/partnerships/:id/status - Atualizar status da mensagem de parceria\nrouter.put('/admin/partnerships/:id/status', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { status, adminNotes, assignedTo } = req.body;\n\n    const message = await PartnershipMessage.findById(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem de parceria nÃ£o encontrada'\n      });\n    }\n\n    // Atualizar campos\n    if (status) {\n      message.status = status;\n    }\n    if (adminNotes) {\n      message.adminNotes = adminNotes;\n    }\n    if (assignedTo) {\n      message.assignedTo = assignedTo;\n    }\n\n    // Atualizar timestamps especÃ­ficos\n    if (status === 'read' && !message.isRead) {\n      message.isRead = true;\n      message.readAt = new Date();\n    }\n\n    if (status === 'contacted' && !message.contactedAt) {\n      message.contactedAt = new Date();\n    }\n\n    await message.save();\n\n    res.json({\n      success: true,\n      message: 'Status da mensagem de parceria atualizado com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating partnership message status:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/contact/admin/messages/:id - Excluir mensagem de contato\nrouter.delete('/admin/messages/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    const message = await ContactMessage.findByIdAndDelete(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Mensagem excluÃ­da com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error deleting contact message:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/contact/admin/partnerships/:id - Excluir mensagem de parceria\nrouter.delete('/admin/partnerships/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    const message = await PartnershipMessage.findByIdAndDelete(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem de parceria nÃ£o encontrada'\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Mensagem de parceria excluÃ­da com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error deleting partnership message:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE ESTATÃSTICAS =====\n\n// GET /api/contact/admin/stats - EstatÃ­sticas das mensagens (admin only)\nrouter.get('/admin/stats', async (req, res) => {\n  try {\n    const [contactStats, partnershipStats] = await Promise.all([\n      ContactMessage.aggregate([\n        {\n          $group: {\n            _id: '$status',\n            count: { $sum: 1 }\n          }\n        }\n      ]),\n      PartnershipMessage.aggregate([\n        {\n          $group: {\n            _id: '$status',\n            count: { $sum: 1 }\n          }\n        }\n      ])\n    ]);\n\n    const totalContact = await ContactMessage.countDocuments();\n    const totalPartnership = await PartnershipMessage.countDocuments();\n    const unreadContact = await ContactMessage.countDocuments({ isRead: false });\n    const unreadPartnership = await PartnershipMessage.countDocuments({ isRead: false });\n\n    res.json({\n      success: true,\n      data: {\n        contact: {\n          total: totalContact,\n          unread: unreadContact,\n          byStatus: contactStats.reduce((acc, stat) => {\n            acc[stat._id] = stat.count;\n            return acc;\n          }, {})\n        },\n        partnership: {\n          total: totalPartnership,\n          unread: unreadPartnership,\n          byStatus: partnershipStats.reduce((acc, stat) => {\n            acc[stat._id] = stat.count;\n            return acc;\n          }, {})\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching contact stats:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\conversations.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 12
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'requireProductMessagingAccess' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 11,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 11,
        "endColumn": 32
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'requireFreightMessagingAccess' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 12,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 12,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport mongoose from 'mongoose';\nimport Conversation from '../models/Conversation.js';\nimport Message from '../models/Message.js';\nimport User from '../models/User.js';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport AuditLog from '../models/AuditLog.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport {\n  requireProductMessagingAccess,\n  requireFreightMessagingAccess\n} from '../middleware/requirePaidAccess.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// ===== VALIDAÃ‡ÃƒO DE DADOS =====\n\nconst validateConversationData = (req, res, next) => {\n  const { serviceType, serviceId, participants } = req.body;\n\n  if (!serviceType || !['product', 'freight'].includes(serviceType)) {\n    return res.status(400).json({\n      ok: false,\n      error: 'invalid_service_type',\n      message: 'Tipo de serviÃ§o deve ser \"product\" ou \"freight\"'\n    });\n  }\n\n  if (!serviceId || !mongoose.Types.ObjectId.isValid(serviceId)) {\n    return res.status(400).json({\n      ok: false,\n      error: 'invalid_service_id',\n      message: 'ID do serviÃ§o invÃ¡lido'\n    });\n  }\n\n  if (!participants || !Array.isArray(participants) || participants.length < 2) {\n    return res.status(400).json({\n      ok: false,\n      error: 'invalid_participants',\n      message: 'Deve haver pelo menos 2 participantes'\n    });\n  }\n\n  // Verificar se o usuÃ¡rio atual estÃ¡ nos participantes\n  if (!participants.includes(req.user.userId)) {\n    return res.status(400).json({\n      ok: false,\n      error: 'unauthorized_participant',\n      message: 'VocÃª deve ser um dos participantes da conversa'\n    });\n  }\n\n  next();\n};\n\nconst validateMessageData = (req, res, next) => {\n  const { content } = req.body;\n\n  if (!content || content.trim().length === 0) {\n    return res.status(400).json({\n      ok: false,\n      error: 'empty_message',\n      message: 'Mensagem nÃ£o pode estar vazia'\n    });\n  }\n\n  if (content.trim().length > 5000) {\n    return res.status(400).json({\n      ok: false,\n      error: 'message_too_long',\n      message: 'Mensagem deve ter no mÃ¡ximo 5000 caracteres'\n    });\n  }\n\n  next();\n};\n\n// ===== ROTAS DE CONVERSAS =====\n\n// GET /api/conversations - Listar conversas do usuÃ¡rio\nrouter.get('/', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { serviceType, page = 1, limit = 20, status } = req.query;\n\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    // Construir query\n    const query = {\n      participants: userId,\n      status: { $ne: 'deleted' }\n    };\n\n    if (serviceType && ['product', 'freight'].includes(serviceType)) {\n      query.serviceType = serviceType;\n    }\n\n    if (status && ['active', 'archived', 'closed', 'blocked'].includes(status)) {\n      query.status = status;\n    }\n\n    // Buscar conversas\n    const conversations = await Conversation.find(query)\n      .sort({ lastMessageAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .populate('participants', 'name email company.name')\n      .populate('lastMessage.senderId', 'name email')\n      .populate('serviceId', 'name title origin destination price images');\n\n    // Contar total\n    const total = await Conversation.countDocuments(query);\n\n    // Log de acesso\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversations_listed',\n      resource: 'conversation',\n      resourceType: 'Conversation',\n      details: `Listed ${conversations.length} conversations`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { serviceType, page, limit, total }\n    });\n\n    res.json({\n      ok: true,\n      data: {\n        conversations,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Error listing conversations:', error);\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error listing conversations: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/conversations - Criar nova conversa\nrouter.post('/', authenticateToken, validateConversationData, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { serviceType, serviceId, participants, title } = req.body;\n\n    // Verificar se o serviÃ§o existe\n    let service;\n    if (serviceType === 'product') {\n      service = await Product.findById(serviceId);\n    } else {\n      service = await Freight.findById(serviceId);\n    }\n\n    if (!service) {\n      return res.status(404).json({\n        ok: false,\n        error: 'service_not_found',\n        message: 'ServiÃ§o nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se jÃ¡ existe conversa entre estes usuÃ¡rios para este serviÃ§o\n    const existingConversation = await Conversation.findBetweenUsers(\n      participants[0],\n      participants[1],\n      serviceId,\n      serviceType\n    );\n\n    if (existingConversation) {\n      return res.status(409).json({\n        ok: false,\n        error: 'conversation_exists',\n        message: 'Conversa jÃ¡ existe para este serviÃ§o',\n        data: { conversationId: existingConversation._id }\n      });\n    }\n\n    // Criar conversa\n    const conversation = await Conversation.createConversation(\n      participants,\n      serviceId,\n      serviceType,\n      title\n    );\n\n    // Populate dados\n    await conversation.populate([\n      { path: 'participants', select: 'name email company.name' },\n      { path: 'serviceId', select: 'name title origin destination price images' }\n    ]);\n\n    // Log de criaÃ§Ã£o\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversation_created',\n      resource: 'conversation',\n      resourceId: conversation._id,\n      resourceType: 'Conversation',\n      details: `Created conversation for ${serviceType} service`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { serviceType, serviceId, participants }\n    });\n\n    res.status(201).json({\n      ok: true,\n      message: 'Conversa criada com sucesso',\n      data: { conversation }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating conversation:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error creating conversation: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/conversations/:id - Obter conversa especÃ­fica\nrouter.get('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    const conversation = await Conversation.findById(conversationId)\n      .populate('participants', 'name email company.name')\n      .populate('serviceId', 'name title origin destination price images')\n      .populate('lastMessage.senderId', 'name email');\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio Ã© participante\n    if (!conversation.participants.some(p => p._id.toString() === userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to access conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Log de acesso\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversation_accessed',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: 'Accessed conversation details',\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      ok: true,\n      data: { conversation }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching conversation:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching conversation: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/conversations/:id - Atualizar conversa\nrouter.put('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n    const { title, status } = req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    const conversation = await Conversation.findById(conversationId);\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio Ã© participante\n    if (!conversation.participants.includes(userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to update conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Atualizar campos permitidos\n    if (title !== undefined) {\n      conversation.title = title;\n    }\n    if (status !== undefined && ['active', 'archived', 'closed'].includes(status)) {\n      conversation.status = status;\n    }\n\n    await conversation.save();\n\n    // Log de atualizaÃ§Ã£o\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'conversation_updated',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: 'Updated conversation',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { title, status }\n    });\n\n    res.json({\n      ok: true,\n      message: 'Conversa atualizada com sucesso',\n      data: { conversation }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating conversation:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error updating conversation: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE MENSAGENS =====\n\n// GET /api/conversations/:id/messages - Listar mensagens de uma conversa\nrouter.get('/:id/messages', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n    const { page = 1, limit = 50 } = req.query;\n\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    // Verificar se a conversa existe e se o usuÃ¡rio Ã© participante\n    const conversation = await Conversation.findById(conversationId);\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    if (!conversation.participants.includes(userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to access messages from conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Buscar mensagens\n    const messages = await Message.find({\n      conversationId,\n      status: { $ne: 'deleted' }\n    })\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .populate('senderId', 'name email company.name')\n      .populate('receiverId', 'name email company.name');\n\n    // Contar total\n    const total = await Message.countDocuments({\n      conversationId,\n      status: { $ne: 'deleted' }\n    });\n\n    // Marcar mensagens como lidas se o usuÃ¡rio for o destinatÃ¡rio\n    const unreadMessages = messages.filter(\n      msg => msg.receiverId._id.toString() === userId && !msg.isRead\n    );\n\n    if (unreadMessages.length > 0) {\n      await Message.updateMany(\n        { _id: { $in: unreadMessages.map(m => m._id) } },\n        { $set: { isRead: true, readAt: new Date() } }\n      );\n    }\n\n    // Log de acesso\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'messages_accessed',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: `Accessed ${messages.length} messages`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: { page, limit, total, unreadCount: unreadMessages.length }\n    });\n\n    res.json({\n      ok: true,\n      data: {\n        messages: messages.reverse(), // Ordem cronolÃ³gica\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching messages:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching messages: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/conversations/:id/messages - Enviar mensagem\nrouter.post('/:id/messages', authenticateToken, validateMessageData, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const conversationId = req.params.id;\n    const { content, attachments = [] } = req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(conversationId)) {\n      return res.status(400).json({\n        ok: false,\n        error: 'invalid_id',\n        message: 'ID da conversa invÃ¡lido'\n      });\n    }\n\n    // Verificar se a conversa existe e se o usuÃ¡rio Ã© participante\n    const conversation = await Conversation.findById(conversationId);\n\n    if (!conversation) {\n      return res.status(404).json({\n        ok: false,\n        error: 'conversation_not_found',\n        message: 'Conversa nÃ£o encontrada'\n      });\n    }\n\n    if (!conversation.participants.includes(userId)) {\n      await createSecurityLog(\n        'unauthorized_access',\n        'medium',\n        \"User attempted to send message to conversation they don't participate in\",\n        req,\n        userId\n      );\n\n      return res.status(403).json({\n        ok: false,\n        error: 'access_denied',\n        message: 'Acesso negado a esta conversa'\n      });\n    }\n\n    // Verificar se a conversa nÃ£o estÃ¡ bloqueada\n    if (conversation.status === 'blocked') {\n      return res.status(403).json({\n        ok: false,\n        error: 'conversation_blocked',\n        message: 'Esta conversa foi bloqueada'\n      });\n    }\n\n    // Encontrar destinatÃ¡rio (outro participante)\n    const recipientId = conversation.participants.find(p => p.toString() !== userId);\n\n    // Criar mensagem\n    const message = new Message({\n      conversationId,\n      senderId: userId,\n      receiverId: recipientId,\n      content: content.trim(),\n      attachments,\n      messageType: conversation.serviceType === 'product' ? 'product_inquiry' : 'freight_request',\n      messagingCategory: conversation.serviceType === 'product' ? 'products' : 'freights'\n    });\n\n    await message.save();\n\n    // Atualizar conversa\n    await conversation.updateLastMessage(content, userId);\n    conversation.unreadCount += 1;\n    await conversation.save();\n\n    // Populate dados da mensagem\n    await message.populate([\n      { path: 'senderId', select: 'name email company.name' },\n      { path: 'receiverId', select: 'name email company.name' }\n    ]);\n\n    // Log de envio\n    await AuditLog.log({\n      userId,\n      userEmail: req.user.email,\n      action: 'message_sent',\n      resource: 'conversation',\n      resourceId: conversationId,\n      resourceType: 'Conversation',\n      details: 'Sent message in conversation',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      metadata: {\n        messageId: message._id,\n        contentLength: content.length,\n        attachmentsCount: attachments.length\n      }\n    });\n\n    res.status(201).json({\n      ok: true,\n      message: 'Mensagem enviada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error sending message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error sending message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS DE ESTATÃSTICAS =====\n\n// GET /api/conversations/stats - EstatÃ­sticas das conversas\nrouter.get('/stats/summary', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const stats = await Conversation.getStats(userId);\n\n    res.json({\n      ok: true,\n      data: { stats }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching conversation stats:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching conversation stats: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      ok: false,\n      error: 'internal_error',\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\crypto.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'iv' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 123,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 123,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport crypto from 'crypto';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Middleware de autenticaÃ§Ã£o para rotas criptografadas\nconst requireAuth = (req, res, next) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Token de autenticaÃ§Ã£o necessÃ¡rio'\n    });\n  }\n  // Aqui vocÃª validaria o JWT token\n  next();\n};\n\n// Gerar chaves de criptografia\nrouter.post('/generate-keys', requireAuth, (req, res) => {\n  try {\n    const { algorithm = 'aes-256-gcm' } = req.body;\n\n    // Gerar chave simÃ©trica\n    const symmetricKey = crypto.randomBytes(32);\n\n    // Gerar par de chaves assimÃ©tricas\n    const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {\n      modulusLength: 2048,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    });\n\n    const keyData = {\n      symmetricKey: symmetricKey.toString('base64'),\n      publicKey,\n      privateKey,\n      algorithm,\n      timestamp: new Date().toISOString()\n    };\n\n    logger.info('Chaves de criptografia geradas com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Chaves geradas com sucesso',\n      data: keyData\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar chaves:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Criptografar dados\nrouter.post('/encrypt', requireAuth, (req, res) => {\n  try {\n    const { data, key, algorithm = 'aes-256-gcm' } = req.body;\n\n    if (!data || !key) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados e chave sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const keyBuffer = Buffer.from(key, 'base64');\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher(algorithm, keyBuffer);\n\n    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'base64');\n    encrypted += cipher.final('base64');\n\n    const authTag = cipher.getAuthTag ? cipher.getAuthTag() : null;\n\n    const encryptedData = {\n      encrypted,\n      iv: iv.toString('base64'),\n      algorithm,\n      authTag: authTag ? authTag.toString('base64') : null,\n      timestamp: new Date().toISOString()\n    };\n\n    logger.info('Dados criptografados com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Dados criptografados com sucesso',\n      data: encryptedData\n    });\n  } catch (error) {\n    logger.error('Erro ao criptografar dados:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao criptografar dados'\n    });\n  }\n});\n\n// Descriptografar dados\nrouter.post('/decrypt', requireAuth, (req, res) => {\n  try {\n    const { encryptedData, key } = req.body;\n\n    if (!encryptedData || !key) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados criptografados e chave sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const keyBuffer = Buffer.from(key, 'base64');\n    const iv = Buffer.from(encryptedData.iv, 'base64');\n    const decipher = crypto.createDecipher(encryptedData.algorithm, keyBuffer);\n\n    if (encryptedData.authTag) {\n      decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'base64'));\n    }\n\n    let decrypted = decipher.update(encryptedData.encrypted, 'base64', 'utf8');\n    decrypted += decipher.final('utf8');\n\n    const data = JSON.parse(decrypted);\n\n    logger.info('Dados descriptografados com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Dados descriptografados com sucesso',\n      data\n    });\n  } catch (error) {\n    logger.error('Erro ao descriptografar dados:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao descriptografar dados'\n    });\n  }\n});\n\n// Hash de dados\nrouter.post('/hash', requireAuth, (req, res) => {\n  try {\n    const { data, algorithm = 'sha256' } = req.body;\n\n    if (!data) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const hash = crypto.createHash(algorithm);\n    hash.update(JSON.stringify(data));\n    const hashValue = hash.digest('hex');\n\n    logger.info('Hash gerado com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Hash gerado com sucesso',\n      data: {\n        hash: hashValue,\n        algorithm,\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar hash:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao gerar hash'\n    });\n  }\n});\n\n// Verificar integridade\nrouter.post('/verify-integrity', requireAuth, (req, res) => {\n  try {\n    const { data, hash, algorithm = 'sha256' } = req.body;\n\n    if (!data || !hash) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados e hash sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const newHash = crypto.createHash(algorithm);\n    newHash.update(JSON.stringify(data));\n    const calculatedHash = newHash.digest('hex');\n\n    const isValid = calculatedHash === hash;\n\n    logger.info(`VerificaÃ§Ã£o de integridade: ${isValid ? 'vÃ¡lida' : 'invÃ¡lida'}`);\n\n    res.json({\n      success: true,\n      message: 'VerificaÃ§Ã£o de integridade concluÃ­da',\n      data: {\n        isValid,\n        originalHash: hash,\n        calculatedHash,\n        algorithm,\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar integridade:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar integridade'\n    });\n  }\n});\n\n// Assinar dados digitalmente\nrouter.post('/sign', requireAuth, (req, res) => {\n  try {\n    const { data, privateKey } = req.body;\n\n    if (!data || !privateKey) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados e chave privada sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const sign = crypto.createSign('SHA256');\n    sign.update(JSON.stringify(data));\n    sign.end();\n\n    const signature = sign.sign(privateKey, 'base64');\n\n    logger.info('Dados assinados digitalmente com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Dados assinados com sucesso',\n      data: {\n        signature,\n        algorithm: 'SHA256',\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao assinar dados:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao assinar dados'\n    });\n  }\n});\n\n// Verificar assinatura digital\nrouter.post('/verify-signature', requireAuth, (req, res) => {\n  try {\n    const { data, signature, publicKey } = req.body;\n\n    if (!data || !signature || !publicKey) {\n      return res.status(400).json({\n        success: false,\n        message: 'Dados, assinatura e chave pÃºblica sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const verify = crypto.createVerify('SHA256');\n    verify.update(JSON.stringify(data));\n    verify.end();\n\n    const isValid = verify.verify(publicKey, signature, 'base64');\n\n    logger.info(`VerificaÃ§Ã£o de assinatura: ${isValid ? 'vÃ¡lida' : 'invÃ¡lida'}`);\n\n    res.json({\n      success: true,\n      message: 'VerificaÃ§Ã£o de assinatura concluÃ­da',\n      data: {\n        isValid,\n        algorithm: 'SHA256',\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao verificar assinatura:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar assinatura'\n    });\n  }\n});\n\n// Gerar nonce\nrouter.post('/generate-nonce', requireAuth, (req, res) => {\n  try {\n    const { length = 32 } = req.body;\n\n    const nonce = crypto.randomBytes(length).toString('hex');\n\n    logger.info('Nonce gerado com sucesso');\n\n    res.json({\n      success: true,\n      message: 'Nonce gerado com sucesso',\n      data: {\n        nonce,\n        length,\n        timestamp: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao gerar nonce:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao gerar nonce'\n    });\n  }\n});\n\n// Status das rotas criptografadas\nrouter.get('/status', (req, res) => {\n  res.json({\n    success: true,\n    message: 'Rotas criptografadas ativas',\n    data: {\n      status: 'online',\n      algorithms: ['aes-256-gcm', 'sha256', 'rsa'],\n      endpoints: [\n        'POST /crypto/generate-keys',\n        'POST /crypto/encrypt',\n        'POST /crypto/decrypt',\n        'POST /crypto/hash',\n        'POST /crypto/verify-integrity',\n        'POST /crypto/sign',\n        'POST /crypto/verify-signature',\n        'POST /crypto/generate-nonce'\n      ],\n      timestamp: new Date().toISOString()\n    }\n  });\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\dashboard.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\data-access.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const express = require('express');\nconst router = express.Router();\nconst auth = require('../middleware/auth');\nconst { Payment } = require('../models/Payment');\nconst { User } = require('../models/User');\nconst { Product } = require('../models/Product');\nconst { AuditLog } = require('../models/AuditLog');\nconst { SecurityLog } = require('../models/SecurityLog');\n\nconst logger = require('../utils/logger.js');\n// Verificar se usuÃ¡rio tem acesso aos dados de um anÃºncio\nrouter.get('/check-access/:adId', auth, async (req, res) => {\n  try {\n    const { adId } = req.params;\n    const userId = req.user.id;\n\n    // Verificar se existe pagamento aprovado para este anÃºncio\n    const payment = await Payment.findOne({\n      userId,\n      adId,\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    const hasAccess = !!payment;\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'check_data_access',\n      resource: `ad_${adId}`,\n      details: { hasAccess, adId },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({ hasAccess, adId });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar acesso:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Liberar dados apÃ³s pagamento confirmado\nrouter.post('/unlock-data', auth, async (req, res) => {\n  try {\n    const { userId, adId } = req.body;\n    const currentUserId = req.user.id;\n\n    // Verificar se o usuÃ¡rio tem permissÃ£o\n    if (userId !== currentUserId) {\n      return res.status(403).json({ error: 'Acesso negado' });\n    }\n\n    // Verificar se existe pagamento aprovado\n    const payment = await Payment.findOne({\n      userId,\n      adId,\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    if (!payment) {\n      return res.status(400).json({ error: 'Pagamento nÃ£o encontrado ou nÃ£o aprovado' });\n    }\n\n    // Marcar dados como liberados\n    payment.dataUnlocked = true;\n    payment.unlockedAt = new Date();\n    await payment.save();\n\n    // Buscar dados do anÃºncio\n    const product = await Product.findById(adId);\n    if (!product) {\n      return res.status(404).json({ error: 'AnÃºncio nÃ£o encontrado' });\n    }\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'unlock_data_access',\n      resource: `ad_${adId}`,\n      details: { adId, paymentId: payment._id },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    // Log de seguranÃ§a\n    await SecurityLog.create({\n      userId,\n      action: 'data_unlock',\n      resource: `ad_${adId}`,\n      severity: 'medium',\n      details: { adId, paymentId: payment._id },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'Dados liberados com sucesso',\n      unlockedAt: payment.unlockedAt,\n      adData: {\n        title: product.title,\n        userName: product.userName,\n        phone: product.phone,\n        email: product.email,\n        location: product.location,\n        description: product.description\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao liberar dados:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Obter dados liberados de um anÃºncio\nrouter.get('/unlocked-data/:adId', auth, async (req, res) => {\n  try {\n    const { adId } = req.params;\n    const userId = req.user.id;\n\n    // Verificar se usuÃ¡rio tem acesso\n    const payment = await Payment.findOne({\n      userId,\n      adId,\n      status: 'succeeded',\n      type: 'individual',\n      dataUnlocked: true\n    });\n\n    if (!payment) {\n      return res.status(403).json({ error: 'Acesso negado aos dados' });\n    }\n\n    // Buscar dados do anÃºncio\n    const product = await Product.findById(adId);\n    if (!product) {\n      return res.status(404).json({ error: 'AnÃºncio nÃ£o encontrado' });\n    }\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'access_unlocked_data',\n      resource: `ad_${adId}`,\n      details: { adId },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      adData: {\n        title: product.title,\n        userName: product.userName,\n        phone: product.phone,\n        email: product.email,\n        location: product.location,\n        description: product.description,\n        images: product.images,\n        price: product.price,\n        category: product.category\n      },\n      unlockedAt: payment.unlockedAt,\n      paymentId: payment._id\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter dados liberados:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Configurar opÃ§Ãµes de liberaÃ§Ã£o para anunciante\nrouter.post('/configure-release/:adId', auth, async (req, res) => {\n  try {\n    const { adId } = req.params;\n    const userId = req.user.id;\n    const {\n      autoRelease = false,\n      releaseDelay = 0,\n      requireVerification = true,\n      customMessage = ''\n    } = req.body;\n\n    // Verificar se o usuÃ¡rio Ã© o dono do anÃºncio\n    const product = await Product.findById(adId);\n    if (!product) {\n      return res.status(404).json({ error: 'AnÃºncio nÃ£o encontrado' });\n    }\n\n    if (product.userId.toString() !== userId) {\n      return res.status(403).json({ error: 'Acesso negado' });\n    }\n\n    // Atualizar configuraÃ§Ãµes de liberaÃ§Ã£o\n    product.releaseSettings = {\n      autoRelease,\n      releaseDelay,\n      requireVerification,\n      customMessage,\n      updatedAt: new Date()\n    };\n\n    await product.save();\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId,\n      action: 'configure_data_release',\n      resource: `ad_${adId}`,\n      details: {\n        autoRelease,\n        releaseDelay,\n        requireVerification,\n        customMessage\n      },\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'ConfiguraÃ§Ãµes de liberaÃ§Ã£o atualizadas',\n      releaseSettings: product.releaseSettings\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao configurar liberaÃ§Ã£o:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Obter estatÃ­sticas de liberaÃ§Ã£o de dados\nrouter.get('/release-stats', auth, async (req, res) => {\n  try {\n    const userId = req.user.id;\n\n    // EstatÃ­sticas do usuÃ¡rio\n    const totalPayments = await Payment.countDocuments({\n      userId,\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    const unlockedData = await Payment.countDocuments({\n      userId,\n      status: 'succeeded',\n      type: 'individual',\n      dataUnlocked: true\n    });\n\n    const totalSpent = await Payment.aggregate([\n      {\n        $match: {\n          userId,\n          status: 'succeeded',\n          type: 'individual'\n        }\n      },\n      {\n        $group: {\n          _id: null,\n          total: { $sum: '$amount' }\n        }\n      }\n    ]);\n\n    // EstatÃ­sticas dos anÃºncios do usuÃ¡rio\n    const userProducts = await Product.find({ userId });\n    const productIds = userProducts.map(p => p._id);\n\n    const paymentsReceived = await Payment.countDocuments({\n      adId: { $in: productIds },\n      status: 'succeeded',\n      type: 'individual'\n    });\n\n    const totalEarned = await Payment.aggregate([\n      {\n        $match: {\n          adId: { $in: productIds },\n          status: 'succeeded',\n          type: 'individual'\n        }\n      },\n      {\n        $group: {\n          _id: null,\n          total: { $sum: '$amount' }\n        }\n      }\n    ]);\n\n    res.json({\n      buyerStats: {\n        totalPayments,\n        unlockedData,\n        totalSpent: totalSpent[0]?.total || 0\n      },\n      sellerStats: {\n        totalProducts: userProducts.length,\n        paymentsReceived,\n        totalEarned: totalEarned[0]?.total || 0\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\nmodule.exports = router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\email.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\escrow.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'escrow' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 459,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 459,
        "endColumn": 37
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'paymentData' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 459,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 459,
        "endColumn": 50
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'escrow' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 475,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 475,
        "endColumn": 39
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'paymentData' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 475,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 475,
        "endColumn": 52
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport Escrow from '../models/Escrow.js';\nimport Payment from '../models/Payment.js';\nimport User from '../models/User.js';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { body, validationResult } from 'express-validator';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// POST /api/escrow/create - Criar escrow\nrouter.post(\n  '/create',\n  authenticateToken,\n  [\n    body('itemId').isMongoId().withMessage('ID do item invÃ¡lido'),\n    body('itemType').isIn(['product', 'freight']).withMessage('Tipo de item invÃ¡lido'),\n    body('amount').isFloat({ min: 0.01 }).withMessage('Valor deve ser maior que zero'),\n    body('description').notEmpty().withMessage('DescriÃ§Ã£o Ã© obrigatÃ³ria')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { itemId, itemType, amount, description } = req.body;\n      const buyerId = req.user.id;\n\n      // Buscar item\n      let item;\n      if (itemType === 'product') {\n        item = await Product.findById(itemId);\n      } else {\n        item = await Freight.findById(itemId);\n      }\n\n      if (!item) {\n        return res.status(404).json({\n          success: false,\n          message: 'Item nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o comprador nÃ£o Ã© o prÃ³prio vendedor\n      if (item.owner.toString() === buyerId) {\n        return res.status(400).json({\n          success: false,\n          message: 'VocÃª nÃ£o pode comprar seu prÃ³prio item'\n        });\n      }\n\n      // Verificar se jÃ¡ existe escrow ativo para este item\n      const existingEscrow = await Escrow.findOne({\n        itemId,\n        itemType,\n        buyerId,\n        status: { $in: ['pending', 'funded'] }\n      });\n\n      if (existingEscrow) {\n        return res.status(400).json({\n          success: false,\n          message: 'JÃ¡ existe uma transaÃ§Ã£o em andamento para este item'\n        });\n      }\n\n      // Criar escrow\n      const escrow = new Escrow({\n        itemId,\n        itemType,\n        sellerId: item.owner,\n        buyerId,\n        amount: parseFloat(amount),\n        description,\n        status: 'pending',\n        createdAt: new Date(),\n        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 dias\n      });\n\n      await escrow.save();\n\n      // Buscar dados do vendedor\n      const seller = await User.findById(item.owner).select('name email company');\n\n      res.json({\n        success: true,\n        message: 'Escrow criado com sucesso',\n        data: {\n          escrowId: escrow._id,\n          item: {\n            id: item._id,\n            name: item.name || `${item.origin} â†’ ${item.destination}`,\n            type: itemType\n          },\n          seller: {\n            id: seller._id,\n            name: seller.name,\n            company: seller.company\n          },\n          amount: escrow.amount,\n          status: escrow.status,\n          expiresAt: escrow.expiresAt\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao criar escrow:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// POST /api/escrow/fund - Financiar escrow\nrouter.post(\n  '/fund',\n  authenticateToken,\n  [\n    body('escrowId').isMongoId().withMessage('ID do escrow invÃ¡lido'),\n    body('paymentMethod')\n      .isIn(['stripe', 'metamask'])\n      .withMessage('MÃ©todo de pagamento invÃ¡lido'),\n    body('paymentData').isObject().withMessage('Dados de pagamento sÃ£o obrigatÃ³rios')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { escrowId, paymentMethod, paymentData } = req.body;\n      const userId = req.user.id;\n\n      // Buscar escrow\n      const escrow = await Escrow.findById(escrowId);\n      if (!escrow) {\n        return res.status(404).json({\n          success: false,\n          message: 'Escrow nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio Ã© o comprador\n      if (escrow.buyerId.toString() !== userId) {\n        return res.status(403).json({\n          success: false,\n          message: 'Acesso negado'\n        });\n      }\n\n      // Verificar se escrow ainda estÃ¡ pendente\n      if (escrow.status !== 'pending') {\n        return res.status(400).json({\n          success: false,\n          message: 'Escrow nÃ£o estÃ¡ mais pendente'\n        });\n      }\n\n      // Verificar se nÃ£o expirou\n      if (escrow.expiresAt < new Date()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Escrow expirado'\n        });\n      }\n\n      // Processar pagamento baseado no mÃ©todo\n      let paymentResult;\n      if (paymentMethod === 'stripe') {\n        paymentResult = await processStripePayment(escrow, paymentData);\n      } else if (paymentMethod === 'metamask') {\n        paymentResult = await processMetaMaskPayment(escrow, paymentData);\n      }\n\n      if (!paymentResult.success) {\n        return res.status(400).json({\n          success: false,\n          message: paymentResult.message || 'Erro ao processar pagamento'\n        });\n      }\n\n      // Atualizar escrow\n      escrow.status = 'funded';\n      escrow.paymentId = paymentResult.paymentId;\n      escrow.paymentMethod = paymentMethod;\n      escrow.fundedAt = new Date();\n      await escrow.save();\n\n      // Criar registro de pagamento\n      const payment = new Payment({\n        userId: escrow.buyerId,\n        amount: escrow.amount,\n        currency: 'BRL',\n        status: 'completed',\n        provider: paymentMethod,\n        purpose: 'escrow_funding',\n        metadata: {\n          escrowId: escrow._id,\n          itemId: escrow.itemId,\n          itemType: escrow.itemType\n        }\n      });\n      await payment.save();\n\n      res.json({\n        success: true,\n        message: 'Escrow financiado com sucesso',\n        data: {\n          escrowId: escrow._id,\n          status: escrow.status,\n          fundedAt: escrow.fundedAt,\n          paymentId: payment._id\n        }\n      });\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao financiar escrow:', error);\n      }\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// POST /api/escrow/release - Liberar pagamento\nrouter.post(\n  '/release',\n  authenticateToken,\n  [\n    body('escrowId').isMongoId().withMessage('ID do escrow invÃ¡lido'),\n    body('action').isIn(['release', 'dispute']).withMessage('AÃ§Ã£o invÃ¡lida'),\n    body('reason').optional().isString().withMessage('Motivo deve ser texto')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { escrowId, action, reason } = req.body;\n      const userId = req.user.id;\n\n      // Buscar escrow\n      const escrow = await Escrow.findById(escrowId);\n      if (!escrow) {\n        return res.status(404).json({\n          success: false,\n          message: 'Escrow nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio Ã© o comprador ou vendedor\n      if (escrow.buyerId.toString() !== userId && escrow.sellerId.toString() !== userId) {\n        return res.status(403).json({\n          success: false,\n          message: 'Acesso negado'\n        });\n      }\n\n      // Verificar se escrow estÃ¡ financiado\n      if (escrow.status !== 'funded') {\n        return res.status(400).json({\n          success: false,\n          message: 'Escrow nÃ£o estÃ¡ financiado'\n        });\n      }\n\n      if (action === 'release') {\n        // Liberar pagamento para o vendedor\n        escrow.status = 'released';\n        escrow.releasedAt = new Date();\n        escrow.releasedBy = userId;\n        escrow.releaseReason = reason || 'Pagamento liberado pelo comprador';\n\n        // Buscar vendedor\n        const seller = await User.findById(escrow.sellerId);\n        if (seller) {\n          // Aqui vocÃª implementaria a lÃ³gica de transferÃªncia real\n          // Por enquanto, apenas marcar como liberado\n          seller.balance = (seller.balance || 0) + escrow.amount;\n          await seller.save();\n        }\n\n        await escrow.save();\n\n        res.json({\n          success: true,\n          message: 'Pagamento liberado com sucesso',\n          data: {\n            escrowId: escrow._id,\n            status: escrow.status,\n            releasedAt: escrow.releasedAt\n          }\n        });\n      } else if (action === 'dispute') {\n        // Abrir disputa\n        escrow.status = 'disputed';\n        escrow.disputedAt = new Date();\n        escrow.disputedBy = userId;\n        escrow.disputeReason = reason || 'Disputa aberta';\n\n        await escrow.save();\n\n        res.json({\n          success: true,\n          message: 'Disputa aberta com sucesso',\n          data: {\n            escrowId: escrow._id,\n            status: escrow.status,\n            disputedAt: escrow.disputedAt\n          }\n        });\n      }\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao processar escrow:', error);\n      }\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n// GET /api/escrow/:id - Obter detalhes do escrow\nrouter.get('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user.id;\n\n    const escrow = await Escrow.findById(id)\n      .populate('sellerId', 'name email company')\n      .populate('buyerId', 'name email company');\n\n    if (!escrow) {\n      return res.status(404).json({\n        success: false,\n        message: 'Escrow nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem acesso\n    if (\n      escrow.buyerId._id.toString() !== userId &&\n      escrow.sellerId._id.toString() !== userId &&\n      !req.user.isAdmin\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    // Buscar item\n    let item;\n    if (escrow.itemType === 'product') {\n      item = await Product.findById(escrow.itemId);\n    } else {\n      item = await Freight.findById(escrow.itemId);\n    }\n\n    res.json({\n      success: true,\n      data: {\n        escrow: {\n          id: escrow._id,\n          status: escrow.status,\n          amount: escrow.amount,\n          description: escrow.description,\n          createdAt: escrow.createdAt,\n          expiresAt: escrow.expiresAt,\n          fundedAt: escrow.fundedAt,\n          releasedAt: escrow.releasedAt,\n          disputedAt: escrow.disputedAt\n        },\n        item: {\n          id: item._id,\n          name: item.name || `${item.origin} â†’ ${item.destination}`,\n          type: escrow.itemType\n        },\n        seller: escrow.sellerId,\n        buyer: escrow.buyerId\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar escrow:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/escrow/user/:userId - Listar escrows do usuÃ¡rio\nrouter.get('/user/:userId', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.params;\n    const currentUserId = req.user.id;\n\n    // Verificar se o usuÃ¡rio pode acessar\n    if (userId !== currentUserId && !req.user.isAdmin) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    const escrows = await Escrow.find({\n      $or: [{ buyerId: userId }, { sellerId: userId }]\n    })\n      .populate('sellerId', 'name email company')\n      .populate('buyerId', 'name email company')\n      .sort({ createdAt: -1 });\n\n    res.json({\n      success: true,\n      data: escrows\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao listar escrows:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// FunÃ§Ãµes auxiliares para processamento de pagamento\nfunction processStripePayment(escrow, paymentData) {\n  try {\n    // Implementar lÃ³gica real do Stripe\n    // Por enquanto, simular sucesso\n    return {\n      success: true,\n      paymentId: `stripe_${Date.now()}`\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: 'Erro ao processar pagamento Stripe'\n    };\n  }\n}\n\nfunction processMetaMaskPayment(escrow, paymentData) {\n  try {\n    // Implementar verificaÃ§Ã£o real da blockchain\n    // Por enquanto, simular sucesso\n    return {\n      success: true,\n      paymentId: `metamask_${Date.now()}`\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: 'Erro ao processar pagamento MetaMask'\n    };\n  }\n}\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\external-apis.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\freight.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\freightOrders.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'Vehicle' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport FreightOrder from '../models/FreightOrder.js';\nimport User from '../models/User.js';\nimport Vehicle from '../models/Vehicle.js';\nimport { auth } from '../middleware/auth.js';\nimport logger from '../utils/logger.js';\nimport openaiService from '../services/openaiService.js';\nimport emailService from '../services/emailService.js';\n\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/freight-orders:\n *   post:\n *     summary: Criar novo pedido de frete\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - sellerId\n *               - origin\n *               - destination\n *               - pickupDate\n *               - deliveryDateEstimate\n *               - items\n *               - pricing\n *             properties:\n *               sellerId:\n *                 type: string\n *               origin:\n *                 type: object\n *                 properties:\n *                   address:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   zipCode:\n *                     type: string\n *                   coordinates:\n *                     type: object\n *                     properties:\n *                       lat:\n *                         type: number\n *                       lng:\n *                         type: number\n *                   contact:\n *                     type: object\n *                     properties:\n *                       name:\n *                         type: string\n *                       phone:\n *                         type: string\n *                       email:\n *                         type: string\n *               destination:\n *                 type: object\n *                 properties:\n *                   address:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   zipCode:\n *                     type: string\n *                   coordinates:\n *                     type: object\n *                     properties:\n *                       lat:\n *                         type: number\n *                       lng:\n *                         type: number\n *                   contact:\n *                     type: object\n *                     properties:\n *                       name:\n *                         type: string\n *                       phone:\n *                         type: string\n *                       email:\n *                         type: string\n *               pickupDate:\n *                 type: string\n *                 format: date\n *               deliveryDateEstimate:\n *                 type: string\n *                 format: date\n *               items:\n *                 type: array\n *                 items:\n *                   type: object\n *                   properties:\n *                     name:\n *                       type: string\n *                     description:\n *                       type: string\n *                     quantity:\n *                       type: number\n *                     unit:\n *                       type: string\n *                     weight:\n *                       type: number\n *                     volume:\n *                       type: number\n *                     value:\n *                       type: number\n *                     category:\n *                       type: string\n *                       enum: [grain, livestock, equipment, fertilizer, other]\n *               pricing:\n *                 type: object\n *                 properties:\n *                   basePrice:\n *                     type: number\n *                   additionalFees:\n *                     type: array\n *                     items:\n *                       type: object\n *                       properties:\n *                         name:\n *                           type: string\n *                         amount:\n *                           type: number\n *                         description:\n *                           type: string\n *                   currency:\n *                     type: string\n *                     default: BRL\n *     responses:\n *       201:\n *         description: Pedido de frete criado com sucesso\n *       400:\n *         description: Dados invÃ¡lidos\n */\nrouter.post(\n  '/',\n  auth,\n  [\n    body('sellerId').isMongoId().withMessage('ID do vendedor invÃ¡lido'),\n    body('origin.address').notEmpty().withMessage('EndereÃ§o de origem Ã© obrigatÃ³rio'),\n    body('origin.city').notEmpty().withMessage('Cidade de origem Ã© obrigatÃ³ria'),\n    body('origin.state').notEmpty().withMessage('Estado de origem Ã© obrigatÃ³rio'),\n    body('destination.address').notEmpty().withMessage('EndereÃ§o de destino Ã© obrigatÃ³rio'),\n    body('destination.city').notEmpty().withMessage('Cidade de destino Ã© obrigatÃ³ria'),\n    body('destination.state').notEmpty().withMessage('Estado de destino Ã© obrigatÃ³rio'),\n    body('pickupDate').isISO8601().withMessage('Data de coleta invÃ¡lida'),\n    body('deliveryDateEstimate').isISO8601().withMessage('Data estimada de entrega invÃ¡lida'),\n    body('items').isArray({ min: 1 }).withMessage('Pelo menos um item Ã© obrigatÃ³rio'),\n    body('pricing.basePrice').isNumeric().withMessage('PreÃ§o base Ã© obrigatÃ³rio')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const userId = req.user.id;\n      const freightOrderData = {\n        ...req.body,\n        buyerId: userId\n      };\n\n      const freightOrder = new FreightOrder(freightOrderData);\n      await freightOrder.save();\n\n      // Adicionar evento inicial de criaÃ§Ã£o\n      await freightOrder.addTrackingEvent('created', {}, 'Pedido de frete criado');\n\n      // Enviar notificaÃ§Ã£o para vendedor\n      const seller = await User.findById(freightOrderData.sellerId);\n      if (seller) {\n        await emailService.sendFreightOrderNotification({\n          to: seller.email,\n          name: seller.name,\n          orderNumber: freightOrder.orderNumber,\n          buyerName: req.user.name,\n          origin: freightOrder.origin,\n          destination: freightOrder.destination,\n          pickupDate: freightOrder.pickupDate,\n          totalPrice: freightOrder.pricing.totalPrice\n        });\n      }\n\n      logger.info(\n        `Novo pedido de frete criado: ${freightOrder.orderNumber} por usuÃ¡rio ${userId}`\n      );\n\n      res.status(201).json({\n        success: true,\n        message: 'Pedido de frete criado com sucesso',\n        data: {\n          freightOrder: {\n            id: freightOrder._id,\n            orderNumber: freightOrder.orderNumber,\n            status: freightOrder.status,\n            origin: freightOrder.origin,\n            destination: freightOrder.destination,\n            pickupDate: freightOrder.pickupDate,\n            deliveryDateEstimate: freightOrder.deliveryDateEstimate,\n            items: freightOrder.items,\n            pricing: freightOrder.pricing,\n            createdAt: freightOrder.createdAt\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao criar pedido de frete:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/freight-orders/{id}/tracking:\n *   post:\n *     summary: Atualizar rastreamento do frete\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - status\n *               - location\n *             properties:\n *               status:\n *                 type: string\n *                 enum: [accepted, picked_up, in_transit, delayed, delivered, exception]\n *               location:\n *                 type: object\n *                 properties:\n *                   address:\n *                     type: string\n *                   city:\n *                     type: string\n *                   state:\n *                     type: string\n *                   coordinates:\n *                     type: object\n *                     properties:\n *                       lat:\n *                         type: number\n *                       lng:\n *                         type: number\n *               description:\n *                 type: string\n *               metadata:\n *                 type: object\n *                 properties:\n *                   driver:\n *                     type: string\n *                   vehicle:\n *                     type: string\n *                   notes:\n *                     type: string\n *                   images:\n *                     type: array\n *                     items:\n *                       type: string\n *                   documents:\n *                     type: array\n *                     items:\n *                       type: string\n *     responses:\n *       200:\n *         description: Rastreamento atualizado com sucesso\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.post(\n  '/:id/tracking',\n  auth,\n  [\n    body('status')\n      .isIn(['accepted', 'picked_up', 'in_transit', 'delayed', 'delivered', 'exception'])\n      .withMessage('Status invÃ¡lido'),\n    body('location').isObject().withMessage('LocalizaÃ§Ã£o Ã© obrigatÃ³ria')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { id } = req.params;\n      const { status, location, description, metadata } = req.body;\n      const userId = req.user.id;\n\n      const freightOrder = await FreightOrder.findById(id);\n      if (!freightOrder) {\n        return res.status(404).json({\n          success: false,\n          message: 'Pedido de frete nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio tem permissÃ£o para atualizar\n      if (\n        freightOrder.carrierId?.toString() !== userId &&\n        freightOrder.buyerId?.toString() !== userId &&\n        freightOrder.sellerId?.toString() !== userId\n      ) {\n        return res.status(403).json({\n          success: false,\n          message: 'Sem permissÃ£o para atualizar este pedido'\n        });\n      }\n\n      // Adicionar evento de rastreamento\n      await freightOrder.addTrackingEvent(status, location, description, metadata);\n\n      // Enviar notificaÃ§Ãµes para partes envolvidas\n      const parties = [freightOrder.buyerId, freightOrder.sellerId];\n      if (freightOrder.carrierId) {\n        parties.push(freightOrder.carrierId);\n      }\n\n      for (const partyId of parties) {\n        if (partyId && partyId.toString() !== userId) {\n          const party = await User.findById(partyId);\n          if (party) {\n            await emailService.sendTrackingUpdateNotification({\n              to: party.email,\n              name: party.name,\n              orderNumber: freightOrder.orderNumber,\n              status,\n              location,\n              description\n            });\n          }\n        }\n      }\n\n      logger.info(`Rastreamento atualizado para pedido ${freightOrder.orderNumber}: ${status}`);\n\n      res.status(200).json({\n        success: true,\n        message: 'Rastreamento atualizado com sucesso',\n        data: {\n          freightOrder: {\n            id: freightOrder._id,\n            orderNumber: freightOrder.orderNumber,\n            status: freightOrder.status,\n            trackingEvents: freightOrder.trackingEvents\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao atualizar rastreamento:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/freight-orders/{id}/ai-closure:\n *   post:\n *     summary: Iniciar fechamento assistido por IA\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     responses:\n *       200:\n *         description: Fechamento assistido por IA iniciado\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.post('/:id/ai-closure', auth, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user.id;\n\n    const freightOrder = await FreightOrder.findById(id);\n    if (!freightOrder) {\n      return res.status(404).json({\n        success: false,\n        message: 'Pedido de frete nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem permissÃ£o\n    if (\n      freightOrder.buyerId?.toString() !== userId &&\n      freightOrder.sellerId?.toString() !== userId\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Sem permissÃ£o para fechar este pedido'\n      });\n    }\n\n    // Verificar se o pedido estÃ¡ entregue\n    if (freightOrder.status !== 'delivered') {\n      return res.status(400).json({\n        success: false,\n        message: 'Pedido deve estar entregue para iniciar fechamento'\n      });\n    }\n\n    // Gerar anÃ¡lise de IA\n    const aiAnalysis = await openaiService.generateFreightClosureSummary(freightOrder);\n\n    // Atualizar pedido com anÃ¡lise de IA\n    freightOrder.aiClosure = {\n      ...aiAnalysis,\n      isCompleted: false\n    };\n    await freightOrder.save();\n\n    logger.info(`Fechamento assistido por IA iniciado para pedido ${freightOrder.orderNumber}`);\n\n    res.status(200).json({\n      success: true,\n      message: 'Fechamento assistido por IA iniciado',\n      data: {\n        freightOrder: {\n          id: freightOrder._id,\n          orderNumber: freightOrder.orderNumber,\n          aiClosure: freightOrder.aiClosure\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao iniciar fechamento assistido por IA:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/freight-orders/{id}/complete-closure:\n *   post:\n *     summary: Completar fechamento do pedido\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               confirmClosure:\n *                 type: boolean\n *               customMessage:\n *                 type: string\n *               rating:\n *                 type: number\n *                 minimum: 1\n *                 maximum: 5\n *               comment:\n *                 type: string\n *     responses:\n *       200:\n *         description: Fechamento completado com sucesso\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.post(\n  '/:id/complete-closure',\n  auth,\n  [\n    body('confirmClosure').isBoolean().withMessage('ConfirmaÃ§Ã£o de fechamento Ã© obrigatÃ³ria'),\n    body('rating')\n      .optional()\n      .isInt({ min: 1, max: 5 })\n      .withMessage('AvaliaÃ§Ã£o deve ser entre 1 e 5')\n  ],\n  async (req, res) => {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        return res.status(400).json({\n          success: false,\n          message: 'Dados invÃ¡lidos',\n          errors: errors.array()\n        });\n      }\n\n      const { id } = req.params;\n      const { confirmClosure, customMessage, rating, comment } = req.body;\n      const userId = req.user.id;\n\n      const freightOrder = await FreightOrder.findById(id);\n      if (!freightOrder) {\n        return res.status(404).json({\n          success: false,\n          message: 'Pedido de frete nÃ£o encontrado'\n        });\n      }\n\n      // Verificar se o usuÃ¡rio tem permissÃ£o\n      if (\n        freightOrder.buyerId?.toString() !== userId &&\n        freightOrder.sellerId?.toString() !== userId\n      ) {\n        return res.status(403).json({\n          success: false,\n          message: 'Sem permissÃ£o para fechar este pedido'\n        });\n      }\n\n      if (!confirmClosure) {\n        return res.status(400).json({\n          success: false,\n          message: 'Fechamento nÃ£o confirmado'\n        });\n      }\n\n      // Completar fechamento\n      const finalMessage = customMessage || freightOrder.aiClosure.suggestedMessage;\n      await freightOrder.completeAIClosure(\n        freightOrder.aiClosure.summary,\n        freightOrder.aiClosure.performanceMetrics,\n        finalMessage,\n        freightOrder.aiClosure.invoiceDraft\n      );\n\n      // Adicionar avaliaÃ§Ã£o se fornecida\n      if (rating && comment) {\n        const userType = freightOrder.buyerId?.toString() === userId ? 'buyer' : 'seller';\n        await freightOrder.rateUser(userType, rating, comment, userId);\n      }\n\n      logger.info(`Pedido de frete ${freightOrder.orderNumber} fechado com sucesso`);\n\n      res.status(200).json({\n        success: true,\n        message: 'Fechamento completado com sucesso',\n        data: {\n          freightOrder: {\n            id: freightOrder._id,\n            orderNumber: freightOrder.orderNumber,\n            status: freightOrder.status,\n            aiClosure: freightOrder.aiClosure,\n            rating: freightOrder.rating\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('Erro ao completar fechamento:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  }\n);\n\n/**\n * @swagger\n * /api/freight-orders:\n *   get:\n *     summary: Listar pedidos de frete do usuÃ¡rio\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: query\n *         name: status\n *         schema:\n *           type: string\n *           enum: [pending, accepted, picked_up, in_transit, delivered, closed, cancelled]\n *       - in: query\n *         name: role\n *         schema:\n *           type: string\n *           enum: [buyer, seller, carrier]\n *     responses:\n *       200:\n *         description: Lista de pedidos de frete\n */\nrouter.get('/', auth, async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { status, role } = req.query;\n\n    let query = {};\n\n    if (role === 'buyer') {\n      query.buyerId = userId;\n    } else if (role === 'seller') {\n      query.sellerId = userId;\n    } else if (role === 'carrier') {\n      query.carrierId = userId;\n    } else {\n      // Buscar todos os pedidos onde o usuÃ¡rio estÃ¡ envolvido\n      query = {\n        $or: [{ buyerId: userId }, { sellerId: userId }, { carrierId: userId }]\n      };\n    }\n\n    if (status) {\n      query.status = status;\n    }\n\n    const freightOrders = await FreightOrder.find(query)\n      .populate('buyerId', 'name email')\n      .populate('sellerId', 'name email')\n      .populate('carrierId', 'name email')\n      .sort({ createdAt: -1 });\n\n    res.status(200).json({\n      success: true,\n      data: {\n        freightOrders: freightOrders.map(order => ({\n          id: order._id,\n          orderNumber: order.orderNumber,\n          status: order.status,\n          origin: order.origin,\n          destination: order.destination,\n          pickupDate: order.pickupDate,\n          deliveryDateEstimate: order.deliveryDateEstimate,\n          deliveryDateActual: order.deliveryDateActual,\n          items: order.items,\n          pricing: order.pricing,\n          buyer: order.buyerId,\n          seller: order.sellerId,\n          carrier: order.carrierId,\n          trackingEvents: order.trackingEvents,\n          aiClosure: order.aiClosure,\n          rating: order.rating,\n          createdAt: order.createdAt,\n          updatedAt: order.updatedAt\n        }))\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao listar pedidos de frete:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n/**\n * @swagger\n * /api/freight-orders/{id}:\n *   get:\n *     summary: Obter detalhes de um pedido de frete\n *     tags: [FreightOrders]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *     responses:\n *       200:\n *         description: Detalhes do pedido de frete\n *       404:\n *         description: Pedido de frete nÃ£o encontrado\n */\nrouter.get('/:id', auth, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user.id;\n\n    const freightOrder = await FreightOrder.findById(id)\n      .populate('buyerId', 'name email phone')\n      .populate('sellerId', 'name email phone')\n      .populate('carrierId', 'name email phone');\n\n    if (!freightOrder) {\n      return res.status(404).json({\n        success: false,\n        message: 'Pedido de frete nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem permissÃ£o para ver\n    if (\n      freightOrder.buyerId?._id.toString() !== userId &&\n      freightOrder.sellerId?._id.toString() !== userId &&\n      freightOrder.carrierId?._id.toString() !== userId\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Sem permissÃ£o para visualizar este pedido'\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      data: {\n        freightOrder: {\n          id: freightOrder._id,\n          orderNumber: freightOrder.orderNumber,\n          status: freightOrder.status,\n          origin: freightOrder.origin,\n          destination: freightOrder.destination,\n          pickupDate: freightOrder.pickupDate,\n          deliveryDateEstimate: freightOrder.deliveryDateEstimate,\n          deliveryDateActual: freightOrder.deliveryDateActual,\n          items: freightOrder.items,\n          pricing: freightOrder.pricing,\n          vehicle: freightOrder.vehicle,\n          documents: freightOrder.documents,\n          trackingEvents: freightOrder.trackingEvents,\n          aiClosure: freightOrder.aiClosure,\n          rating: freightOrder.rating,\n          notifications: freightOrder.notifications,\n          buyer: freightOrder.buyerId,\n          seller: freightOrder.sellerId,\n          carrier: freightOrder.carrierId,\n          createdAt: freightOrder.createdAt,\n          updatedAt: freightOrder.updatedAt\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Erro ao obter pedido de frete:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\freights.js",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: '}' expected.",
        "line": 489,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport Freight from '../models/Freight.js';\nimport User from '../models/User.js';\nimport { validateFreight } from '../middleware/validation.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { authenticateToken, requireActivePlan } from '../middleware/auth.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// GET /api/freights - Get all freights with pagination and filters\nrouter.get('/', async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 20,\n      originCity,\n      originState,\n      destCity,\n      destState,\n      cargoType,\n      minWeight,\n      maxWeight,\n      maxPrice,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = req.query;\n\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    // Build query\n    const query = { status: 'active' };\n\n    if (originCity) {\n      query['origin.city'] = { $regex: originCity, $options: 'i' };\n    }\n    if (originState) {\n      query['origin.state'] = { $regex: originState, $options: 'i' };\n    }\n    if (destCity) {\n      query['destination.city'] = { $regex: destCity, $options: 'i' };\n    }\n    if (destState) {\n      query['destination.state'] = { $regex: destState, $options: 'i' };\n    }\n    if (cargoType) {\n      query.cargoType = cargoType;\n    }\n    if (minWeight || maxWeight) {\n      query.weight = {};\n      if (minWeight) {\n        query.weight.min = { $gte: parseFloat(minWeight) };\n      }\n      if (maxWeight) {\n        query.weight.max = { $lte: parseFloat(maxWeight) };\n      }\n    }\n    if (maxPrice) {\n      query.price = { $lte: parseFloat(maxPrice) };\n    }\n\n    // Build sort\n    const sort = {};\n    sort[sortBy] = sortOrder === 'desc' ? -1 : 1;\n\n    // Execute query\n    const freights = await Freight.find(query)\n      .sort(sort)\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .populate('providerId', 'name company.name phone')\n      .lean();\n\n    // Get total count for pagination\n    const total = await Freight.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        freights,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching freights:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/freights/route/:originCity/:originState/:destCity/:destState - Search by route\nrouter.get('/route/:originCity/:originState/:destCity/:destState', async (req, res) => {\n  try {\n    const { originCity, originState, destCity, destState } = req.params;\n    const { limit = 20 } = req.query;\n\n    const freights = await Freight.findByRoute(\n      originCity,\n      originState,\n      destCity,\n      destState,\n      parseInt(limit, 10, 10)\n    );\n\n    res.json({\n      success: true,\n      data: { freights }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error searching freights by route:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/freights/cargo/:cargoType - Get freights by cargo type\nrouter.get('/cargo/:cargoType', async (req, res) => {\n  try {\n    const { cargoType } = req.params;\n    const { limit = 20 } = req.query;\n\n    const freights = await Freight.findByCargoType(cargoType, parseInt(limit, 10, 10));\n\n    res.json({\n      success: true,\n      data: { freights }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching freights by cargo type:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/freights/available - Get available freights with advanced filters\nrouter.get('/available', async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 20,\n      originCity,\n      originState,\n      destCity,\n      destState,\n      cargoType,\n      minWeight,\n      maxWeight,\n      maxPrice,\n      vehicleType\n    } = req.query;\n\n    const filters = {};\n    if (originCity) {\n      filters.originCity = originCity;\n    }\n    if (originState) {\n      filters.originState = originState;\n    }\n    if (destCity) {\n      filters.destCity = destCity;\n    }\n    if (destState) {\n      filters.destState = destState;\n    }\n    if (cargoType) {\n      filters.cargoType = cargoType;\n    }\n    if (minWeight) {\n      filters.minWeight = parseFloat(minWeight);\n    }\n    if (maxWeight) {\n      filters.maxWeight = parseFloat(maxWeight);\n    }\n    if (maxPrice) {\n      filters.maxPrice = parseFloat(maxPrice);\n    }\n    if (vehicleType) {\n      filters.vehicleType = vehicleType;\n    }\n\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const freights = await Freight.findAvailable(filters, parseInt(limit, 10, 10), skip);\n\n    // Get total count\n    const totalQuery = { status: 'active' };\n    if (originCity) {\n      totalQuery['origin.city'] = { $regex: originCity, $options: 'i' };\n    }\n    if (originState) {\n      totalQuery['origin.state'] = { $regex: originState, $options: 'i' };\n    }\n    if (destCity) {\n      totalQuery['destination.city'] = { $regex: destCity, $options: 'i' };\n    }\n    if (destState) {\n      totalQuery['destination.state'] = { $regex: destState, $options: 'i' };\n    }\n    if (cargoType) {\n      totalQuery.cargoType = cargoType;\n    }\n    if (vehicleType) {\n      totalQuery.vehicleType = vehicleType;\n    }\n\n    const total = await Freight.countDocuments(totalQuery);\n\n    res.json({\n      success: true,\n      data: {\n        freights,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching available freights:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/freights/:id - Get freight by ID\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    const freight = await Freight.findById(id)\n      .populate('providerId', 'name company.name phone')\n      .lean();\n\n    if (!freight) {\n      return res.status(404).json({\n        success: false,\n        message: 'Frete nÃ£o encontrado'\n      });\n    }\n\n    if (freight.status !== 'active') {\n      return res.status(404).json({\n        success: false,\n        message: 'Frete nÃ£o disponÃ­vel'\n      });\n    }\n\n    // Increment view count (async, don't wait)\n    Freight.findByIdAndUpdate(id, { $inc: { views: 1 } }).exec();\n\n    res.json({\n      success: true,\n      data: { freight }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching freight:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/freights - Create new freight (requires authentication and active freight plan)\nrouter.post('/', authenticateToken, requireActivePlan, validateFreight, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Check if user has active freight plan\n    const user = await User.findById(userId);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    if (!user.hasActivePlan('freight')) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano de frete nÃ£o ativo. Ative um plano para criar fretes.'\n      });\n    }\n\n    if (!user.canCreateFreight()) {\n      return res.status(403).json({\n        success: false,\n        message: 'Limite de fretes atingido. FaÃ§a upgrade do seu plano.'\n      });\n    }\n\n    // Create freight\n    const freightData = {\n      ...req.body,\n      providerId: userId\n    };\n\n    const freight = new Freight(freightData);\n    await freight.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Frete criado com sucesso',\n      data: { freight }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating freight:', error);\n    }\n    if (error.message.includes('Plano de frete nÃ£o ativo')) {\n      return res.status(403).json({\n        success: false,\n        message: error.message\n      });\n    }\n\n    if (error.message.includes('Limite de fretes atingido')) {\n      return res.status(403).json({\n        success: false,\n        message: error.message\n      });\n    }\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/freights/:id - Update freight\nrouter.put('/:id', authenticateToken, validateFreight, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const freight = await Freight.findById(id);\n    if (!freight) {\n      return res.status(404).json({\n        success: false,\n        message: 'Frete nÃ£o encontrado'\n      });\n    }\n\n    // Check if user owns the freight\n    if (freight.providerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. VocÃª sÃ³ pode editar seus prÃ³prios fretes.'\n      });\n    }\n\n    // Update freight\n    Object.assign(freight, req.body);\n    await freight.save();\n\n    res.json({\n      success: true,\n      message: 'Frete atualizado com sucesso',\n      data: { freight }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating freight:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/freights/:id - Delete freight\nrouter.delete('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const freight = await Freight.findById(id);\n    if (!freight) {\n      return res.status(404).json({\n        success: false,\n        message: 'Frete nÃ£o encontrado'\n      });\n    }\n\n    // Check if user owns the freight\n    if (freight.providerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. VocÃª sÃ³ pode excluir seus prÃ³prios fretes.'\n      });\n    }\n\n    // Soft delete - mark as inactive\n    freight.status = 'inactive';\n    await freight.save();\n\n    res.json({\n      success: true,\n      message: 'Frete removido com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error deleting freight:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/freights/:id/inquiry - Send inquiry about freight\nrouter.post('/:id/inquiry', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n    const { message } = req.body;\n\n    if (!message || message.trim().length < 10) {\n      return res.status(400).json({\n        success: false,\n        message: 'Mensagem deve ter pelo menos 10 caracteres'\n      });\n    }\n\n    const freight = await Freight.findById(id);\n    if (!freight) {\n      return res.status(404).json({\n        success: false,\n        message: 'Frete nÃ£o encontrado'\n      });\n    }\n\n    if (freight.providerId.toString() === userId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Voc\\u00ea n\\u00e3o pode enviar uma consulta para seu pr\\u00f3prio frete'\n      });\n    }\n\n    // Create inquiry (simplified - you may want to persist this and notify the provider)\n    const inquiry = {\n      from: userId,\n      to: freight.providerId,\n      freightId: freight._id,\n      message,\n      createdAt: new Date()\n    };\n\n    // Optionally persist inquiry or send notification here\n    logger.info('Freight inquiry created', inquiry);\n\n    res.status(201).json({\n      success: true,\n      message: 'Consulta enviada com sucesso',\n      data: inquiry\n    });\n\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\gamification.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 12
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'Transaction' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 6,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport UserReputation from '../models/UserReputation.js';\nimport User from '../models/User.js';\nimport Transaction from '../models/Transaction.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Aplicar rate limiting\nrouter.use(apiLimiter);\n\n// Aplicar autenticaÃ§Ã£o em todas as rotas\nrouter.use(authenticateToken);\n\n// ===== ROTAS DE GAMIFICAÃ‡ÃƒO =====\n\n// GET /api/gamification/profile - Obter perfil de reputaÃ§Ã£o do usuÃ¡rio\nrouter.get('/profile', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    let userReputation = await UserReputation.findOne({ userId }).populate(\n      'userId',\n      'name email avatar'\n    );\n\n    if (!userReputation) {\n      // Criar perfil de reputaÃ§Ã£o se nÃ£o existir\n      userReputation = new UserReputation({ userId });\n      await userReputation.save();\n    }\n\n    res.json({\n      success: true,\n      data: userReputation\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar perfil de reputaÃ§Ã£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/leaderboard - Obter ranking global\nrouter.get('/leaderboard', async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 20,\n      category = 'global', // 'global', 'regional', 'category'\n      region = null\n    } = req.query;\n\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = {};\n\n    // Filtrar por regiÃ£o se especificado\n    if (region && category === 'regional') {\n      query['userId.region'] = region;\n    }\n\n    // Buscar ranking\n    const leaderboard = await UserReputation.find(query)\n      .populate('userId', 'name email avatar region')\n      .sort({ totalScore: -1, level: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10));\n\n    const total = await UserReputation.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        leaderboard,\n        pagination: {\n          page: parseInt(page, 10, 10),\n          limit: parseInt(limit, 10, 10),\n          total,\n          pages: Math.ceil(total / parseInt(limit, 10, 10))\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar ranking:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/badges - Obter badges disponÃ­veis\nrouter.get('/badges', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      return res.status(404).json({\n        success: false,\n        message: 'Perfil de reputaÃ§Ã£o nÃ£o encontrado'\n      });\n    }\n\n    // Calcular novos badges\n    const newBadges = userReputation.calculateBadges();\n\n    // Adicionar novos badges se houver\n    if (newBadges.length > 0) {\n      userReputation.badges.push(...newBadges);\n      await userReputation.save();\n    }\n\n    res.json({\n      success: true,\n      data: {\n        earnedBadges: userReputation.badges,\n        newBadges\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar badges:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/gamification/points - Adicionar pontos (para aÃ§Ãµes do usuÃ¡rio)\nrouter.post('/points', async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { action, points, description, metadata } = req.body;\n\n    if (!action || !points || !description) {\n      return res.status(400).json({\n        success: false,\n        message: 'AÃ§Ã£o, pontos e descriÃ§Ã£o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    let userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      userReputation = new UserReputation({ userId });\n    }\n\n    // Adicionar pontos\n    userReputation.addPoints(points, action, description, metadata);\n\n    // Calcular novos badges\n    const newBadges = userReputation.calculateBadges();\n    if (newBadges.length > 0) {\n      userReputation.badges.push(...newBadges);\n    }\n\n    await userReputation.save();\n\n    res.json({\n      success: true,\n      data: {\n        newScore: userReputation.totalScore,\n        newLevel: userReputation.level,\n        newBadges,\n        levelUp: newBadges.length > 0\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao adicionar pontos:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/stats - Obter estatÃ­sticas do usuÃ¡rio\nrouter.get('/stats', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      return res.status(404).json({\n        success: false,\n        message: 'Perfil de reputaÃ§Ã£o nÃ£o encontrado'\n      });\n    }\n\n    // Calcular estatÃ­sticas adicionais\n    const stats = {\n      ...userReputation.toObject(),\n      progressToNextLevel: {\n        current: userReputation.experience,\n        required: userReputation.experienceToNextLevel,\n        percentage: Math.round(\n          (userReputation.experience / userReputation.experienceToNextLevel) * 100\n        )\n      },\n      ranking: {\n        global:\n          (await UserReputation.countDocuments({\n            totalScore: { $gt: userReputation.totalScore }\n          })) + 1,\n        regional:\n          (await UserReputation.countDocuments({\n            totalScore: { $gt: userReputation.totalScore },\n            'userId.region': userReputation.userId?.region\n          })) + 1\n      }\n    };\n\n    res.json({\n      success: true,\n      data: stats\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar estatÃ­sticas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/gamification/notifications - Atualizar configuraÃ§Ãµes de notificaÃ§Ãµes\nrouter.put('/notifications', async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { notifications } = req.body;\n\n    if (!notifications || typeof notifications !== 'object') {\n      return res.status(400).json({\n        success: false,\n        message: 'ConfiguraÃ§Ãµes de notificaÃ§Ãµes sÃ£o obrigatÃ³rias'\n      });\n    }\n\n    const userReputation = await UserReputation.findOne({ userId });\n    if (!userReputation) {\n      return res.status(404).json({\n        success: false,\n        message: 'Perfil de reputaÃ§Ã£o nÃ£o encontrado'\n      });\n    }\n\n    // Atualizar configuraÃ§Ãµes\n    userReputation.notifications = {\n      ...userReputation.notifications,\n      ...notifications\n    };\n\n    await userReputation.save();\n\n    res.json({\n      success: true,\n      data: userReputation.notifications\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao atualizar notificaÃ§Ãµes:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/gamification/achievements - Obter conquistas disponÃ­veis\nrouter.get('/achievements', (req, res) => {\n  try {\n    const achievements = [\n      {\n        id: 'FIRST_TRANSACTION',\n        name: 'Primeira TransaÃ§Ã£o',\n        description: 'Completou sua primeira transaÃ§Ã£o',\n        icon: 'ðŸŽ¯',\n        category: 'TRANSACTION',\n        rarity: 'COMMON',\n        requirement: '1 transaÃ§Ã£o',\n        points: 50\n      },\n      {\n        id: 'ACTIVE_SELLER',\n        name: 'Vendedor Ativo',\n        description: 'Cadastrou 10 ou mais produtos',\n        icon: 'ðŸª',\n        category: 'PRODUCT',\n        rarity: 'RARE',\n        requirement: '10 produtos',\n        points: 200\n      },\n      {\n        id: 'TRANSPORTER',\n        name: 'Transportador',\n        description: 'Completou 5 ou mais fretes',\n        icon: 'ðŸšš',\n        category: 'FREIGHT',\n        rarity: 'RARE',\n        requirement: '5 fretes',\n        points: 200\n      },\n      {\n        id: 'TRUSTED_USER',\n        name: 'UsuÃ¡rio ConfiÃ¡vel',\n        description: 'Alta avaliaÃ§Ã£o e muitas transaÃ§Ãµes bem-sucedidas',\n        icon: 'â­',\n        category: 'SPECIAL',\n        rarity: 'EPIC',\n        requirement: '4.5+ rating, 20+ transaÃ§Ãµes',\n        points: 500\n      },\n      {\n        id: 'TOP_SELLER',\n        name: 'Top Vendedor',\n        description: 'Vendeu mais de R$ 10.000 em produtos',\n        icon: 'ðŸ‘‘',\n        category: 'SPECIAL',\n        rarity: 'LEGENDARY',\n        requirement: 'R$ 10.000+ em vendas',\n        points: 1000\n      }\n    ];\n\n    res.json({\n      success: true,\n      data: achievements\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar conquistas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\geolocation.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\health-check.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\health.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\marketplace.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\messages.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\messaging.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'requireActivePlan' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport PrivateMessage from '../models/PrivateMessage.js';\nimport ContactMessage from '../models/ContactMessage.js';\nimport PartnershipMessage from '../models/PartnershipMessage.js';\nimport User from '../models/User.js';\nimport { validateMessage } from '../middleware/validation.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { authenticateToken, requireActivePlan } from '../middleware/auth.js';\n\nconst router = express.Router();\nimport logger from '../utils/logger.js';\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// ===== PRIVATE MESSAGES (requires active subscription) =====\n\n// GET /api/messaging/conversations - Get user's conversations\nrouter.get('/conversations', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Check if user has any active plan\n    const user = await User.findById(userId);\n    if (!user.hasActivePlan('store') && !user.hasActivePlan('freight')) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano ativo necessÃ¡rio para acessar mensagens privadas'\n      });\n    }\n\n    // Get conversations (simplified - you might want to implement a more sophisticated approach)\n    const conversations = await PrivateMessage.aggregate([\n      {\n        $match: {\n          $or: [{ senderId: userId }, { receiverId: userId }]\n        }\n      },\n      {\n        $group: {\n          _id: {\n            $cond: [{ $eq: ['$senderId', userId] }, '$receiverId', '$senderId']\n          },\n          lastMessage: { $first: '$$ROOT' },\n          unreadCount: {\n            $sum: {\n              $cond: [\n                { $and: [{ $eq: ['$receiverId', userId] }, { $eq: ['$isRead', false] }] },\n                1,\n                0\n              ]\n            }\n          }\n        }\n      },\n      {\n        $sort: { 'lastMessage.createdAt': -1 }\n      }\n    ]);\n\n    // Populate user information\n    const populatedConversations = await PrivateMessage.populate(conversations, [\n      { path: '_id', select: 'name company.name' },\n      { path: 'lastMessage.senderId', select: 'name company.name' },\n      { path: 'lastMessage.receiverId', select: 'name company.name' }\n    ]);\n\n    res.json({\n      success: true,\n      data: { conversations: populatedConversations }\n    });\n  } catch (error) {\n    logger.error('Error fetching conversations:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/messaging/conversation/:otherUserId - Get conversation with specific user\nrouter.get('/conversation/:otherUserId', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { otherUserId } = req.params;\n\n    // Check if user has any active plan\n    const user = await User.findById(userId);\n    if (!user.hasActivePlan('store') && !user.hasActivePlan('freight')) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano ativo necessÃ¡rio para acessar mensagens privadas'\n      });\n    }\n\n    const messages = await PrivateMessage.getConversation(userId, otherUserId, 100);\n\n    res.json({\n      success: true,\n      data: { messages }\n    });\n  } catch (error) {\n    logger.error('Error fetching conversation:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/messaging/send - Send private message\nrouter.post('/send', authenticateToken, validateMessage, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { receiverId, subject, content, messageType, relatedProduct, relatedFreight } = req.body;\n\n    // Check if user has any active plan\n    const user = await User.findById(userId);\n    if (!user.hasActivePlan('store') && !user.hasActivePlan('freight')) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano ativo necessÃ¡rio para enviar mensagens privadas'\n      });\n    }\n\n    // Check if receiver exists\n    const receiver = await User.findById(receiverId);\n    if (!receiver) {\n      return res.status(404).json({\n        success: false,\n        message: 'DestinatÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Create message\n    const message = new PrivateMessage({\n      senderId: userId,\n      receiverId,\n      subject,\n      content,\n      messageType: messageType || 'general',\n      relatedProduct,\n      relatedFreight\n    });\n\n    await message.save();\n\n    // Populate sender and receiver info\n    await message.populate([\n      { path: 'senderId', select: 'name company.name' },\n      { path: 'receiverId', select: 'name company.name' }\n    ]);\n\n    res.status(201).json({\n      success: true,\n      message: 'Mensagem enviada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    logger.error('Error sending message:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/messaging/:messageId/read - Mark message as read\nrouter.put('/:messageId/read', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { messageId } = req.params;\n\n    // Check if user has any active plan\n    const user = await User.findById(userId);\n    if (!user.hasActivePlan('store') && !user.hasActivePlan('freight')) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano ativo necessÃ¡rio para acessar mensagens privadas'\n      });\n    }\n\n    const message = await PrivateMessage.findById(messageId);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Check if user is the receiver\n    if (message.receiverId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado'\n      });\n    }\n\n    await message.markAsRead();\n\n    res.json({\n      success: true,\n      message: 'Mensagem marcada como lida'\n    });\n  } catch (error) {\n    logger.error('Error marking message as read:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/messaging/unread - Get unread messages count\nrouter.get('/unread', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Check if user has any active plan\n    const user = await User.findById(userId);\n    if (!user.hasActivePlan('store') && !user.hasActivePlan('freight')) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano ativo necessÃ¡rio para acessar mensagens privadas'\n      });\n    }\n\n    const unreadMessages = await PrivateMessage.getUnreadMessages(userId);\n    const unreadCount = unreadMessages.length;\n\n    res.json({\n      success: true,\n      data: { unreadCount, unreadMessages }\n    });\n  } catch (error) {\n    logger.error('Error fetching unread messages:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== CONTACT FORM (public, goes to admin) =====\n\n// POST /api/messaging/contact - Send contact message\nrouter.post('/contact', async (req, res) => {\n  try {\n    const { name, email, subject, message } = req.body;\n\n    // Basic validation\n    if (!name || !email || !subject || !message) {\n      return res.status(400).json({\n        success: false,\n        message: 'Todos os campos sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    if (message.trim().length < 10) {\n      return res.status(400).json({\n        success: false,\n        message: 'Mensagem deve ter pelo menos 10 caracteres'\n      });\n    }\n\n    // Create contact message\n    const contactMessage = new ContactMessage({\n      name,\n      email,\n      subject,\n      message\n    });\n\n    await contactMessage.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Mensagem de contato enviada com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error sending contact message:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== PARTNERSHIP INQUIRIES (public, goes to admin) =====\n\n// POST /api/messaging/partnership - Send partnership inquiry\nrouter.post('/partnership', async (req, res) => {\n  try {\n    const { company, contactPerson, email, phone, partnershipType, description } = req.body;\n\n    // Basic validation\n    if (!company || !contactPerson || !email || !partnershipType || !description) {\n      return res.status(400).json({\n        success: false,\n        message: 'Todos os campos obrigatÃ³rios devem ser preenchidos'\n      });\n    }\n\n    if (description.trim().length < 20) {\n      return res.status(400).json({\n        success: false,\n        message: 'DescriÃ§Ã£o deve ter pelo menos 20 caracteres'\n      });\n    }\n\n    // Create partnership message\n    const partnershipMessage = new PartnershipMessage({\n      company,\n      contactPerson,\n      email,\n      phone,\n      partnershipType,\n      description\n    });\n\n    await partnershipMessage.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'SolicitaÃ§Ã£o de parceria enviada com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error sending partnership inquiry:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ADMIN ROUTES (protected) =====\n\n// GET /api/messaging/admin/contact - Get contact messages (admin only)\nrouter.get('/admin/contact', authenticateToken, async (req, res) => {\n  try {\n    // Check if user is admin\n    if (req.user.userType !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. PrivilÃ©gios de administrador necessÃ¡rios.'\n      });\n    }\n\n    const { page = 1, limit = 20, status } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = {};\n    if (status) {\n      query.status = status;\n    }\n\n    const messages = await ContactMessage.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .lean();\n\n    const total = await ContactMessage.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        messages,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Error fetching contact messages:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/messaging/admin/partnership - Get partnership messages (admin only)\nrouter.get('/admin/partnership', authenticateToken, async (req, res) => {\n  try {\n    // Check if user is admin\n    if (req.user.userType !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. PrivilÃ©gios de administrador necessÃ¡rios.'\n      });\n    }\n\n    const { page = 1, limit = 20, status } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = {};\n    if (status) {\n      query.status = status;\n    }\n\n    const messages = await PartnershipMessage.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .lean();\n\n    const total = await PartnershipMessage.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        messages,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership messages:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/messaging/admin/private - Get private messages (admin only)\nrouter.get('/admin/private', authenticateToken, async (req, res) => {\n  try {\n    // Check if user is admin\n    if (req.user.userType !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. PrivilÃ©gios de administrador necessÃ¡rios.'\n      });\n    }\n\n    const { page = 1, limit = 20, status } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = {};\n    if (status) {\n      query.status = status;\n    }\n\n    const messages = await PrivateMessage.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .populate('senderId', 'name email company.name')\n      .populate('receiverId', 'name email company.name')\n      .lean();\n\n    const total = await PrivateMessage.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        messages,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching private messages:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/messaging/admin/contact/:id/status - Update contact message status (admin only)\nrouter.put('/admin/contact/:id/status', authenticateToken, async (req, res) => {\n  try {\n    // Check if user is admin\n    if (req.user.userType !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. PrivilÃ©gios de administrador necessÃ¡rios.'\n      });\n    }\n\n    const { id } = req.params;\n    const { status, adminResponse } = req.body;\n\n    const message = await ContactMessage.findById(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    if (status === 'replied' && adminResponse) {\n      message.adminResponse = adminResponse;\n      message.repliedAt = new Date();\n      message.repliedBy = req.user.userId;\n    }\n\n    message.status = status;\n    await message.save();\n\n    res.json({\n      success: true,\n      message: 'Status da mensagem atualizado com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating contact message status:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/messaging/admin/partnership/:id/status - Update partnership message status (admin only)\nrouter.put('/admin/partnership/:id/status', authenticateToken, async (req, res) => {\n  try {\n    // Check if user is admin\n    if (req.user.userType !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. PrivilÃ©gios de administrador necessÃ¡rios.'\n      });\n    }\n\n    const { id } = req.params;\n    const { status, adminResponse } = req.body;\n\n    const message = await PartnershipMessage.findById(id);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    if (status === 'contacted' && adminResponse) {\n      message.adminResponse = adminResponse;\n      message.contactedAt = new Date();\n      message.contactedBy = req.user.userId;\n    }\n\n    message.status = status;\n    await message.save();\n\n    res.json({\n      success: true,\n      message: 'Status da mensagem atualizado com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating partnership message status:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\mirror-apis.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'getClientIP' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 4,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { externalAPIService } from '../services/externalAPIs.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { getClientIP } from '../utils/ipUtils.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Aplicar rate limiting especÃ­fico para mirrors\nrouter.use(apiLimiter);\n\n// ===== MIRROR API - BAIDU MAPS =====\n\n// GET /api/mirror/baidu?query=... - Geocoding e busca de endereÃ§os\nrouter.get('/baidu', async (req, res) => {\n  try {\n    const { query, lat, lng, type = 'geocoding' } = req.query;\n\n    if (!query && !lat && !lng) {\n      return res.status(400).json({\n        success: false,\n        message: 'Query de busca ou coordenadas (lat/lng) sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    let result;\n    if (type === 'geocoding' && query) {\n      // Buscar coordenadas por endereÃ§o\n      result = await externalAPIService.buscarCoordenadasBaidu(query);\n    } else if (type === 'reverse' && lat && lng) {\n      // Buscar endereÃ§o por coordenadas\n      result = await externalAPIService.buscarEnderecoBaidu(lat, lng);\n    } else if (type === 'search' && query) {\n      // Busca geral de lugares\n      result = await externalAPIService.buscarLugaresBaidu(query);\n    } else {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipo de busca invÃ¡lido ou parÃ¢metros insuficientes'\n      });\n    }\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'baidu-maps',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no mirror Baidu Maps:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// ===== MIRROR API - RECEITA FEDERAL =====\n\n// GET /api/mirror/receita/validate?cnpj=... - Validar CNPJ\nrouter.get('/receita/validate', async (req, res) => {\n  try {\n    const { cnpj, cpf, ie } = req.query;\n\n    if (!cnpj && !cpf && !ie) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ, CPF ou IE deve ser fornecido'\n      });\n    }\n\n    let result;\n    if (cnpj) {\n      result = await externalAPIService.validarCNPJ(cnpj);\n    } else if (cpf) {\n      result = await externalAPIService.validarCPF(cpf);\n    } else if (ie) {\n      result = await externalAPIService.validarIE(ie);\n    }\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'receita-federal',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no mirror Receita Federal:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// GET /api/mirror/receita/company/:cnpj - Obter dados da empresa\nrouter.get('/receita/company/:cnpj', async (req, res) => {\n  try {\n    const { cnpj } = req.params;\n\n    if (!cnpj) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ Ã© obrigatÃ³rio'\n      });\n    }\n\n    const result = await externalAPIService.obterDadosEmpresa(cnpj);\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'receita-federal',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter dados da empresa:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// ===== MIRROR API - IBGE =====\n\n// GET /api/mirror/ibge?cep=... - Buscar dados por CEP\nrouter.get('/ibge', async (req, res) => {\n  try {\n    const { cep, uf, municipio } = req.query;\n\n    if (!cep && !uf && !municipio) {\n      return res.status(400).json({\n        success: false,\n        message: 'CEP, UF ou municÃ­pio deve ser fornecido'\n      });\n    }\n\n    let result;\n    if (cep) {\n      result = await externalAPIService.consultarCEP(cep);\n    } else if (uf && municipio) {\n      result = await externalAPIService.buscarMunicipioPorNome(uf, municipio);\n    } else if (uf) {\n      result = await externalAPIService.buscarMunicipiosPorEstado(uf);\n    } else {\n      return res.status(400).json({\n        success: false,\n        message: 'ParÃ¢metros insuficientes para busca'\n      });\n    }\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'ibge',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no mirror IBGE:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// GET /api/mirror/ibge/estados - Listar todos os estados\nrouter.get('/ibge/estados', async (req, res) => {\n  try {\n    const result = await externalAPIService.buscarEstados();\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'ibge',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar estados:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// GET /api/mirror/ibge/estados/:uf/municipios - Listar municÃ­pios por estado\nrouter.get('/ibge/estados/:uf/municipios', async (req, res) => {\n  try {\n    const { uf } = req.params;\n\n    if (!uf) {\n      return res.status(400).json({\n        success: false,\n        message: 'UF Ã© obrigatÃ³ria'\n      });\n    }\n\n    const result = await externalAPIService.buscarMunicipiosPorEstado(uf);\n\n    if (result.success) {\n      res.json({\n        success: true,\n        data: result.data,\n        source: 'ibge',\n        cached: result.cached || false,\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar municÃ­pios:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// ===== MIRROR API - STATUS E SAÃšDE =====\n\n// GET /api/mirror/status - Status das APIs mirror\nrouter.get('/status', (req, res) => {\n  try {\n    const status = {\n      baidu: {\n        status: 'operational',\n        lastCheck: new Date().toISOString(),\n        endpoints: ['/api/mirror/baidu']\n      },\n      receita: {\n        status: 'operational',\n        lastCheck: new Date().toISOString(),\n        endpoints: ['/api/mirror/receita/validate', '/api/mirror/receita/company/:cnpj']\n      },\n      ibge: {\n        status: 'operational',\n        lastCheck: new Date().toISOString(),\n        endpoints: [\n          '/api/mirror/ibge',\n          '/api/mirror/ibge/estados',\n          '/api/mirror/ibge/estados/:uf/municipios'\n        ]\n      }\n    };\n\n    res.json({\n      success: true,\n      data: status,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar status dos mirrors:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\news.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'getClientIP' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 3,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { getClientIP } from '../utils/ipUtils.js';\nimport axios from 'axios';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// Simulated news data (in production, this would come from a database or external API)\nconst mockNews = [\n  {\n    id: 1,\n    title: 'Safra de soja 2024/25 deve crescer 5% no Brasil',\n    summary: 'Estimativas apontam para produÃ§Ã£o recorde de 158 milhÃµes de toneladas',\n    content:\n      'A safra de soja 2024/25 no Brasil deve crescer 5% em relaÃ§Ã£o Ã  temporada anterior, atingindo 158 milhÃµes de toneladas, segundo estimativas da Companhia Nacional de Abastecimento (Conab). O aumento Ã© impulsionado pela expansÃ£o da Ã¡rea plantada e melhores condiÃ§Ãµes climÃ¡ticas.',\n    category: 'grains',\n    image: 'https://images.unsplash.com/photo-1574323347407-f5e1ad6d020b?w=800&h=600&fit=crop',\n    source: 'AgroNews',\n    publishedAt: '2024-01-15T10:00:00Z',\n    isActive: true,\n    tags: ['soja', 'safra', 'conab', 'produÃ§Ã£o']\n  },\n  {\n    id: 2,\n    title: 'Tecnologia de irrigaÃ§Ã£o inteligente reduz consumo de Ã¡gua em 30%',\n    summary: 'Sistema automatizado monitora umidade do solo e otimiza uso de recursos hÃ­dricos',\n    content:\n      'Novas tecnologias de irrigaÃ§Ã£o inteligente estÃ£o revolucionando a agricultura brasileira, permitindo reduÃ§Ã£o de atÃ© 30% no consumo de Ã¡gua. Sensores IoT monitoram a umidade do solo em tempo real, ajustando automaticamente a irrigaÃ§Ã£o conforme as necessidades das plantas.',\n    category: 'technology',\n    image: 'https://images.unsplash.com/photo-1565299624946-b28f40a0ca4b?w=800&h=600&fit=crop',\n    source: 'TechAgro',\n    publishedAt: '2024-01-14T14:30:00Z',\n    isActive: true,\n    tags: ['irrigaÃ§Ã£o', 'tecnologia', 'IoT', 'sustentabilidade']\n  },\n  {\n    id: 3,\n    title: 'ExportaÃ§Ãµes de carne bovina batem recorde em dezembro',\n    summary: 'Volume exportado supera 200 mil toneladas, maior marca para o mÃªs',\n    content:\n      'As exportaÃ§Ãµes brasileiras de carne bovina em dezembro de 2023 atingiram 203 mil toneladas, representando um crescimento de 12% em relaÃ§Ã£o ao mesmo perÃ­odo do ano anterior. A China continua sendo o principal destino, seguida pelos Estados Unidos e UniÃ£o Europeia.',\n    category: 'livestock',\n    image: 'https://images.unsplash.com/photo-1544025162-d76694265947?w=800&h=600&fit=crop',\n    source: 'AgroBusiness',\n    publishedAt: '2024-01-13T16:45:00Z',\n    isActive: true,\n    tags: ['carne bovina', 'exportaÃ§Ã£o', 'china', 'mercado']\n  },\n  {\n    id: 4,\n    title: 'Fertilizantes orgÃ¢nicos ganham espaÃ§o no mercado brasileiro',\n    summary: 'Produtores buscam alternativas sustentÃ¡veis aos fertilizantes quÃ­micos',\n    content:\n      'O mercado de fertilizantes orgÃ¢nicos no Brasil estÃ¡ em expansÃ£o, impulsionado pela busca por prÃ¡ticas agrÃ­colas mais sustentÃ¡veis. Produtores estÃ£o investindo em compostagem, biofertilizantes e outras alternativas naturais para reduzir dependÃªncia de insumos quÃ­micos.',\n    category: 'fertilizers',\n    image: 'https://images.unsplash.com/photo-1574323347407-f5e1ad6d020b?w=800&h=600&fit=crop',\n    source: 'SustentAgro',\n    publishedAt: '2024-01-12T09:15:00Z',\n    isActive: true,\n    tags: ['fertilizantes orgÃ¢nicos', 'sustentabilidade', 'agricultura orgÃ¢nica']\n  },\n  {\n    id: 5,\n    title: 'PreÃ§os do milho se estabilizam apÃ³s perÃ­odo de alta',\n    summary: 'Oferta adequada e demanda estÃ¡vel levam Ã  estabilizaÃ§Ã£o dos preÃ§os',\n    content:\n      'Os preÃ§os do milho no mercado brasileiro se estabilizaram apÃ³s um perÃ­odo de alta significativa. A oferta adequada do grÃ£o e a demanda estÃ¡vel por parte dos produtores de raÃ§Ã£o animal contribuÃ­ram para a estabilizaÃ§Ã£o dos preÃ§os nas principais praÃ§as do paÃ­s.',\n    category: 'grains',\n    image: 'https://images.unsplash.com/photo-1574323347407-f5e1ad6d020b?w=800&h=600&fit=crop',\n    source: 'MercadoAgro',\n    publishedAt: '2024-01-11T11:20:00Z',\n    isActive: true,\n    tags: ['milho', 'preÃ§os', 'mercado', 'oferta']\n  }\n];\n\n// GET /api/v1/news - Get latest news\nrouter.get('/', (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 10,\n      category,\n      search,\n      sortBy = 'publishedAt',\n      sortOrder = 'desc'\n    } = req.query;\n\n    let filteredNews = [...mockNews];\n\n    // Filter by category\n    if (category) {\n      filteredNews = filteredNews.filter(news => news.category === category && news.isActive);\n    }\n\n    // Filter by search term\n    if (search) {\n      const searchRegex = new RegExp(search, 'i');\n      filteredNews = filteredNews.filter(\n        news =>\n          news.isActive &&\n          (searchRegex.test(news.title) ||\n            searchRegex.test(news.summary) ||\n            searchRegex.test(news.content) ||\n            news.tags.some(tag => searchRegex.test(tag)))\n      );\n    }\n\n    // Sort news\n    filteredNews.sort((a, b) => {\n      let aValue = a[sortBy];\n      let bValue = b[sortBy];\n\n      if (sortBy === 'publishedAt') {\n        aValue = new Date(aValue);\n        bValue = new Date(bValue);\n      }\n\n      if (sortOrder === 'desc') {\n        return bValue > aValue ? 1 : -1;\n      } else {\n        return aValue > bValue ? 1 : -1;\n      }\n    });\n\n    // Pagination\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n    const paginatedNews = filteredNews.slice(skip, skip + parseInt(limit, 10, 10));\n\n    // Calculate pagination info\n    const total = filteredNews.length;\n    const totalPages = Math.ceil(total / parseInt(limit, 10, 10));\n\n    res.json({\n      success: true,\n      data: {\n        news: paginatedNews,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages,\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10),\n          hasNextPage: parseInt(page, 10, 10) < totalPages,\n          hasPrevPage: parseInt(page, 10, 10) > 1\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Get news error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter notÃ­cias'\n    });\n  }\n});\n\n// GET /api/v1/news/categories - Get news categories\nrouter.get('/categories', (req, res) => {\n  try {\n    const categories = [\n      {\n        id: 'grains',\n        name: 'GrÃ£os',\n        count: mockNews.filter(n => n.category === 'grains' && n.isActive).length\n      },\n      {\n        id: 'technology',\n        name: 'Tecnologia',\n        count: mockNews.filter(n => n.category === 'technology' && n.isActive).length\n      },\n      {\n        id: 'livestock',\n        name: 'PecuÃ¡ria',\n        count: mockNews.filter(n => n.category === 'livestock' && n.isActive).length\n      },\n      {\n        id: 'fertilizers',\n        name: 'Fertilizantes',\n        count: mockNews.filter(n => n.category === 'fertilizers' && n.isActive).length\n      },\n      {\n        id: 'machinery',\n        name: 'MaquinÃ¡rio',\n        count: mockNews.filter(n => n.category === 'machinery' && n.isActive).length\n      },\n      {\n        id: 'market',\n        name: 'Mercado',\n        count: mockNews.filter(n => n.category === 'market' && n.isActive).length\n      }\n    ];\n\n    res.json({\n      success: true,\n      data: {\n        categories,\n        totalCategories: categories.length\n      }\n    });\n  } catch (error) {\n    logger.error('Get categories error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter categorias'\n    });\n  }\n});\n\n// GET /api/v1/news/:id - Get news article by ID\nrouter.get('/:id', (req, res) => {\n  try {\n    const { id } = req.params;\n    const news = mockNews.find(n => n.id === parseInt(id, 10, 10) && n.isActive);\n\n    if (!news) {\n      return res.status(404).json({\n        success: false,\n        message: 'NotÃ­cia nÃ£o encontrada'\n      });\n    }\n\n    // Get related news (same category, excluding current)\n    const relatedNews = mockNews\n      .filter(n => n.id !== parseInt(id, 10, 10) && n.category === news.category && n.isActive)\n      .slice(0, 3);\n\n    res.json({\n      success: true,\n      data: {\n        news,\n        relatedNews\n      }\n    });\n  } catch (error) {\n    logger.error('Get news by ID error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter notÃ­cia'\n    });\n  }\n});\n\n// GET /api/v1/news/rss/agribusiness - Get agribusiness RSS feed\nrouter.get('/rss/agribusiness', (req, res) => {\n  try {\n    // Filter agribusiness related news\n    const agribusinessNews = mockNews\n      .filter(\n        news =>\n          news.isActive &&\n          (news.category === 'grains' ||\n            news.category === 'livestock' ||\n            news.category === 'fertilizers' ||\n            news.category === 'machinery')\n      )\n      .slice(0, 10);\n\n    // Create RSS feed\n    const items = agribusinessNews\n      .map(\n        n => `\n    <item>\n      <title><![CDATA[${n.title}]]></title>\n      <link>https://agrotm.com.br/news/${n.id}</link>\n      <description><![CDATA[${n.summary}]]></description>\n      <category>${n.category}</category>\n      <pubDate>${new Date(n.publishedAt).toUTCString()}</pubDate>\n      <guid>https://agrotm.com.br/news/${n.id}</guid>\n    </item>`\n      )\n      .join('');\n\n    const rssFeed = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\">\\n  <channel>\\n    <title>AGROTM - Notícias do Agronegócio</title>\\n    <link>https://agrotm.com.br/news</link>\\n    <description>Últimas notícias e atualizações do setor agrícola brasileiro</description>\\n    <language>pt-BR</language>\\n    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>\\n    <atom:link href=\"https://agrotm.com.br/api/v1/news/rss/agribusiness\" rel=\"self\" type=\"application/rss+xml\" />\\n${items}\\n  </channel>\\n</rss>`;\n\n    res.set('Content-Type', 'application/xml');\n    res.send(rssFeed);\n  } catch (error) {\n    logger.error('RSS feed error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao gerar feed RSS'\n    });\n  }\n});\n\n// GET /api/v1/news/featured - Get featured news\nrouter.get('/featured', (req, res) => {\n  try {\n    const featuredNews = mockNews\n      .filter(news => news.isActive)\n      .sort((a, b) => new Date(b.publishedAt) - new Date(a.publishedAt))\n      .slice(0, 5);\n\n    res.json({\n      success: true,\n      data: {\n        featuredNews,\n        totalFeatured: featuredNews.length\n      }\n    });\n  } catch (error) {\n    logger.error('Get featured news error:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter notÃ­cias em destaque'\n    });\n  }\n});\n\n// ConfiguraÃ§Ãµes\nconst RSS_URLS = {\n  'globo-rural': 'https://g1.globo.com/rss/g1/economia/agronegocios/',\n  agrolink: 'https://www.agrolink.com.br/rss/noticias',\n  'canal-rural': 'https://www.canalrural.com.br/rss/noticias'\n};\n\n// GET /api/news/globo-rural - Obter notÃ­cias do Globo Rural\nrouter.get(\n  '/globo-rural',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const rssUrl = RSS_URLS['globo-rural'];\n\n      // Fazer requisiÃ§Ã£o para o RSS\n      const response = await axios.get(rssUrl, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'AgroSync-News/1.0'\n        }\n      });\n\n      // Parsear o XML RSS (simplificado)\n      const rssData = parseRSSXML(response.data);\n\n      res.json({\n        success: true,\n        source: 'Globo Rural',\n        lastUpdated: new Date().toISOString(),\n        items: rssData.items || []\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias do Globo Rural:', error);\n      // Retornar dados de fallback\n      res.json({\n        success: true,\n        source: 'Globo Rural (Fallback)',\n        lastUpdated: new Date().toISOString(),\n        items: getFallbackNews()\n      });\n    }\n  }\n);\n\n// GET /api/news/agrolink - Obter notÃ­cias do Agrolink\nrouter.get(\n  '/agrolink',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const rssUrl = RSS_URLS['agrolink'];\n\n      const response = await axios.get(rssUrl, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'AgroSync-News/1.0'\n        }\n      });\n\n      const rssData = parseRSSXML(response.data);\n\n      res.json({\n        success: true,\n        source: 'Agrolink',\n        lastUpdated: new Date().toISOString(),\n        items: rssData.items || []\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias do Agrolink:', error);\n      res.json({\n        success: true,\n        source: 'Agrolink (Fallback)',\n        lastUpdated: new Date().toISOString(),\n        items: getFallbackNews()\n      });\n    }\n  }\n);\n\n// GET /api/news/canal-rural - Obter notÃ­cias do Canal Rural\nrouter.get(\n  '/canal-rural',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const rssUrl = RSS_URLS['canal-rural'];\n\n      const response = await axios.get(rssUrl, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'AgroSync-News/1.0'\n        }\n      });\n\n      const rssData = parseRSSXML(response.data);\n\n      res.json({\n        success: true,\n        source: 'Canal Rural',\n        lastUpdated: new Date().toISOString(),\n        items: rssData.items || []\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias do Canal Rural:', error);\n      res.json({\n        success: true,\n        source: 'Canal Rural (Fallback)',\n        lastUpdated: new Date().toISOString(),\n        items: getFallbackNews()\n      });\n    }\n  }\n);\n\n// GET /api/news/all - Obter notÃ­cias de todas as fontes\nrouter.get(\n  '/all',\n  apiLimiter, // Use the existing apiLimiter\n  async (req, res) => {\n    try {\n      const limit = parseInt(req.query.limit, 10, 10) || 20;\n      const sources = Object.keys(RSS_URLS);\n      const allNews = [];\n\n      // Obter notÃ­cias de todas as fontes\n      for (const source of sources) {\n        try {\n          const response = await axios.get(RSS_URLS[source], {\n            timeout: 5000,\n            headers: {\n              'User-Agent': 'AgroSync-News/1.0'\n            }\n          });\n\n          const rssData = parseRSSXML(response.data);\n          if (rssData.items && rssData.items.length > 0) {\n            allNews.push(...rssData.items.slice(0, Math.ceil(limit / sources.length)));\n          }\n        } catch (error) {\n          logger.warn(`Erro ao obter notícias de ${source}:`, error.message);\n        }\n      }\n\n      // Ordenar por data e limitar\n      const sortedNews = allNews\n        .sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate))\n        .slice(0, limit);\n\n      res.json({\n        success: true,\n        sources,\n        lastUpdated: new Date().toISOString(),\n        totalItems: sortedNews.length,\n        items: sortedNews\n      });\n    } catch (error) {\n      logger.error('Erro ao obter notícias de todas as fontes:', error);\n      res.json({\n        success: true,\n        sources: ['Fallback'],\n        lastUpdated: new Date().toISOString(),\n        totalItems: 10,\n        items: getFallbackNews(10)\n      });\n    }\n  }\n);\n\n// FunÃ§Ã£o para parsear XML RSS (simplificada)\nfunction parseRSSXML(xmlString) {\n  try {\n    // Parse bÃ¡sico do XML RSS\n    const items = [];\n\n    // Extrair itens do RSS\n    const itemRegex = /<item>([\\s\\S]*?)<\\/item>/g;\n    let match;\n\n    while ((match = itemRegex.exec(xmlString)) !== null) {\n      const itemContent = match[1];\n\n      const title = extractTag(itemContent, 'title');\n      const description = extractTag(itemContent, 'description');\n      const link = extractTag(itemContent, 'link');\n      const pubDate = extractTag(itemContent, 'pubDate');\n      const guid = extractTag(itemContent, 'guid');\n\n      if (title && link) {\n        items.push({\n          title: decodeXMLEntities(title),\n          description: decodeXMLEntities(description || ''),\n          link: decodeXMLEntities(link),\n          pubDate: pubDate || new Date().toISOString(),\n          guid: guid || link\n        });\n      }\n    }\n\n    return { items };\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao parsear XML RSS:', error);\n    }\n    return { items: [] };\n  }\n}\n\n// FunÃ§Ã£o para extrair conteÃºdo de tags XML\nfunction extractTag(content, tagName) {\n  const regex = new RegExp(`<${tagName}[^>]*>([\\\\s\\\\S]*?)<\\\\/${tagName}>`, 'i');\n  const match = content.match(regex);\n  return match ? match[1].trim() : null;\n}\n\n// FunÃ§Ã£o para decodificar entidades XML\nfunction decodeXMLEntities(text) {\n  if (!text) {\n    return '';\n  }\n\n  return text\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&nbsp;/g, ' ');\n}\n\n// FunÃ§Ã£o para gerar notÃ­cias de fallback\nfunction getFallbackNews(limit = 10) {\n  const fallbackNews = [\n    {\n      title: 'Mercado agrÃ­cola em alta com forte demanda internacional',\n      description:\n        'Commodities agrÃ­colas brasileiras registram alta expressiva com forte demanda de paÃ­ses asiÃ¡ticos.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date().toISOString(),\n      guid: 'fallback-1'\n    },\n    {\n      title: 'Tecnologia revoluciona agricultura brasileira',\n      description:\n        'Novas tecnologias como drones e IoT aumentam produtividade no campo brasileiro.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-2'\n    },\n    {\n      title: 'Clima favorÃ¡vel para safra de grÃ£os 2024',\n      description:\n        'PrevisÃµes climÃ¡ticas indicam condiÃ§Ãµes favorÃ¡veis para a prÃ³xima safra de grÃ£os.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-3'\n    },\n    {\n      title: 'ExportaÃ§Ã£o de carne bovina atinge recorde',\n      description:\n        'Setor de carne bovina brasileiro registra recorde de exportaÃ§Ãµes para mercados internacionais.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-4'\n    },\n    {\n      title: 'Investimentos em agricultura sustentÃ¡vel crescem',\n      description:\n        'Produtores rurais investem cada vez mais em prÃ¡ticas sustentÃ¡veis e certificaÃ§Ãµes ambientais.',\n      link: 'https://g1.globo.com/economia/agronegocios/',\n      pubDate: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000).toISOString(),\n      guid: 'fallback-5'\n    }\n  ];\n\n  return fallbackNews.slice(0, limit);\n}\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\nfts.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\notifications.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'skip' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 332,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 332,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport notificationService from '../services/notificationService.js';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\n\n// Aplicar rate limiting\nrouter.use(apiLimiter);\n\n// Aplicar autenticaÃ§Ã£o em todas as rotas\nrouter.use(authenticateToken);\n\n// ===== ROTAS DE NOTIFICAÃ‡Ã•ES =====\n\n// GET /api/notifications - Listar notificaÃ§Ãµes do usuÃ¡rio\nrouter.get('/', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, read, archived = false, type, category } = req.query;\n\n    const result = await notificationService.getUserNotifications(req.user.userId, {\n      page: parseInt(page, 10, 10),\n      limit: parseInt(limit, 10, 10),\n      read: read === 'true' ? true : read === 'false' ? false : null,\n      archived: archived === 'true',\n      type,\n      category\n    });\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao buscar notificaÃ§Ãµes:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/unread - Contar notificaÃ§Ãµes nÃ£o lidas\nrouter.get('/unread/count', async (req, res) => {\n  try {\n    const result = await notificationService.getUserNotifications(req.user.userId, {\n      read: false,\n      archived: false,\n      limit: 1\n    });\n\n    if (result.success) {\n      res.json({\n        success: true,\n        count: result.data.pagination.total\n      });\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao contar notificaÃ§Ãµes nÃ£o lidas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/:id - Obter notificaÃ§Ã£o especÃ­fica\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    // Buscar notificaÃ§Ã£o especÃ­fica do usuÃ¡rio\n    const result = await notificationService.getUserNotifications(userId, {\n      limit: 1000 // Buscar todas para encontrar a especÃ­fica\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    const notification = result.data.notifications.find(n => n._id.toString() === id);\n\n    if (!notification) {\n      return res.status(404).json({\n        success: false,\n        message: 'NotificaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: notification\n    });\n  } catch (error) {\n    logger.error('Erro ao buscar notificaÃ§Ã£o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/notifications/:id/read - Marcar como lida\nrouter.patch('/:id/read', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const result = await notificationService.markAsRead(id, userId);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao marcar como lida:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/notifications/:id/archive - Arquivar notificaÃ§Ã£o\nrouter.patch('/:id/archive', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const result = await notificationService.archiveNotification(id, userId);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    logger.error('Erro ao arquivar notificaÃ§Ã£o:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /api/notifications/read-all - Marcar todas como lidas\nrouter.patch('/read-all', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar todas as notificaÃ§Ãµes nÃ£o lidas\n    const result = await notificationService.getUserNotifications(userId, {\n      read: false,\n      archived: false,\n      limit: 1000\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    // Marcar todas como lidas\n    const { notifications } = result.data;\n    const updatePromises = notifications.map(notification => notification.markAsRead());\n\n    await Promise.all(updatePromises);\n\n    res.json({\n      success: true,\n      message: `${notifications.length} notificaÃ§Ãµes marcadas como lidas`,\n      count: notifications.length\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao marcar todas como lidas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/notifications/:id - Deletar notificaÃ§Ã£o\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    // Buscar notificaÃ§Ã£o\n    const result = await notificationService.getUserNotifications(userId, {\n      limit: 1000\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    const notification = result.data.notifications.find(n => n._id.toString() === id);\n\n    if (!notification) {\n      return res.status(404).json({\n        success: false,\n        message: 'NotificaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Deletar notificaÃ§Ã£o\n    await notification.deleteOne();\n\n    res.json({\n      success: true,\n      message: 'NotificaÃ§Ã£o deletada com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao deletar notificaÃ§Ã£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/notifications/clear-read - Limpar notificaÃ§Ãµes lidas\nrouter.delete('/clear-read', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Buscar todas as notificaÃ§Ãµes lidas\n    const result = await notificationService.getUserNotifications(userId, {\n      read: true,\n      archived: false,\n      limit: 1000\n    });\n\n    if (!result.success) {\n      return res.status(400).json(result);\n    }\n\n    // Deletar todas as lidas\n    const { notifications } = result.data;\n    const deletePromises = notifications.map(notification => notification.deleteOne());\n\n    await Promise.all(deletePromises);\n\n    res.json({\n      success: true,\n      message: `${notifications.length} notificaÃ§Ãµes lidas removidas`,\n      count: notifications.length\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao limpar notificaÃ§Ãµes lidas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/stats - EstatÃ­sticas das notificaÃ§Ãµes\nrouter.get('/stats/overview', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const result = await notificationService.getNotificationStats(userId);\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS ADMIN (APENAS PARA ADMINISTRADORES) =====\n\n// Middleware para verificar se Ã© admin\nconst adminAuth = (req, res, next) => {\n  if (!req.user.isAdmin) {\n    return res.status(403).json({\n      success: false,\n      message: 'Acesso negado. Apenas administradores.'\n    });\n  }\n  next();\n};\n\n// GET /api/notifications/admin/all - Listar todas as notificaÃ§Ãµes (admin)\nrouter.get('/admin/all', adminAuth, async (req, res) => {\n  try {\n    const { page = 1, limit = 50, userId, type, category, status } = req.query;\n\n    // Construir query\n    const query = {};\n    if (userId) {\n      query.userId = userId;\n    }\n    if (type) {\n      query.type = type;\n    }\n    if (category) {\n      query.category = category;\n    }\n    if (status) {\n      if (status === 'read') {\n        query.read = true;\n      } else if (status === 'unread') {\n        query.read = false;\n      } else if (status === 'archived') {\n        query.archived = true;\n      }\n    }\n\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    // Buscar notificaÃ§Ãµes\n    const notifications = await notificationService.getUserNotifications(null, {\n      limit: 1000\n    });\n\n    if (!notifications.success) {\n      return res.status(400).json(notifications);\n    }\n\n    const { total } = notifications.data.pagination;\n\n    res.json({\n      success: true,\n      data: {\n        notifications,\n        pagination: {\n          page: parseInt(page, 10, 10),\n          limit: parseInt(limit, 10, 10),\n          total,\n          pages: Math.ceil(total / parseInt(limit, 10, 10))\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar todas as notificaÃ§Ãµes:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/notifications/admin/send - Enviar notificaÃ§Ã£o manual (admin)\nrouter.post('/admin/send', adminAuth, async (req, res) => {\n  try {\n    const { userId, type, title, body, channels, priority, category, data, metadata } = req.body;\n\n    if (!userId || !type || !title || !body) {\n      return res.status(400).json({\n        success: false,\n        message: 'userId, type, title e body sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    const result = await notificationService.createAndSendNotification({\n      userId,\n      type,\n      title,\n      body,\n      channels,\n      priority,\n      category,\n      data,\n      metadata\n    });\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao enviar notificaÃ§Ã£o manual:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/notifications/admin/stats - EstatÃ­sticas gerais (admin)\nrouter.get('/admin/stats', adminAuth, async (req, res) => {\n  try {\n    const result = await notificationService.getNotificationStats();\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter estatÃ­sticas gerais:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/notifications/admin/cleanup - Limpeza manual (admin)\nrouter.post('/admin/cleanup', adminAuth, async (req, res) => {\n  try {\n    const result = await notificationService.cleanupExpiredNotifications();\n\n    if (result.success) {\n      res.json(result);\n    } else {\n      res.status(400).json(result);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao fazer limpeza manual:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\partners.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\partnership-messages.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport mongoose from 'mongoose';\nimport PartnershipMessage from '../models/PartnershipMessage.js';\nimport Partner from '../models/Partner.js';\nimport User from '../models/User.js';\nimport { authenticateToken, requireAdmin } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { createSecurityLog } from '../utils/securityLogger.js';\nimport { sanitizeInput } from '../utils/sanitizer.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// ===== MIDDLEWARE DE VALIDAÃ‡ÃƒO =====\n\n// ValidaÃ§Ã£o para mensagens de parceiros\nconst validatePartnershipMessage = (req, res, next) => {\n  const { partnerId, subject, content, messageType, category, priority } = req.body;\n\n  if (!partnerId || !subject || !content) {\n    return res.status(400).json({\n      success: false,\n      message: 'ID do parceiro, assunto e conteÃºdo sÃ£o obrigatÃ³rios'\n    });\n  }\n\n  if (!mongoose.Types.ObjectId.isValid(partnerId)) {\n    return res.status(400).json({\n      success: false,\n      message: 'ID do parceiro invÃ¡lido'\n    });\n  }\n\n  if (subject.trim().length < 5 || subject.trim().length > 200) {\n    return res.status(400).json({\n      success: false,\n      message: 'Assunto deve ter entre 5 e 200 caracteres'\n    });\n  }\n\n  if (content.trim().length < 10 || content.trim().length > 5000) {\n    return res.status(400).json({\n      success: false,\n      message: 'ConteÃºdo deve ter entre 10 e 5000 caracteres'\n    });\n  }\n\n  // Validar tipo de mensagem\n  const validMessageTypes = [\n    'partnership_request',\n    'business_proposal',\n    'collaboration',\n    'support',\n    'general',\n    'urgent'\n  ];\n  if (messageType && !validMessageTypes.includes(messageType)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Tipo de mensagem invÃ¡lido'\n    });\n  }\n\n  // Validar categoria\n  const validCategories = [\n    'agriculture',\n    'technology',\n    'finance',\n    'logistics',\n    'marketing',\n    'research',\n    'other'\n  ];\n  if (category && !validCategories.includes(category)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Categoria invÃ¡lida'\n    });\n  }\n\n  // Validar prioridade\n  const validPriorities = ['low', 'normal', 'high', 'urgent'];\n  if (priority && !validPriorities.includes(priority)) {\n    return res.status(400).json({\n      success: false,\n      message: 'Prioridade invÃ¡lida'\n    });\n  }\n\n  next();\n};\n\n// ===== ROTAS DE MENSAGENS DE PARCEIROS =====\n\n// GET /api/partnership-messages - Listar mensagens de parceiros (admin apenas)\nrouter.get('/', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const { page = 1, limit = 20, status, priority, category, partnerId, assignedTo } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = {};\n\n    // Filtros\n    if (status) {\n      query.status = status;\n    }\n    if (priority) {\n      query.priority = priority;\n    }\n    if (category) {\n      query.category = category;\n    }\n    if (partnerId) {\n      query.partnerId = partnerId;\n    }\n    if (assignedTo) {\n      query.assignedTo = assignedTo;\n    }\n\n    const messages = await PartnershipMessage.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .populate('partnerId', 'name company category')\n      .populate('assignedTo', 'name email')\n      .populate('readBy', 'name email')\n      .populate('repliedBy', 'name email');\n\n    const total = await PartnershipMessage.countDocuments(query);\n\n    // Log de acesso\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin accessed partnership messages',\n      req,\n      req.user.userId\n    );\n\n    res.json({\n      success: true,\n      data: {\n        messages,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership messages:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching partnership messages: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/partnership-messages - Criar nova mensagem de parceiro\nrouter.post('/', authenticateToken, requireAdmin, validatePartnershipMessage, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const { partnerId, subject, content, messageType, category, priority, tags, assignedTo } =\n      req.body;\n\n    // Verificar se o parceiro existe\n    const partner = await Partner.findById(partnerId);\n    if (!partner) {\n      return res.status(404).json({\n        success: false,\n        message: 'Parceiro nÃ£o encontrado'\n      });\n    }\n\n    // Criar mensagem\n    const message = new PartnershipMessage({\n      partnerId,\n      subject: sanitizeInput(subject.trim()),\n      content: sanitizeInput(content.trim()),\n      messageType: messageType || 'general',\n      category: category || 'other',\n      priority: priority || 'normal',\n      tags: tags || [],\n      assignedTo: assignedTo || adminId\n    });\n\n    await message.save();\n\n    // Populate informaÃ§Ãµes\n    await message.populate([\n      { path: 'partnerId', select: 'name company category' },\n      { path: 'assignedTo', select: 'name email' }\n    ]);\n\n    // Log de criaÃ§Ã£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      'Admin created partnership message',\n      req,\n      adminId,\n      {\n        partnerId,\n        messageId: message._id,\n        messageType\n      }\n    );\n\n    res.status(201).json({\n      success: true,\n      message: 'Mensagem de parceiro criada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error creating partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/partnership-messages/:id - Obter mensagem especÃ­fica\nrouter.get('/:id', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const messageId = req.params.id;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId)\n      .populate('partnerId', 'name company category contact')\n      .populate('assignedTo', 'name email')\n      .populate('readBy', 'name email')\n      .populate('repliedBy', 'name email')\n      .populate('flaggedBy', 'name email');\n\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Log de acesso\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin accessed specific partnership message',\n      req,\n      req.user.userId,\n      {\n        messageId\n      }\n    );\n\n    res.json({\n      success: true,\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/partnership-messages/:id - Atualizar mensagem\nrouter.put('/:id', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const messageId = req.params.id;\n    const { subject, content, messageType, category, priority, tags, adminNotes, assignedTo } =\n      req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Atualizar campos permitidos\n    if (subject) {\n      message.subject = sanitizeInput(subject.trim());\n    }\n    if (content) {\n      message.content = sanitizeInput(content.trim());\n    }\n    if (messageType) {\n      message.messageType = messageType;\n    }\n    if (category) {\n      message.category = category;\n    }\n    if (priority) {\n      message.priority = priority;\n    }\n    if (tags) {\n      message.tags = tags;\n    }\n    if (adminNotes) {\n      message.adminNotes = sanitizeInput(adminNotes.trim());\n    }\n    if (assignedTo) {\n      message.assignedTo = assignedTo;\n    }\n\n    await message.save();\n\n    // Log de atualizaÃ§Ã£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      'Admin updated partnership message',\n      req,\n      adminId,\n      {\n        messageId,\n        updatedFields: Object.keys(req.body)\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'Mensagem atualizada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error updating partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/partnership-messages/:id/status - Atualizar status da mensagem\nrouter.put('/:id/status', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const messageId = req.params.id;\n    const { status, action } = req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Executar aÃ§Ã£o baseada no status\n    switch (action) {\n      case 'mark_read':\n        await message.markAsRead(adminId);\n        break;\n      case 'mark_in_progress':\n        await message.markInProgress(adminId);\n        break;\n      case 'reply':\n        if (!req.body.replyContent) {\n          return res.status(400).json({\n            success: false,\n            message: 'ConteÃºdo da resposta Ã© obrigatÃ³rio'\n          });\n        }\n        await message.reply(req.body.replyContent, adminId);\n        break;\n      case 'close':\n        await message.close(adminId);\n        break;\n      case 'archive':\n        await message.archive(adminId);\n        break;\n      case 'flag':\n        if (!req.body.flagReason) {\n          return res.status(400).json({\n            success: false,\n            message: 'Motivo da sinalizaÃ§Ã£o Ã© obrigatÃ³rio'\n          });\n        }\n        await message.flag(req.body.flagReason, adminId);\n        break;\n      case 'unflag':\n        await message.unflag();\n        break;\n      default:\n        if (status) {\n          message.status = status;\n          await message.save();\n        }\n    }\n\n    // Log de aÃ§Ã£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      `Admin performed action on partnership message: ${action}`,\n      req,\n      adminId,\n      {\n        messageId,\n        action,\n        newStatus: message.status\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'AÃ§Ã£o executada com sucesso',\n      data: { message }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error updating partnership message status:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error updating partnership message status: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/partnership-messages/:id - Excluir mensagem\nrouter.delete('/:id', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const adminId = req.user.userId;\n    const messageId = req.params.id;\n\n    if (!mongoose.Types.ObjectId.isValid(messageId)) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID da mensagem invÃ¡lido'\n      });\n    }\n\n    const message = await PartnershipMessage.findById(messageId);\n    if (!message) {\n      return res.status(404).json({\n        success: false,\n        message: 'Mensagem nÃ£o encontrada'\n      });\n    }\n\n    // Soft delete - marcar como arquivada\n    message.status = 'archived';\n    message.assignedTo = adminId;\n    message.assignedAt = new Date();\n    await message.save();\n\n    // Log de exclusÃ£o\n    await createSecurityLog(\n      'admin_action',\n      'medium',\n      'Admin archived partnership message',\n      req,\n      adminId,\n      {\n        messageId\n      }\n    );\n\n    res.json({\n      success: true,\n      message: 'Mensagem arquivada com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error archiving partnership message:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error archiving partnership message: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/partnership-messages/stats - EstatÃ­sticas das mensagens\nrouter.get('/stats/overview', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const stats = await PartnershipMessage.getMessageStats();\n\n    // Contar mensagens por prioridade\n    const priorityStats = await PartnershipMessage.aggregate([\n      {\n        $group: {\n          _id: '$priority',\n          count: { $sum: 1 }\n        }\n      }\n    ]);\n\n    // Contar mensagens por categoria\n    const categoryStats = await PartnershipMessage.aggregate([\n      {\n        $group: {\n          _id: '$category',\n          count: { $sum: 1 }\n        }\n      }\n    ]);\n\n    // Contar mensagens nÃ£o lidas\n    const unreadCount = await PartnershipMessage.countDocuments({\n      isRead: false,\n      status: { $nin: ['closed', 'archived'] }\n    });\n\n    // Log de acesso Ã s estatÃ­sticas\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin accessed partnership messages statistics',\n      req,\n      req.user.userId\n    );\n\n    res.json({\n      success: true,\n      data: {\n        statusStats: stats,\n        priorityStats: priorityStats.reduce((acc, stat) => {\n          acc[stat._id] = stat.count;\n          return acc;\n        }, {}),\n        categoryStats: categoryStats.reduce((acc, stat) => {\n          acc[stat._id] = stat.count;\n          return acc;\n        }, {}),\n        unreadCount\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching partnership messages stats:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error fetching partnership messages stats: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/partnership-messages/search/:term - Buscar mensagens\nrouter.get('/search/:term', authenticateToken, requireAdmin, async (req, res) => {\n  try {\n    const searchTerm = req.params.term;\n    const { page = 1, limit = 20 } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    if (!searchTerm || searchTerm.trim().length < 2) {\n      return res.status(400).json({\n        success: false,\n        message: 'Termo de busca deve ter pelo menos 2 caracteres'\n      });\n    }\n\n    const messages = await PartnershipMessage.searchMessages(\n      searchTerm.trim(),\n      parseInt(limit, 10, 10)\n    );\n    const total = messages.length;\n\n    // Log de busca\n    await createSecurityLog(\n      'admin_action',\n      'low',\n      'Admin searched partnership messages',\n      req,\n      req.user.userId,\n      {\n        searchTerm\n      }\n    );\n\n    res.json({\n      success: true,\n      data: {\n        messages: messages.slice(skip, skip + parseInt(limit, 10, 10)),\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error searching partnership messages:', error);\n    }\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Error searching partnership messages: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\payment-verification.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'apiRateLimiter' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 3,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiRateLimiter } from '../middleware/rateLimiter.js';\nimport AuditLog from '../models/AuditLog.js';\nimport User from '../models/User.js';\nimport Payment from '../models/Payment.js';\nimport stripe from 'stripe';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Inicializar Stripe\nconst stripeClient = new stripe(process.env.STRIPE_SECRET_KEY);\n\n// ===== VERIFICAÃ‡ÃƒO DE PAGAMENTO =====\n\n// GET /api/payment-verification/status - Verificar status do pagamento do usuÃ¡rio\nrouter.get('/status', authenticateToken, async (req, res) => {\n  try {\n    const userId = req.user.id;\n\n    // Buscar usuÃ¡rio\n    const user = await User.findById(userId);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Verificar planos ativos\n    const hasActivePlan =\n      user.subscriptions &&\n      ((user.subscriptions.store && user.subscriptions.store.status === 'active') ||\n        (user.subscriptions.agroconecta && user.subscriptions.agroconecta.status === 'active'));\n\n    // Verificar pagamentos recentes (Ãºltimos 30 dias)\n    const thirtyDaysAgo = new Date();\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n    const recentPayments = await Payment.find({\n      userId,\n      status: 'completed',\n      createdAt: { $gte: thirtyDaysAgo }\n    }).sort({ createdAt: -1 });\n\n    // Verificar pagamentos pendentes\n    const pendingPayments = await Payment.find({\n      userId,\n      status: { $in: ['pending', 'processing'] }\n    }).sort({ createdAt: -1 });\n\n    // Status geral\n    const paymentStatus = {\n      hasActivePlan,\n      hasRecentPayment: recentPayments.length > 0,\n      hasPendingPayment: pendingPayments.length > 0,\n      lastPayment: recentPayments[0] || null,\n      pendingPayment: pendingPayments[0] || null,\n      canAccessMessaging: hasActivePlan || recentPayments.length > 0\n    };\n\n    // Log da verificaÃ§Ã£o\n    await AuditLog.logAction({\n      userId,\n      userEmail: req.user.email,\n      action: 'PAYMENT_STATUS_CHECKED',\n      resource: 'payment_verification',\n      details: `Payment status checked. Has access: ${paymentStatus.canAccessMessaging}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      data: paymentStatus\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar status do pagamento:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'PAYMENT_STATUS_CHECK_ERROR',\n      resource: 'payment_verification',\n      details: `Error checking payment status: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'STATUS_CHECK_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/payment-verification/verify-stripe - Verificar pagamento Stripe\nrouter.post('/verify-stripe', authenticateToken, async (req, res) => {\n  try {\n    const { paymentIntentId } = req.body;\n    const userId = req.user.id;\n\n    if (!paymentIntentId) {\n      return res.status(400).json({\n        success: false,\n        message: 'ID do pagamento Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Verificar pagamento no Stripe\n    const paymentIntent = await stripeClient.paymentIntents.retrieve(paymentIntentId);\n\n    if (paymentIntent.status === 'succeeded') {\n      // Buscar ou criar registro de pagamento\n      let payment = await Payment.findOne({\n        stripePaymentIntentId: paymentIntentId\n      });\n\n      if (!payment) {\n        payment = new Payment({\n          userId,\n          amount: paymentIntent.amount / 100, // Stripe usa centavos\n          currency: paymentIntent.currency,\n          status: 'completed',\n          provider: 'stripe',\n          stripePaymentIntentId: paymentIntentId,\n          metadata: {\n            stripeCustomerId: paymentIntent.customer,\n            stripeChargeId: paymentIntent.latest_charge\n          }\n        });\n\n        await payment.save();\n      }\n\n      // Atualizar status do usuÃ¡rio se necessÃ¡rio\n      const user = await User.findById(userId);\n      if (user) {\n        // Aqui vocÃª pode implementar lÃ³gica para ativar planos especÃ­ficos\n        // baseado no valor do pagamento ou metadata\n        await user.save();\n      }\n\n      // Log do pagamento verificado\n      await AuditLog.logAction({\n        userId,\n        userEmail: req.user.email,\n        action: 'STRIPE_PAYMENT_VERIFIED',\n        resource: 'payment_verification',\n        resourceId: payment._id,\n        details: `Stripe payment verified: ${paymentIntentId}`,\n        ip: req.ip,\n        userAgent: req.get('User-Agent')\n      });\n\n      res.json({\n        success: true,\n        message: 'Pagamento verificado com sucesso',\n        data: {\n          payment,\n          canAccessMessaging: true\n        }\n      });\n    } else {\n      return res.status(400).json({\n        success: false,\n        message: 'Pagamento nÃ£o foi concluÃ­do com sucesso',\n        data: {\n          status: paymentIntent.status,\n          canAccessMessaging: false\n        }\n      });\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar pagamento Stripe:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'STRIPE_PAYMENT_VERIFICATION_ERROR',\n      resource: 'payment_verification',\n      details: `Error verifying Stripe payment: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'STRIPE_VERIFICATION_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar pagamento'\n    });\n  }\n});\n\n// POST /api/payment-verification/verify-metamask - Verificar pagamento Metamask\nrouter.post('/verify-metamask', authenticateToken, async (req, res) => {\n  try {\n    const { transactionHash, amount, currency, network } = req.body;\n    const userId = req.user.id;\n\n    if (!transactionHash || !amount || !currency || !network) {\n      return res.status(400).json({\n        success: false,\n        message: 'Todos os campos sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Verificar se jÃ¡ existe pagamento com este hash\n    let payment = await Payment.findOne({\n      metamaskTransactionHash: transactionHash\n    });\n\n    if (payment) {\n      return res.status(400).json({\n        success: false,\n        message: 'TransaÃ§Ã£o jÃ¡ foi verificada'\n      });\n    }\n\n    // Aqui vocÃª implementaria a verificaÃ§Ã£o real da transaÃ§Ã£o na blockchain\n    // Por enquanto, vamos assumir que Ã© vÃ¡lida se os dados estÃ£o corretos\n\n    // Criar registro de pagamento\n    payment = new Payment({\n      userId,\n      amount: parseFloat(amount),\n      currency,\n      status: 'completed',\n      provider: 'metamask',\n      metamaskTransactionHash: transactionHash,\n      metadata: {\n        network,\n        verifiedAt: new Date()\n      }\n    });\n\n    await payment.save();\n\n    // Atualizar status do usuÃ¡rio se necessÃ¡rio\n    const user = await User.findById(userId);\n    if (user) {\n      // Implementar lÃ³gica de ativaÃ§Ã£o de planos\n      await user.save();\n    }\n\n    // Log do pagamento verificado\n    await AuditLog.logAction({\n      userId,\n      userEmail: req.user.email,\n      action: 'METAMASK_PAYMENT_VERIFIED',\n      resource: 'payment_verification',\n      resourceId: payment._id,\n      details: `Metamask payment verified: ${transactionHash}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      message: 'Pagamento Metamask verificado com sucesso',\n      data: {\n        payment,\n        canAccessMessaging: true\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar pagamento Metamask:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'METAMASK_PAYMENT_VERIFICATION_ERROR',\n      resource: 'payment_verification',\n      details: `Error verifying Metamask payment: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'METAMASK_VERIFICATION_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao verificar pagamento Metamask'\n    });\n  }\n});\n\n// GET /api/payment-verification/plans - Obter planos disponÃ­veis\nrouter.get('/plans', authenticateToken, (req, res) => {\n  try {\n    const plans = {\n      store: {\n        id: 'store',\n        name: 'Loja',\n        price: 25.0,\n        currency: 'BRL',\n        interval: 'month',\n        features: [\n          'AtÃ© 3 anÃºncios de produtos',\n          'Mensageria privada com compradores',\n          'Dashboard de vendas',\n          'Suporte prioritÃ¡rio'\n        ],\n        messagingAccess: true\n      },\n      agroconecta: {\n        id: 'agroconecta',\n        name: 'AgroConecta',\n        price: 50.0,\n        currency: 'BRL',\n        interval: 'month',\n        features: [\n          'AtÃ© 10 anÃºncios de fretes',\n          'Mensageria privada com fretistas',\n          'Rastreamento de cargas',\n          'Suporte 24/7'\n        ],\n        messagingAccess: true\n      },\n      agroconectaPro: {\n        id: 'agroconecta-pro',\n        name: 'AgroConecta Pro',\n        price: 149.0,\n        currency: 'BRL',\n        interval: 'month',\n        features: [\n          'AtÃ© 30 anÃºncios de fretes',\n          'Mensageria privada ilimitada',\n          'Rastreamento GPS em tempo real',\n          'RelatÃ³rios avanÃ§ados',\n          'Suporte VIP'\n        ],\n        messagingAccess: true\n      }\n    };\n\n    res.json({\n      success: true,\n      data: plans\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar planos:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/payment-verification/create-stripe-session - Criar sessÃ£o de pagamento Stripe\nrouter.post('/create-stripe-session', authenticateToken, async (req, res) => {\n  try {\n    const { planId, successUrl, cancelUrl } = req.body;\n    const userId = req.user.id;\n\n    if (!planId || !successUrl || !cancelUrl) {\n      return res.status(400).json({\n        success: false,\n        message: 'Todos os campos sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Buscar usuÃ¡rio\n    const user = await User.findById(userId);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Definir preÃ§o baseado no plano\n    let price;\n    switch (planId) {\n      case 'store':\n        price = 2500; // R$25.00 em centavos\n        break;\n      case 'agroconecta':\n        price = 5000; // R$50.00 em centavos\n        break;\n      case 'agroconecta-pro':\n        price = 14900; // R$149.00 em centavos\n        break;\n      default:\n        return res.status(400).json({\n          success: false,\n          message: 'Plano invÃ¡lido'\n        });\n    }\n\n    // Criar sessÃ£o do Stripe\n    const session = await stripeClient.checkout.sessions.create({\n      customer_email: user.email,\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price_data: {\n            currency: 'brl',\n            product_data: {\n              name: `Plano ${planId}`,\n              description: `Assinatura mensal do plano ${planId}`\n            },\n            unit_amount: price\n          },\n          quantity: 1\n        }\n      ],\n      mode: 'subscription',\n      success_url: successUrl,\n      cancel_url: cancelUrl,\n      metadata: {\n        userId,\n        planId\n      }\n    });\n\n    // Log da criaÃ§Ã£o da sessÃ£o\n    await AuditLog.logAction({\n      userId,\n      userEmail: user.email,\n      action: 'STRIPE_SESSION_CREATED',\n      resource: 'payment_verification',\n      details: `Stripe session created for plan: ${planId}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n\n    res.json({\n      success: true,\n      data: {\n        sessionId: session.id,\n        url: session.url\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao criar sessÃ£o do Stripe:', error);\n    }\n    await AuditLog.logAction({\n      userId: req.user.id,\n      userEmail: req.user.email,\n      action: 'STRIPE_SESSION_CREATION_ERROR',\n      resource: 'payment_verification',\n      details: `Error creating Stripe session: ${error.message}`,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      errorCode: 'SESSION_CREATION_ERROR',\n      errorMessage: error.message\n    });\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao criar sessÃ£o de pagamento'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\payments.js",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'User' is not defined.",
        "line": 134,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 134,
        "endColumn": 28
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 249,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 249,
        "endColumn": 43
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 254,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 254,
        "endColumn": 43
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 259,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 259,
        "endColumn": 48
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'User' is not defined.",
        "line": 329,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 329,
        "endColumn": 28
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'User' is not defined.",
        "line": 420,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 420,
        "endColumn": 28
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'User' is not defined.",
        "line": 507,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 507,
        "endColumn": 15
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'User' is not defined.",
        "line": 552,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 552,
        "endColumn": 17
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'User' is not defined.",
        "line": 573,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 573,
        "endColumn": 17
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'User' is not defined.",
        "line": 696,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 696,
        "endColumn": 28
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 750,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 750,
        "endColumn": 61
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'transactionHash' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 825,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 825,
        "endColumn": 59
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'amount' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 825,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 825,
        "endColumn": 67
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'walletAddress' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 825,
        "column": 69,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 825,
        "endColumn": 82
      }
    ],
    "suppressedMessages": [],
    "errorCount": 10,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { requirePaidAccess as _requirePaidAccess } from '../middleware/requirePaidAccess.js';\nimport { rateLimiter as _rateLimiter } from '../middleware/rateLimiter.js';\nimport _User from '../models/User.js';\nimport Payment from '../models/Payment.js';\nimport AuditLog from '../models/AuditLog.js';\nimport Stripe from 'stripe';\nimport { ethers } from 'ethers';\nimport logger from '../utils/logger.js';\n\nconst router = express.Router();\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n\n// ConfiguraÃ§Ãµes\nconst OWNER_WALLET = process.env.OWNER_WALLET || '0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6';\nconst _WEB3_PROVIDER = process.env.WEB3_PROVIDER || 'https://mainnet.infura.io/v3/your-project-id';\nconst COMMISSION_RATE = 0.05; // 5% de comissÃ£o para intermediaÃ§Ã£o\nconst MIN_COMMISSION = 0.01; // ComissÃ£o mÃ­nima\n\n// Middleware de autenticaÃ§Ã£o para todas as rotas\nrouter.use(authenticateToken);\n\n// Sistema de comissÃµes automÃ¡ticas para intermediaÃ§Ã£o\nrouter.post('/commission/calculate', (req, res) => {\n  try {\n    const { transactionAmount, transactionType } = req.body;\n\n    if (!transactionAmount || transactionAmount <= 0) {\n      return res.status(400).json({\n        success: false,\n        error: 'Valor da transaÃ§Ã£o invÃ¡lido'\n      });\n    }\n\n    // Calcular comissÃ£o baseada no tipo de transaÃ§Ã£o\n    let commissionRate = COMMISSION_RATE;\n\n    switch (transactionType) {\n      case 'product_sale':\n        commissionRate = 0.05; // 5% para vendas de produtos\n        break;\n      case 'freight_service':\n        commissionRate = 0.03; // 3% para serviÃ§os de frete\n        break;\n      case 'premium_plan':\n        commissionRate = 0.1; // 10% para planos premium\n        break;\n      default:\n        commissionRate = COMMISSION_RATE;\n    }\n\n    const commission = Math.max(transactionAmount * commissionRate, MIN_COMMISSION);\n    const netAmount = transactionAmount - commission;\n\n    res.json({\n      success: true,\n      transactionAmount,\n      commissionRate: commissionRate * 100,\n      commission,\n      netAmount,\n      ownerWallet: OWNER_WALLET\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao calcular comissÃ£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Processar pagamento de comissÃ£o para carteira do proprietÃ¡rio\nrouter.post('/commission/process', async (req, res) => {\n  try {\n    const { transactionId, amount, paymentMethod, userWallet } = req.body;\n\n    if (!transactionId || !amount || !paymentMethod) {\n      return res.status(400).json({\n        success: false,\n        error: 'Dados de comissÃ£o invÃ¡lidos'\n      });\n    }\n\n    // Registrar comissÃ£o no banco de dados\n    const commission = new Payment({\n      userId: req.user.id,\n      transactionId,\n      amount,\n      paymentMethod,\n      type: 'commission',\n      status: 'pending',\n      recipientWallet: OWNER_WALLET,\n      senderWallet: userWallet,\n      description: 'ComissÃ£o de intermediaÃ§Ã£o AgroSync'\n    });\n\n    await commission.save();\n\n    // Log de auditoria\n    await AuditLog.create({\n      userId: req.user.id,\n      action: 'commission_created',\n      details: {\n        transactionId,\n        amount,\n        paymentMethod,\n        commissionId: commission._id\n      }\n    });\n\n    res.json({\n      success: true,\n      commissionId: commission._id,\n      message: 'ComissÃ£o processada com sucesso',\n      ownerWallet: OWNER_WALLET\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar comissÃ£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Verificar status de pagamento do usuÃ¡rio\nrouter.get('/status', async (req, res) => {\n  try {\n    const user = await User.findById(req.user.id).select('isPaid planActive planType planExpiry');\n\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        error: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    res.json({\n      success: true,\n      isPaid: user.isPaid || false,\n      planActive: user.planActive || null,\n      planType: user.planType || null,\n      planExpiry: user.planExpiry || null\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar status de pagamento:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Criar sessÃ£o de pagamento Stripe\nrouter.post('/stripe/create-session', async (req, res) => {\n  try {\n    const { planId, planData } = req.body;\n\n    if (!planId || !planData) {\n      return res.status(400).json({\n        success: false,\n        error: 'Dados do plano sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Validar dados do plano\n    const validPlans = {\n      'loja-basic': { price: 2500, name: 'Loja BÃ¡sico' },\n      'loja-pro': { price: 5000, name: 'Loja Pro' },\n      'agroconecta-basic': { price: 5000, name: 'AgroConecta BÃ¡sico' },\n      'agroconecta-pro': { price: 14900, name: 'AgroConecta Pro' }\n    };\n\n    const plan = validPlans[planId];\n    if (!plan) {\n      return res.status(400).json({\n        success: false,\n        error: 'Plano invÃ¡lido'\n      });\n    }\n\n    // Criar sessÃ£o do Stripe\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price_data: {\n            currency: 'brl',\n            product_data: {\n              name: plan.name,\n              description: `Plano ${plan.name} - AgroSync`\n            },\n            unit_amount: plan.price // em centavos\n          },\n          quantity: 1\n        }\n      ],\n      mode: 'subscription',\n      success_url: `${process.env.FRONTEND_URL}/payment-success?session_id={CHECKOUT_SESSION_ID}`,\n      cancel_url: `${process.env.FRONTEND_URL}/planos?canceled=true`,\n      customer_email: req.user.email,\n      metadata: {\n        userId: req.user.id,\n        planId,\n        planName: plan.name\n      }\n    });\n\n    res.json({\n      success: true,\n      sessionId: session.id,\n      url: session.url\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao criar sessÃ£o Stripe:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro ao processar pagamento'\n    });\n  }\n});\n\n// Webhook do Stripe para confirmar pagamentos\nrouter.post('/stripe/webhook', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  let event;\n\n  try {\n    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro na assinatura do webhook:', err.message);\n    }\n    return res.status(400).send(`Webhook Error: ${err.message}`);\n  }\n\n  try {\n    switch (event.type) {\n      case 'checkout.session.completed':\n        const session = event.data.object;\n        await handleStripePaymentSuccess(session);\n        break;\n\n      case 'invoice.payment_succeeded':\n        const invoice = event.data.object;\n        await handleStripeSubscriptionRenewal(invoice);\n        break;\n\n      case 'customer.subscription.deleted':\n        const subscription = event.data.object;\n        await handleStripeSubscriptionCancellation(subscription);\n        break;\n\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Evento nÃ£o tratado: ${event.type}`);\n        }\n    }\n\n    res.json({ received: true });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar webhook:', error);\n    }\n    res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n});\n\n// Processar pagamento Metamask\nrouter.post('/crypto/verify', async (req, res) => {\n  try {\n    const { planId, planData, transactionHash, amount, walletAddress } = req.body;\n\n    if (!planId || !transactionHash || !amount || !walletAddress) {\n      return res.status(400).json({\n        success: false,\n        error: 'Dados da transaÃ§Ã£o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Validar dados do plano\n    const validPlans = {\n      'loja-basic': { price: 0.001, name: 'Loja BÃ¡sico' },\n      'loja-pro': { price: 0.002, name: 'Loja Pro' },\n      'agroconecta-basic': { price: 0.002, name: 'AgroConecta BÃ¡sico' },\n      'agroconecta-pro': { price: 0.005, name: 'AgroConecta Pro' }\n    };\n\n    const plan = validPlans[planId];\n    if (!plan) {\n      return res.status(400).json({\n        success: false,\n        error: 'Plano invÃ¡lido'\n      });\n    }\n\n    // Verificar se o valor estÃ¡ correto\n    if (parseFloat(amount) < plan.price) {\n      return res.status(400).json({\n        success: false,\n        error: 'Valor insuficiente para o plano selecionado'\n      });\n    }\n\n    // Verificar transaÃ§Ã£o na blockchain (simulado)\n    const transactionValid = await verifyBlockchainTransaction(\n      transactionHash,\n      amount,\n      walletAddress\n    );\n\n    if (!transactionValid) {\n      return res.status(400).json({\n        success: false,\n        error: 'TransaÃ§Ã£o invÃ¡lida ou nÃ£o confirmada'\n      });\n    }\n\n    // Atualizar usuÃ¡rio como pago\n    const user = await User.findByIdAndUpdate(\n      req.user.id,\n      {\n        isPaid: true,\n        planActive: planId,\n        planType: plan.name,\n        planExpiry: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias\n        lastPayment: new Date(),\n        paymentMethod: 'crypto'\n      },\n      { new: true }\n    );\n\n    // Salvar registro de pagamento\n    const payment = new Payment({\n      userId: req.user.id,\n      planId,\n      planName: plan.name,\n      amount,\n      currency: 'ETH',\n      paymentMethod: 'crypto',\n      transactionHash,\n      walletAddress,\n      status: 'completed',\n      metadata: {\n        planData,\n        verificationSource: 'blockchain'\n      }\n    });\n\n    await payment.save();\n\n    res.json({\n      success: true,\n      message: 'Pagamento confirmado com sucesso',\n      user: {\n        isPaid: user.isPaid,\n        planActive: user.planActive,\n        planType: user.planType,\n        planExpiry: user.planExpiry\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar pagamento crypto:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Verificar pagamento especÃ­fico\nrouter.get('/verify/:paymentId', async (req, res) => {\n  try {\n    const payment = await Payment.findById(req.params.paymentId);\n\n    if (!payment) {\n      return res.status(404).json({\n        success: false,\n        error: 'Pagamento nÃ£o encontrado'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem acesso ao pagamento\n    if (payment.userId.toString() !== req.user.id && !req.user.isAdmin) {\n      return res.status(403).json({\n        success: false,\n        error: 'Acesso negado'\n      });\n    }\n\n    res.json({\n      success: true,\n      payment\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar pagamento:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Cancelar assinatura\nrouter.post('/cancel', async (req, res) => {\n  try {\n    const user = await User.findById(req.user.id);\n\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        error: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    if (!user.isPaid) {\n      return res.status(400).json({\n        success: false,\n        error: 'UsuÃ¡rio nÃ£o possui plano ativo'\n      });\n    }\n\n    // Se for assinatura Stripe, cancelar no Stripe\n    if (user.paymentMethod === 'stripe' && user.stripeSubscriptionId) {\n      try {\n        await stripe.subscriptions.update(user.stripeSubscriptionId, {\n          cancel_at_period_end: true\n        });\n      } catch (stripeError) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('Erro ao cancelar no Stripe:', stripeError);\n        }\n      }\n    }\n\n    // Atualizar usuÃ¡rio\n    user.isPaid = false;\n    user.planActive = null;\n    user.planType = null;\n    user.planExpiry = null;\n    user.cancellationDate = new Date();\n\n    await user.save();\n\n    res.json({\n      success: true,\n      message: 'Assinatura cancelada com sucesso',\n      user: {\n        isPaid: user.isPaid,\n        planActive: user.planActive,\n        planType: user.planType,\n        planExpiry: user.planExpiry\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao cancelar assinatura:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// HistÃ³rico de pagamentos\nrouter.get('/history', async (req, res) => {\n  try {\n    const payments = await Payment.find({ userId: req.user.id }).sort({ createdAt: -1 }).limit(20);\n\n    res.json({\n      success: true,\n      payments\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar histÃ³rico:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// FunÃ§Ãµes auxiliares\nasync function handleStripePaymentSuccess(session) {\n  try {\n    const { userId } = session.metadata;\n    const { planId } = session.metadata;\n    const { planName } = session.metadata;\n\n    // Atualizar usuÃ¡rio\n    await User.findByIdAndUpdate(userId, {\n      isPaid: true,\n      planActive: planId,\n      planType: planName,\n      planExpiry: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias\n      lastPayment: new Date(),\n      paymentMethod: 'stripe',\n      stripeCustomerId: session.customer,\n      stripeSubscriptionId: session.subscription\n    });\n\n    // Salvar registro de pagamento\n    const payment = new Payment({\n      userId,\n      planId,\n      planName,\n      amount: session.amount_total / 100, // Converter de centavos\n      currency: 'BRL',\n      paymentMethod: 'stripe',\n      stripeSessionId: session.id,\n      status: 'completed',\n      metadata: {\n        stripeCustomerId: session.customer,\n        stripeSubscriptionId: session.subscription\n      }\n    });\n\n    await payment.save();\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Pagamento Stripe confirmado para usuÃ¡rio ${userId}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar pagamento Stripe:', error);\n    }\n  }\n}\n\nasync function handleStripeSubscriptionRenewal(invoice) {\n  try {\n    const subscription = await stripe.subscriptions.retrieve(invoice.subscription);\n    const { userId } = subscription.metadata;\n\n    if (userId) {\n      await User.findByIdAndUpdate(userId, {\n        lastPayment: new Date(),\n        planExpiry: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`RenovaÃ§Ã£o Stripe confirmada para usuÃ¡rio ${userId}`);\n      }\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar renovaÃ§Ã£o Stripe:', error);\n    }\n  }\n}\n\nasync function handleStripeSubscriptionCancellation(subscription) {\n  try {\n    const { userId } = subscription.metadata;\n\n    if (userId) {\n      await User.findByIdAndUpdate(userId, {\n        isPaid: false,\n        planActive: null,\n        planType: null,\n        planExpiry: null,\n        cancellationDate: new Date()\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Cancelamento Stripe processado para usuÃ¡rio ${userId}`);\n      }\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao processar cancelamento Stripe:', error);\n    }\n  }\n}\n\n// ===== ROTAS METAMASK =====\n\n// Criar fatura para pagamento MetaMask\nrouter.post('/metamask/create-invoice', (req, res) => {\n  try {\n    const { planId, planData } = req.body;\n\n    if (!planId || !planData) {\n      return res.status(400).json({\n        success: false,\n        error: 'Dados do plano sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Validar dados do plano\n    const validPlans = {\n      'loja-basic': { price: 0.001, name: 'Loja BÃ¡sico' },\n      'loja-pro': { price: 0.002, name: 'Loja Pro' },\n      'agroconecta-medio': { price: 0.002, name: 'AgroConecta MÃ©dio' },\n      'agroconecta-pro': { price: 0.005, name: 'AgroConecta Pro' }\n    };\n\n    const plan = validPlans[planId];\n    if (!plan) {\n      return res.status(400).json({\n        success: false,\n        error: 'Plano invÃ¡lido'\n      });\n    }\n\n    // Gerar ID Ãºnico para a fatura\n    const invoiceId = `INV_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    res.json({\n      success: true,\n      invoiceId,\n      plan,\n      amount: plan.price,\n      currency: 'ETH',\n      expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutos\n      instructions: `Envie exatamente ${plan.price} ETH para a carteira especificada`\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao criar fatura MetaMask:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Verificar pagamento MetaMask\nrouter.post('/metamask/verify', async (req, res) => {\n  try {\n    const { planId, planData, transactionHash, amount, walletAddress } = req.body;\n\n    if (!planId || !transactionHash || !amount || !walletAddress) {\n      return res.status(400).json({\n        success: false,\n        error: 'Dados da transaÃ§Ã£o sÃ£o obrigatÃ³rios'\n      });\n    }\n\n    // Validar dados do plano\n    const validPlans = {\n      'loja-basic': { price: 0.001, name: 'Loja BÃ¡sico' },\n      'loja-pro': { price: 0.002, name: 'Loja Pro' },\n      'agroconecta-medio': { price: 0.002, name: 'AgroConecta MÃ©dio' },\n      'agroconecta-pro': { price: 0.005, name: 'AgroConecta Pro' }\n    };\n\n    const plan = validPlans[planId];\n    if (!plan) {\n      return res.status(400).json({\n        success: false,\n        error: 'Plano invÃ¡lido'\n      });\n    }\n\n    // Verificar se o valor estÃ¡ correto\n    if (parseFloat(amount) < plan.price) {\n      return res.status(400).json({\n        success: false,\n        error: 'Valor insuficiente para o plano selecionado'\n      });\n    }\n\n    // Verificar transaÃ§Ã£o na blockchain (simulado)\n    const transactionValid = await verifyBlockchainTransaction(\n      transactionHash,\n      amount,\n      walletAddress\n    );\n\n    if (!transactionValid) {\n      return res.status(400).json({\n        success: false,\n        error: 'TransaÃ§Ã£o invÃ¡lida ou nÃ£o confirmada'\n      });\n    }\n\n    // Atualizar usuÃ¡rio como pago\n    const user = await User.findByIdAndUpdate(\n      req.user.id,\n      {\n        isPaid: true,\n        planActive: planId,\n        planType: plan.name,\n        planExpiry: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias\n        lastPayment: new Date(),\n        paymentMethod: 'metamask'\n      },\n      { new: true }\n    );\n\n    // Salvar registro de pagamento\n    const payment = new Payment({\n      userId: req.user.id,\n      planId,\n      planName: plan.name,\n      amount,\n      currency: 'ETH',\n      paymentMethod: 'metamask',\n      transactionHash,\n      walletAddress,\n      status: 'completed',\n      metadata: {\n        planData,\n        verificationSource: 'blockchain'\n      }\n    });\n\n    await payment.save();\n\n    res.json({\n      success: true,\n      message: 'Pagamento MetaMask confirmado com sucesso',\n      user: {\n        isPaid: user.isPaid,\n        planActive: user.planActive,\n        planType: user.planType,\n        planExpiry: user.planExpiry\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar pagamento MetaMask:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Obter saldo da carteira MetaMask\nrouter.get('/metamask/balance/:address', async (req, res) => {\n  try {\n    const { address } = req.params;\n\n    if (!address || !ethers.utils.isAddress(address)) {\n      return res.status(400).json({\n        success: false,\n        error: 'EndereÃ§o de carteira invÃ¡lido'\n      });\n    }\n\n    // Em produÃ§Ã£o, usar provider real\n    // const provider = new ethers.providers.JsonRpcProvider(WEB3_PROVIDER);\n    // const balance = await provider.getBalance(address);\n\n    // Por enquanto, simular saldo\n    const balance = '0.0'; // Simulado\n\n    res.json({\n      success: true,\n      address,\n      balance,\n      currency: 'ETH'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter saldo MetaMask:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Obter transaÃ§Ãµes da carteira MetaMask\nrouter.get('/metamask/transactions/:address', (req, res) => {\n  try {\n    const { address } = req.params;\n    const { limit = 10, offset = 0 } = req.query;\n\n    if (!address || !ethers.utils.isAddress(address)) {\n      return res.status(400).json({\n        success: false,\n        error: 'EndereÃ§o de carteira invÃ¡lido'\n      });\n    }\n\n    // Em produÃ§Ã£o, usar provider real para buscar transaÃ§Ãµes\n    // Por enquanto, retornar transaÃ§Ãµes vazias\n    const transactions = [];\n\n    res.json({\n      success: true,\n      address,\n      transactions,\n      pagination: {\n        limit: parseInt(limit, 10, 10),\n        offset: parseInt(offset, 10, 10),\n        total: 0\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter transaÃ§Ãµes MetaMask:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== FUNÃ‡Ã•ES AUXILIARES =====\n\nasync function verifyBlockchainTransaction(transactionHash, amount, walletAddress) {\n  try {\n    // Em produÃ§Ã£o, usar provider real (Infura, Alchemy, etc.)\n    // const provider = new ethers.providers.JsonRpcProvider(WEB3_PROVIDER);\n    // const tx = await provider.getTransaction(transactionHash);\n\n    // Por enquanto, simular verificaÃ§Ã£o\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Simular verificaÃ§Ã£o bem-sucedida\n    return true;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao verificar transaÃ§Ã£o blockchain:', error);\n    }\n    return false;\n  }\n}\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\plans.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\privacy.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\products.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'authLimiter' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 21
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'getClientIP' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 7,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport Product from '../models/Product.js';\nimport User from '../models/User.js';\nimport { validateProduct } from '../middleware/validation.js';\nimport { authLimiter, apiLimiter } from '../middleware/rateLimiter.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { getClientIP } from '../utils/ipUtils.js';\n\nconst router = express.Router();\nimport logger from '../utils/logger.js';\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// GET /api/products - Get all products with pagination and filters\nrouter.get('/', async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 20,\n      category,\n      subcategory,\n      minPrice,\n      maxPrice,\n      location,\n      search,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = req.query;\n\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    // Build query\n    const query = { status: 'active' };\n\n    if (category) {\n      query.category = category;\n    }\n    if (subcategory) {\n      query.subcategory = subcategory;\n    }\n    if (minPrice || maxPrice) {\n      query.price = {};\n      if (minPrice) {\n        query.price.$gte = parseFloat(minPrice);\n      }\n      if (maxPrice) {\n        query.price.$lte = parseFloat(maxPrice);\n      }\n    }\n    if (location) {\n      query['location.city'] = { $regex: location, $options: 'i' };\n    }\n    if (search) {\n      query.$or = [\n        { name: { $regex: search, $options: 'i' } },\n        { description: { $regex: search, $options: 'i' } },\n        { tags: { $in: [new RegExp(search, 'i')] } }\n      ];\n    }\n\n    // Build sort\n    const sort = {};\n    sort[sortBy] = sortOrder === 'desc' ? -1 : 1;\n\n    // Execute query\n    const products = await Product.find(query)\n      .sort(sort)\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .populate('sellerId', 'name company.name')\n      .lean();\n\n    // Get total count for pagination\n    const total = await Product.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        products,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    logger.error('Error fetching products:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/products/featured - Get featured products\nrouter.get('/featured', async (req, res) => {\n  try {\n    const { limit = 10 } = req.query;\n\n    const products = await Product.find({\n      status: 'active',\n      isFeatured: true\n    })\n      .sort({ createdAt: -1 })\n      .limit(parseInt(limit, 10, 10))\n      .populate('sellerId', 'name company.name')\n      .lean();\n\n    res.json({\n      success: true,\n      data: { products }\n    });\n  } catch (error) {\n    logger.error('Error fetching featured products:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/products/categories - Get all product categories\nrouter.get('/categories', async (req, res) => {\n  try {\n    const categories = await Product.distinct('category');\n\n    res.json({\n      success: true,\n      data: { categories }\n    });\n  } catch (error) {\n    logger.error('Error fetching categories:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/products/:id - Get product by ID\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    const product = await Product.findById(id)\n      .populate('sellerId', 'name company.name phone')\n      .lean();\n\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Produto nÃ£o encontrado'\n      });\n    }\n\n    if (product.status !== 'active') {\n      return res.status(404).json({\n        success: false,\n        message: 'Produto nÃ£o disponÃ­vel'\n      });\n    }\n\n    // Increment view count (async, don't wait)\n    Product.findByIdAndUpdate(id, { $inc: { views: 1 } }).exec();\n\n    res.json({\n      success: true,\n      data: { product }\n    });\n  } catch (error) {\n    logger.error('Error fetching product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/products - Create new product (requires authentication and active store plan)\nrouter.post('/', authenticateToken, validateProduct, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // Check if user has active store plan\n    const user = await User.findById(userId);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    if (!user.hasActivePlan('store')) {\n      return res.status(403).json({\n        success: false,\n        message: 'Plano de loja nÃ£o ativo. Ative um plano para criar anÃºncios.'\n      });\n    }\n\n    if (!user.canCreateAd()) {\n      return res.status(403).json({\n        success: false,\n        message: 'Limite de anÃºncios atingido. FaÃ§a upgrade do seu plano.'\n      });\n    }\n\n    // Create product\n    const productData = {\n      ...req.body,\n      sellerId: userId\n    };\n\n    const product = new Product(productData);\n    await product.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Produto criado com sucesso',\n      data: { product }\n    });\n  } catch (error) {\n    logger.error('Error creating product:', error);\n    if (error.message.includes('Plano de loja nÃ£o ativo')) {\n      return res.status(403).json({\n        success: false,\n        message: error.message\n      });\n    }\n\n    if (error.message.includes('Limite de anÃºncios atingido')) {\n      return res.status(403).json({\n        success: false,\n        message: error.message\n      });\n    }\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /api/products/:id - Update product\nrouter.put('/:id', authenticateToken, validateProduct, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const product = await Product.findById(id);\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Produto nÃ£o encontrado'\n      });\n    }\n\n    // Check if user owns the product\n    if (product.sellerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. VocÃª sÃ³ pode editar seus prÃ³prios produtos.'\n      });\n    }\n\n    // Update product\n    Object.assign(product, req.body);\n    await product.save();\n\n    res.json({\n      success: true,\n      message: 'Produto atualizado com sucesso',\n      data: { product }\n    });\n  } catch (error) {\n    logger.error('Error updating product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/products/:id - Delete product\nrouter.delete('/:id', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const product = await Product.findById(id);\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Produto nÃ£o encontrado'\n      });\n    }\n\n    // Check if user owns the product\n    if (product.sellerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado. VocÃª sÃ³ pode excluir seus prÃ³prios produtos.'\n      });\n    }\n\n    // Soft delete - mark as inactive\n    product.status = 'inactive';\n    await product.save();\n\n    res.json({\n      success: true,\n      message: 'Produto removido com sucesso'\n    });\n  } catch (error) {\n    logger.error('Error deleting product:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/products/:id/favorite - Add product to favorites\nrouter.post('/:id/favorite', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const product = await Product.findById(id);\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Produto nÃ£o encontrado'\n      });\n    }\n\n    if (product.status !== 'active') {\n      return res.status(400).json({\n        success: false,\n        message: 'Produto nÃ£o disponÃ­vel'\n      });\n    }\n\n    // Add to favorites\n    await product.addToFavorites(userId);\n\n    res.json({\n      success: true,\n      message: 'Produto adicionado aos favoritos'\n    });\n  } catch (error) {\n    logger.error('Error adding to favorites:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// DELETE /api/products/:id/favorite - Remove product from favorites\nrouter.delete('/:id/favorite', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const product = await Product.findById(id);\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Produto nÃ£o encontrado'\n      });\n    }\n\n    // Remove from favorites\n    await product.removeFromFavorites(userId);\n\n    res.json({\n      success: true,\n      message: 'Produto removido dos favoritos'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error removing from favorites:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/products/user/favorites - Get user's favorite products\nrouter.get('/user/favorites', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { page = 1, limit = 20 } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const products = await Product.find({\n      'favorites.userId': userId,\n      status: 'active'\n    })\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .populate('sellerId', 'name company.name')\n      .lean();\n\n    const total = await Product.countDocuments({\n      'favorites.userId': userId,\n      status: 'active'\n    });\n\n    res.json({\n      success: true,\n      data: {\n        products,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching favorite products:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/products/seller/my-products - Get seller's own products\nrouter.get('/seller/my-products', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { page = 1, limit = 20, status } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = { sellerId: userId };\n    if (status) {\n      query.status = status;\n    }\n\n    const products = await Product.find(query)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .lean();\n\n    const total = await Product.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        products,\n        pagination: {\n          currentPage: parseInt(page, 10, 10),\n          totalPages: Math.ceil(total / parseInt(limit, 10, 10)),\n          totalItems: total,\n          itemsPerPage: parseInt(limit, 10, 10)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error fetching seller products:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/products/:id/contact - Contact seller about product\nrouter.post('/:id/contact', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n    const { message } = req.body;\n\n    if (!message || message.trim().length < 10) {\n      return res.status(400).json({\n        success: false,\n        message: 'Mensagem deve ter pelo menos 10 caracteres'\n      });\n    }\n\n    const product = await Product.findById(id);\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        message: 'Produto nÃ£o encontrado'\n      });\n    }\n\n    if (product.status !== 'active') {\n      return res.status(400).json({\n        success: false,\n        message: 'Produto nÃ£o disponÃ­vel'\n      });\n    }\n\n    // Check if user is not contacting themselves\n    if (product.sellerId.toString() === userId) {\n      return res.status(400).json({\n        success: false,\n        message: 'VocÃª nÃ£o pode enviar mensagem para si mesmo'\n      });\n    }\n\n    // Here you would typically create a message/contact record\n    // For now, we'll just return success\n\n    res.json({\n      success: true,\n      message: 'Mensagem enviada com sucesso para o vendedor'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error contacting seller:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\registration.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'auth' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 4,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 11
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 22,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 22,
        "endColumn": 34
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 51,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 51,
        "endColumn": 33
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 79,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 79,
        "endColumn": 35
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 118,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 118,
        "endColumn": 38
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async arrow function has no 'await' expression.",
        "line": 140,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 140,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const express = require('express');\nconst router = express.Router();\nconst { AgroConecta, Loja, Marketplace, Fazenda } = require('../models/Registration');\nconst auth = require('../middleware/auth');\nconst rateLimit = require('express-rate-limit');\n\n// Rate limiting para APIs externas\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 100, // mÃ¡ximo 100 requests por IP\n  message: 'Muitas tentativas de acesso. Tente novamente em 15 minutos.'\n});\n\n// Rate limiting para cadastros\nconst registrationLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hora\n  max: 5, // mÃ¡ximo 5 cadastros por IP por hora\n  message: 'Muitos cadastros realizados. Tente novamente em 1 hora.'\n});\n\n// FunÃ§Ã£o para buscar dados por CEP\nconst fetchCEPData = async cep => {\n  try {\n    // Simular API dos Correios (substituir por API real)\n    const cleanCEP = cep.replace(/\\D/g, '');\n\n    if (cleanCEP.length !== 8) {\n      throw new Error('CEP invÃ¡lido');\n    }\n\n    // Mock data - substituir por chamada real para API dos Correios\n    const mockData = {\n      cep,\n      logradouro: 'Avenida Paulista',\n      bairro: 'Bela Vista',\n      localidade: 'SÃ£o Paulo',\n      uf: 'SP',\n      ibge: '3550308',\n      gia: '1004',\n      ddd: '11',\n      siafi: '7107'\n    };\n\n    return mockData;\n  } catch (error) {\n    throw new Error(`Erro ao buscar CEP: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para validar CPF na Receita Federal\nconst validateCPF = async cpf => {\n  try {\n    const cleanCPF = cpf.replace(/\\D/g, '');\n\n    if (cleanCPF.length !== 11) {\n      throw new Error('CPF deve ter 11 dÃ­gitos');\n    }\n\n    // Simular validaÃ§Ã£o na Receita Federal\n    // Em produÃ§Ã£o, usar API real da Receita Federal\n    const isValid = true; // Mock validation\n\n    if (!isValid) {\n      throw new Error('CPF invÃ¡lido na Receita Federal');\n    }\n\n    return {\n      isValid: true,\n      status: 'VALID',\n      name: 'Nome da Pessoa', // Mock - em produÃ§Ã£o viria da API\n      birthDate: '1990-01-01' // Mock\n    };\n  } catch (error) {\n    throw new Error(`Erro ao validar CPF: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para validar CNPJ na Receita Federal\nconst validateCNPJ = async cnpj => {\n  try {\n    const cleanCNPJ = cnpj.replace(/\\D/g, '');\n\n    if (cleanCNPJ.length !== 14) {\n      throw new Error('CNPJ deve ter 14 dÃ­gitos');\n    }\n\n    // Simular validaÃ§Ã£o na Receita Federal\n    // Em produÃ§Ã£o, usar API real da Receita Federal\n    const isValid = true; // Mock validation\n\n    if (!isValid) {\n      throw new Error('CNPJ invÃ¡lido na Receita Federal');\n    }\n\n    return {\n      isValid: true,\n      status: 'ATIVA',\n      companyName: 'Empresa Exemplo LTDA', // Mock - em produÃ§Ã£o viria da API\n      fantasyName: 'Empresa Exemplo',\n      openingDate: '2020-01-01',\n      ie: '123.456.789.012',\n      address: {\n        street: 'Rua das Flores, 123',\n        neighborhood: 'Centro',\n        city: 'SÃ£o Paulo',\n        state: 'SP',\n        zipCode: '01000-000'\n      },\n      activities: ['ComÃ©rcio de produtos agrÃ­colas'],\n      capital: 100000\n    };\n  } catch (error) {\n    throw new Error(`Erro ao validar CNPJ: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para buscar localizaÃ§Ã£o por IP\nconst fetchLocationByIP = async ip => {\n  try {\n    // Simular busca por IP (substituir por API real como ipapi.co)\n    const mockData = {\n      ip,\n      city: 'SÃ£o Paulo',\n      region: 'SÃ£o Paulo',\n      country: 'BR',\n      country_name: 'Brazil',\n      postal: '01000-000',\n      latitude: -23.5505,\n      longitude: -46.6333,\n      timezone: 'America/Sao_Paulo'\n    };\n\n    return mockData;\n  } catch (error) {\n    throw new Error(`Erro ao buscar localizaÃ§Ã£o: ${error.message}`);\n  }\n};\n\n// FunÃ§Ã£o para buscar produtos por API\nconst searchProducts = async query => {\n  try {\n    // Simular busca de produtos (substituir por API real)\n    const mockProducts = [\n      {\n        id: '1',\n        name: 'Soja',\n        category: 'GrÃ£os',\n        unit: 'saca',\n        description: 'Soja para alimentaÃ§Ã£o animal'\n      },\n      {\n        id: '2',\n        name: 'Milho',\n        category: 'GrÃ£os',\n        unit: 'saca',\n        description: 'Milho para alimentaÃ§Ã£o animal'\n      },\n      {\n        id: '3',\n        name: 'Trigo',\n        category: 'GrÃ£os',\n        unit: 'saca',\n        description: 'Trigo para panificaÃ§Ã£o'\n      },\n      { id: '4', name: 'CafÃ©', category: 'Bebidas', unit: 'kg', description: 'CafÃ© em grÃ£o' },\n      {\n        id: '5',\n        name: 'AÃ§Ãºcar',\n        category: 'DulÃ§or',\n        unit: 'kg',\n        description: 'AÃ§Ãºcar cristal'\n      },\n      {\n        id: '6',\n        name: 'Fertilizante NPK',\n        category: 'Insumos',\n        unit: 'kg',\n        description: 'Fertilizante NPK 20-10-10'\n      },\n      {\n        id: '7',\n        name: 'Sementes de Soja',\n        category: 'Insumos',\n        unit: 'kg',\n        description: 'Sementes de soja certificadas'\n      },\n      {\n        id: '8',\n        name: 'Defensivo AgrÃ­cola',\n        category: 'Insumos',\n        unit: 'L',\n        description: 'Defensivo para controle de pragas'\n      }\n    ];\n\n    const filtered = mockProducts.filter(\n      product =>\n        product.name.toLowerCase().includes(query.toLowerCase()) ||\n        product.category.toLowerCase().includes(query.toLowerCase()) ||\n        product.description.toLowerCase().includes(query.toLowerCase())\n    );\n\n    return filtered;\n  } catch (error) {\n    throw new Error(`Erro ao buscar produtos: ${error.message}`);\n  }\n};\n\n// GET /api/registration/cep/:cep - Buscar dados por CEP\nrouter.get('/cep/:cep', apiLimiter, async (req, res) => {\n  try {\n    const { cep } = req.params;\n    const data = await fetchCEPData(cep);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/validate/cpf/:cpf - Validar CPF\nrouter.get('/validate/cpf/:cpf', apiLimiter, async (req, res) => {\n  try {\n    const { cpf } = req.params;\n    const data = await validateCPF(cpf);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/validate/cnpj/:cnpj - Validar CNPJ\nrouter.get('/validate/cnpj/:cnpj', apiLimiter, async (req, res) => {\n  try {\n    const { cnpj } = req.params;\n    const data = await validateCNPJ(cnpj);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/location/:ip - Buscar localizaÃ§Ã£o por IP\nrouter.get('/location/:ip', apiLimiter, async (req, res) => {\n  try {\n    const { ip } = req.params;\n    const data = await fetchLocationByIP(ip);\n\n    res.json({\n      success: true,\n      data\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// GET /api/registration/products/search/:query - Buscar produtos\nrouter.get('/products/search/:query', apiLimiter, async (req, res) => {\n  try {\n    const { query } = req.params;\n    const products = await searchProducts(query);\n\n    res.json({\n      success: true,\n      data: products\n    });\n  } catch (error) {\n    res.status(400).json({\n      success: false,\n      message: error.message\n    });\n  }\n});\n\n// POST /api/registration/agroconecta - Cadastrar no AgroConecta\nrouter.post('/agroconecta', registrationLimiter, async (req, res) => {\n  try {\n    const {\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      vehicle,\n      services,\n      plan,\n      isPublic\n    } = req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await AgroConecta.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await AgroConecta.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCNPJ = await AgroConecta.findOne({ cnpj });\n    if (existingCNPJ) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newAgroConecta = new AgroConecta({\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      vehicle,\n      services,\n      plan,\n      isPublic\n    });\n\n    await newAgroConecta.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newAgroConecta._id,\n        email: newAgroConecta.email,\n        plan: newAgroConecta.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar AgroConecta:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/registration/loja - Cadastrar na Loja\nrouter.post('/loja', registrationLimiter, async (req, res) => {\n  try {\n    const { name, email, phone, cpf, companyName, cnpj, ie, address, products, plan, isPublic } =\n      req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await Loja.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await Loja.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCNPJ = await Loja.findOne({ cnpj });\n    if (existingCNPJ) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newLoja = new Loja({\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      products,\n      plan,\n      isPublic\n    });\n\n    await newLoja.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newLoja._id,\n        email: newLoja.email,\n        plan: newLoja.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar Loja:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/registration/marketplace - Cadastrar no Marketplace\nrouter.post('/marketplace', registrationLimiter, async (req, res) => {\n  try {\n    const { name, email, phone, cpf, companyName, cnpj, ie, address, offerings, plan, isPublic } =\n      req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await Marketplace.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await Marketplace.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCNPJ = await Marketplace.findOne({ cnpj });\n    if (existingCNPJ) {\n      return res.status(400).json({\n        success: false,\n        message: 'CNPJ jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newMarketplace = new Marketplace({\n      name,\n      email,\n      phone,\n      cpf,\n      companyName,\n      cnpj,\n      ie,\n      address,\n      offerings,\n      plan,\n      isPublic\n    });\n\n    await newMarketplace.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newMarketplace._id,\n        email: newMarketplace.email,\n        plan: newMarketplace.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar Marketplace:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// POST /api/registration/fazenda - Cadastrar Fazenda\nrouter.post('/fazenda', registrationLimiter, async (req, res) => {\n  try {\n    const {\n      name,\n      email,\n      phone,\n      cpf,\n      farmName,\n      farmSize,\n      farmType,\n      address,\n      products,\n      plan,\n      isPublic\n    } = req.body;\n\n    // Verificar se jÃ¡ existe cadastro\n    const existingEmail = await Fazenda.findOne({ email });\n    if (existingEmail) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email jÃ¡ cadastrado'\n      });\n    }\n\n    const existingCPF = await Fazenda.findOne({ cpf });\n    if (existingCPF) {\n      return res.status(400).json({\n        success: false,\n        message: 'CPF jÃ¡ cadastrado'\n      });\n    }\n\n    // Criar novo cadastro\n    const newFazenda = new Fazenda({\n      name,\n      email,\n      phone,\n      cpf,\n      farmName,\n      farmSize,\n      farmType,\n      address,\n      products,\n      plan,\n      isPublic\n    });\n\n    await newFazenda.save();\n\n    res.status(201).json({\n      success: true,\n      message: 'Cadastro realizado com sucesso',\n      data: {\n        id: newFazenda._id,\n        email: newFazenda.email,\n        plan: newFazenda.plan\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao cadastrar Fazenda:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/agroconecta/public - Listar cadastros pÃºblicos do AgroConecta\nrouter.get('/agroconecta/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, vehicleType } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n    if (vehicleType) {\n      filter['vehicle.type'] = vehicleType;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [agroconectas, total] = await Promise.all([\n      AgroConecta.find(filter)\n        .select('name companyName address vehicle services stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10, 10))\n        .sort({ createdAt: -1 }),\n      AgroConecta.countDocuments(filter)\n    ]);\n\n    res.json({\n      success: true,\n      data: agroconectas,\n      pagination: {\n        page: parseInt(page, 10, 10),\n        limit: parseInt(limit, 10, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar AgroConecta:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/loja/public - Listar cadastros pÃºblicos da Loja\nrouter.get('/loja/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, category } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [lojas, total] = await Promise.all([\n      Loja.find(filter)\n        .select('name companyName address products stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10, 10))\n        .sort({ createdAt: -1 }),\n      Loja.countDocuments(filter)\n    ]);\n\n    // Filtrar produtos por categoria se especificado\n    if (category) {\n      lojas.forEach(loja => {\n        loja.products = loja.products.filter(product =>\n          product.category.toLowerCase().includes(category.toLowerCase())\n        );\n      });\n    }\n\n    res.json({\n      success: true,\n      data: lojas,\n      pagination: {\n        page: parseInt(page, 10, 10),\n        limit: parseInt(limit, 10, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar Lojas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/marketplace/public - Listar cadastros pÃºblicos do Marketplace\nrouter.get('/marketplace/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, type } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [marketplaces, total] = await Promise.all([\n      Marketplace.find(filter)\n        .select('name companyName address offerings stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10, 10))\n        .sort({ createdAt: -1 }),\n      Marketplace.countDocuments(filter)\n    ]);\n\n    // Filtrar ofertas por tipo se especificado\n    if (type) {\n      marketplaces.forEach(marketplace => {\n        marketplace.offerings = marketplace.offerings.filter(offering => offering.type === type);\n      });\n    }\n\n    res.json({\n      success: true,\n      data: marketplaces,\n      pagination: {\n        page: parseInt(page, 10, 10),\n        limit: parseInt(limit, 10, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar Marketplaces:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\n// GET /api/registration/fazenda/public - Listar cadastros pÃºblicos de Fazendas\nrouter.get('/fazenda/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, city, state, farmType } = req.query;\n\n    const filter = { isPublic: true, isActive: true };\n\n    if (city) {\n      filter['address.city'] = new RegExp(city, 'i');\n    }\n    if (state) {\n      filter['address.state'] = state;\n    }\n    if (farmType) {\n      filter.farmType = farmType;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const [fazendas, total] = await Promise.all([\n      Fazenda.find(filter)\n        .select('name farmName farmSize farmType address products stats plan')\n        .skip(skip)\n        .limit(parseInt(limit, 10, 10))\n        .sort({ createdAt: -1 }),\n      Fazenda.countDocuments(filter)\n    ]);\n\n    res.json({\n      success: true,\n      data: fazendas,\n      pagination: {\n        page: parseInt(page, 10, 10),\n        limit: parseInt(limit, 10, 10),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    const logger = require('../utils/logger');\n    logger.error('Erro ao buscar Fazendas:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: error.message\n    });\n  }\n});\n\nmodule.exports = router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\secureURLs.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\staking.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\swagger.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\transactions.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 7,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport { authenticateToken, requireRole } from '../middleware/auth.js';\nimport Transaction from '../models/Transaction.js';\nimport TransactionMessage from '../models/TransactionMessage.js';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport User from '../models/User.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Aplicar rate limiting\nrouter.use(apiLimiter);\n\n// ===== MIDDLEWARE DE AUTENTICAÃ‡ÃƒO =====\n// Todas as rotas requerem autenticaÃ§Ã£o\nrouter.use(authenticateToken);\n\n// ===== ROTAS DE TRANSACÃ•ES =====\n\n// POST / - Criar nova transaÃ§Ã£o de intermediaÃ§Ã£o\nrouter.post('/', async (req, res) => {\n  try {\n    const { type, itemId, itemModel, total, shipping, paymentMethods, deliveryOptions, notes } =\n      req.body;\n\n    const buyerId = req.user.userId;\n\n    // ValidaÃ§Ãµes bÃ¡sicas\n    if (!type || !itemId || !itemModel || !total) {\n      return res.status(400).json({\n        success: false,\n        message: 'Campos obrigatÃ³rios: type, itemId, itemModel, total'\n      });\n    }\n\n    // Validar tipo de transaÃ§Ã£o\n    if (!['PRODUCT', 'FREIGHT', 'SERVICE'].includes(type)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipo de transaÃ§Ã£o invÃ¡lido'\n      });\n    }\n\n    // Validar modelo do item\n    if (!['Product', 'Freight', 'Service'].includes(itemModel)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Modelo de item invÃ¡lido'\n      });\n    }\n\n    // Buscar o item para obter sellerId e detalhes\n    let item, sellerId;\n\n    switch (itemModel) {\n      case 'Product':\n        item = await Product.findById(itemId);\n        if (!item) {\n          return res.status(404).json({\n            success: false,\n            message: 'Produto nÃ£o encontrado'\n          });\n        }\n        sellerId = item.seller;\n        break;\n\n      case 'Freight':\n        item = await Freight.findById(itemId);\n        if (!item) {\n          return res.status(404).json({\n            success: false,\n            message: 'Frete nÃ£o encontrado'\n          });\n        }\n        sellerId = item.carrier;\n        break;\n\n      default:\n        return res.status(400).json({\n          success: false,\n          message: 'Modelo de item nÃ£o suportado'\n        });\n    }\n\n    // Verificar se nÃ£o estÃ¡ tentando comprar de si mesmo\n    if (buyerId.toString() === sellerId.toString()) {\n      return res.status(400).json({\n        success: false,\n        message: 'NÃ£o Ã© possÃ­vel criar transaÃ§Ã£o consigo mesmo'\n      });\n    }\n\n    // Verificar se jÃ¡ existe uma transaÃ§Ã£o pendente para este item\n    const existingTransaction = await Transaction.findOne({\n      itemId,\n      itemModel,\n      buyerId,\n      status: { $in: ['PENDING', 'NEGOTIATING'] }\n    });\n\n    if (existingTransaction) {\n      return res.status(409).json({\n        success: false,\n        message: 'JÃ¡ existe uma transaÃ§Ã£o pendente para este item',\n        transactionId: existingTransaction.id\n      });\n    }\n\n    // Criar transaÃ§Ã£o\n    const transaction = new Transaction({\n      type,\n      buyerId,\n      sellerId,\n      itemId,\n      itemModel,\n      total,\n      shipping: shipping || {},\n      paymentMethods: paymentMethods || [],\n      deliveryOptions: deliveryOptions || [],\n      notes: notes || {},\n      createdBy: buyerId\n    });\n\n    // Adicionar detalhes do item\n    if (item) {\n      transaction.itemDetails = {\n        name: item.name || item.title,\n        description: item.description,\n        price: item.price,\n        quantity: item.quantity || item.stock,\n        unit: item.unit,\n        category: item.category,\n        location: item.location || item.origin\n      };\n    }\n\n    await transaction.save();\n\n    // Populate dados do usuÃ¡rio para resposta\n    await transaction.populate([\n      { path: 'buyerId', select: 'name email phone' },\n      { path: 'sellerId', select: 'name email phone' }\n    ]);\n\n    res.status(201).json({\n      success: true,\n      message: 'TransaÃ§Ã£o criada com sucesso',\n      transaction: {\n        id: transaction.id,\n        type: transaction.type,\n        status: transaction.status,\n        buyer: transaction.buyerId,\n        seller: transaction.sellerId,\n        item: transaction.itemDetails,\n        total: transaction.total,\n        createdAt: transaction.createdAt,\n        negotiationDeadline: transaction.negotiationDeadline\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao criar transaÃ§Ã£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n});\n\n// GET / - Listar transaÃ§Ãµes do usuÃ¡rio\nrouter.get('/', async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { type, status, page = 1, limit = 20 } = req.query;\n\n    // Construir filtros\n    const filters = {\n      $or: [{ buyerId: userId }, { sellerId: userId }]\n    };\n\n    if (type) {\n      filters.type = type;\n    }\n    if (status) {\n      filters.status = status;\n    }\n\n    // PaginaÃ§Ã£o\n    const skip = (page - 1) * limit;\n\n    // Buscar transaÃ§Ãµes\n    const transactions = await Transaction.find(filters)\n      .populate('buyerId', 'name email phone')\n      .populate('sellerId', 'name email phone')\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10));\n\n    // Contar total\n    const total = await Transaction.countDocuments(filters);\n\n    // Separar por tipo (compras vs vendas)\n    const purchases = transactions.filter(t => t.buyerId._id.toString() === userId);\n    const sales = transactions.filter(t => t.sellerId._id.toString() === userId);\n\n    res.json({\n      success: true,\n      data: {\n        transactions,\n        purchases,\n        sales,\n        pagination: {\n          page: parseInt(page, 10, 10),\n          limit: parseInt(limit, 10, 10),\n          total,\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar transaÃ§Ãµes:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /:id - Buscar transaÃ§Ã£o por ID\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const transaction = await Transaction.findById(id)\n      .populate('buyerId', 'name email phone')\n      .populate('sellerId', 'name email phone');\n\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem acesso a esta transaÃ§Ã£o\n    if (\n      transaction.buyerId._id.toString() !== userId &&\n      transaction.sellerId._id.toString() !== userId\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado a esta transaÃ§Ã£o'\n      });\n    }\n\n    res.json({\n      success: true,\n      transaction\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar transaÃ§Ã£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PUT /:id/status - Atualizar status da transaÃ§Ã£o\nrouter.put('/:id/status', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { newStatus, reason, notes } = req.body;\n    const { userId } = req.user;\n\n    // Buscar transaÃ§Ã£o\n    const transaction = await Transaction.findById(id);\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Verificar permissÃµes\n    if (transaction.buyerId.toString() !== userId && transaction.sellerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Sem permissÃ£o para alterar esta transaÃ§Ã£o'\n      });\n    }\n\n    // Verificar se a mudanÃ§a de status Ã© vÃ¡lida\n    if (!transaction.canChangeToStatus(newStatus)) {\n      return res.status(400).json({\n        success: false,\n        message: `MudanÃ§a de status invÃ¡lida: ${transaction.status} â†’ ${newStatus}`\n      });\n    }\n\n    // Salvar status anterior\n    const oldStatus = transaction.status;\n\n    // Atualizar status\n    transaction.status = newStatus;\n\n    // Adicionar ao histÃ³rico\n    await transaction.addStatusHistory(newStatus, userId, reason, notes);\n\n    // Atualizar campos relacionados ao escrow se necessÃ¡rio\n    if (newStatus.startsWith('ESCROW_')) {\n      transaction.usesEscrow = true;\n      transaction.escrowStatus = newStatus.replace('ESCROW_', '');\n    }\n\n    // Salvar transaÃ§Ã£o\n    await transaction.save();\n\n    // Buscar transaÃ§Ã£o atualizada com populaÃ§Ãµes\n    const updatedTransaction = await Transaction.findById(id)\n      .populate('buyerId', 'name email')\n      .populate('sellerId', 'name email')\n      .populate('itemId')\n      .populate('escrowTransactionId');\n\n    res.json({\n      success: true,\n      message: 'Status da transaÃ§Ã£o atualizado com sucesso',\n      data: {\n        transaction: updatedTransaction,\n        oldStatus,\n        newStatus,\n        escrowBadge: updatedTransaction.getEscrowBadge(),\n        timeRemaining: updatedTransaction.getTimeRemaining()\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao atualizar status da transaÃ§Ã£o:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /:id/escrow/enable - Habilitar escrow para transaÃ§Ã£o\nrouter.post('/:id/escrow/enable', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { autoReleaseDays, requiresConfirmation, allowDisputes, maxDisputeDays } = req.body;\n    const { userId } = req.user;\n\n    // Buscar transaÃ§Ã£o\n    const transaction = await Transaction.findById(id);\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Verificar permissÃµes (apenas comprador pode habilitar escrow)\n    if (transaction.buyerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Apenas o comprador pode habilitar escrow'\n      });\n    }\n\n    // Verificar se jÃ¡ tem escrow habilitado\n    if (transaction.usesEscrow) {\n      return res.status(400).json({\n        success: false,\n        message: 'Escrow jÃ¡ estÃ¡ habilitado para esta transaÃ§Ã£o'\n      });\n    }\n\n    // Verificar se o status permite habilitar escrow\n    if (!['PENDING', 'NEGOTIATING', 'AGREED'].includes(transaction.status)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Status da transaÃ§Ã£o nÃ£o permite habilitar escrow'\n      });\n    }\n\n    // Atualizar configuraÃ§Ãµes de escrow\n    transaction.usesEscrow = true;\n    transaction.escrowSettings = {\n      enabled: true,\n      autoReleaseDays: autoReleaseDays || 7,\n      requiresConfirmation: requiresConfirmation !== false,\n      allowDisputes: allowDisputes !== false,\n      maxDisputeDays: maxDisputeDays || 3\n    };\n\n    // Mudar status para ESCROW_PENDING\n    transaction.status = 'ESCROW_PENDING';\n    transaction.escrowStatus = 'PENDING';\n\n    // Adicionar ao histÃ³rico\n    await transaction.addStatusHistory(\n      'ESCROW_PENDING',\n      userId,\n      'Escrow habilitado',\n      'Escrow habilitado pelo comprador'\n    );\n\n    // Salvar transaÃ§Ã£o\n    await transaction.save();\n\n    // Buscar transaÃ§Ã£o atualizada\n    const updatedTransaction = await Transaction.findById(id)\n      .populate('buyerId', 'name email')\n      .populate('sellerId', 'name email')\n      .populate('itemId');\n\n    res.json({\n      success: true,\n      message: 'Escrow habilitado com sucesso',\n      data: {\n        transaction: updatedTransaction,\n        escrowBadge: updatedTransaction.getEscrowBadge(),\n        escrowSettings: updatedTransaction.escrowSettings\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao habilitar escrow:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /:id/escrow/disable - Desabilitar escrow para transaÃ§Ã£o\nrouter.post('/:id/escrow/disable', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { reason } = req.body;\n    const { userId } = req.user;\n\n    // Buscar transaÃ§Ã£o\n    const transaction = await Transaction.findById(id);\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Verificar permissÃµes (apenas comprador pode desabilitar escrow)\n    if (transaction.buyerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Apenas o comprador pode desabilitar escrow'\n      });\n    }\n\n    // Verificar se escrow estÃ¡ habilitado\n    if (!transaction.usesEscrow) {\n      return res.status(400).json({\n        success: false,\n        message: 'Escrow nÃ£o estÃ¡ habilitado para esta transaÃ§Ã£o'\n      });\n    }\n\n    // Verificar se pode desabilitar (apenas se ainda nÃ£o foi fundado)\n    if (\n      ['FUNDED', 'IN_TRANSIT', 'DELIVERED', 'CONFIRMED', 'DISPUTED', 'RELEASED'].includes(\n        transaction.escrowStatus\n      )\n    ) {\n      return res.status(400).json({\n        success: false,\n        message: 'NÃ£o Ã© possÃ­vel desabilitar escrow apÃ³s o valor ser depositado'\n      });\n    }\n\n    // Desabilitar escrow\n    transaction.usesEscrow = false;\n    transaction.escrowSettings.enabled = false;\n    transaction.escrowStatus = 'NONE';\n\n    // Voltar para status anterior\n    if (transaction.status.startsWith('ESCROW_')) {\n      transaction.status = 'AGREED';\n    }\n\n    // Adicionar ao histÃ³rico\n    await transaction.addStatusHistory(\n      'AGREED',\n      userId,\n      'Escrow desabilitado',\n      reason || 'Escrow desabilitado pelo comprador'\n    );\n\n    // Salvar transaÃ§Ã£o\n    await transaction.save();\n\n    // Buscar transaÃ§Ã£o atualizada\n    const updatedTransaction = await Transaction.findById(id)\n      .populate('buyerId', 'name email')\n      .populate('sellerId', 'name email')\n      .populate('itemId');\n\n    res.json({\n      success: true,\n      message: 'Escrow desabilitado com sucesso',\n      data: {\n        transaction: updatedTransaction,\n        escrowBadge: updatedTransaction.getEscrowBadge()\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao desabilitar escrow:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /:id/escrow/status - Obter status detalhado do escrow\nrouter.get('/:id/escrow/status', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    // Buscar transaÃ§Ã£o\n    const transaction = await Transaction.findById(id)\n      .populate('buyerId', 'name email')\n      .populate('sellerId', 'name email')\n      .populate('itemId')\n      .populate('escrowTransactionId');\n\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Verificar permissÃµes\n    if (\n      transaction.buyerId._id.toString() !== userId &&\n      transaction.sellerId._id.toString() !== userId\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'Sem permissÃ£o para visualizar esta transaÃ§Ã£o'\n      });\n    }\n\n    // Verificar se escrow estÃ¡ habilitado\n    if (!transaction.usesEscrow) {\n      return res.status(400).json({\n        success: false,\n        message: 'Escrow nÃ£o estÃ¡ habilitado para esta transaÃ§Ã£o'\n      });\n    }\n\n    // Preparar dados de resposta\n    const escrowData = {\n      enabled: transaction.usesEscrow,\n      status: transaction.escrowStatus,\n      statusText: transaction.getEscrowStatusText(),\n      badge: transaction.getEscrowBadge(),\n      settings: transaction.escrowSettings,\n      timeRemaining: transaction.getTimeRemaining(),\n      isOverdue: transaction.isOverdue()\n    };\n\n    // Adicionar dados da transaÃ§Ã£o de escrow se existir\n    if (transaction.escrowTransactionId) {\n      escrowData.escrowTransaction = {\n        id: transaction.escrowTransactionId._id,\n        amount: transaction.escrowTransactionId.amount,\n        currency: transaction.escrowTransactionId.currency,\n        fee: transaction.escrowTransactionId.fee,\n        totalAmount: transaction.escrowTransactionId.totalAmount,\n        fundedAt: transaction.escrowTransactionId.fundedAt,\n        deliveredAt: transaction.escrowTransactionId.deliveredAt,\n        confirmedAt: transaction.escrowTransactionId.confirmedAt,\n        releasedAt: transaction.escrowTransactionId.releasedAt\n      };\n    }\n\n    res.json({\n      success: true,\n      data: escrowData\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao obter status do escrow:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /:id/messages - Buscar mensagens da transaÃ§Ã£o\nrouter.get('/:id/messages', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    const transaction = await Transaction.findById(id);\n\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem acesso a esta transaÃ§Ã£o\n    if (transaction.buyerId.toString() !== userId && transaction.sellerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado a esta transaÃ§Ã£o'\n      });\n    }\n\n    // Buscar mensagens da transaÃ§Ã£o\n    const messages = await TransactionMessage.findByTransaction(id, {\n      limit: 100,\n      sort: { createdAt: 1 }\n    });\n\n    // Marcar mensagens como lidas se o usuÃ¡rio for o destinatÃ¡rio\n    const unreadMessages = messages.filter(\n      msg => msg.to.toString() === userId && msg.status !== 'read'\n    );\n\n    if (unreadMessages.length > 0) {\n      await Promise.all(unreadMessages.map(msg => msg.markAsRead(userId)));\n    }\n\n    res.json({\n      success: true,\n      messages: messages.map(msg => msg.getDisplayData(userId)),\n      transactionId: id\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar mensagens:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /:id/messages - Adicionar mensagem Ã  transaÃ§Ã£o\nrouter.post('/:id/messages', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { message, attachments, type = 'text', metadata } = req.body;\n    const { userId } = req.user;\n\n    const transaction = await Transaction.findById(id);\n\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Verificar se o usuÃ¡rio tem acesso a esta transaÃ§Ã£o\n    if (transaction.buyerId.toString() !== userId && transaction.sellerId.toString() !== userId) {\n      return res.status(403).json({\n        success: false,\n        message: 'Acesso negado a esta transaÃ§Ã£o'\n      });\n    }\n\n    // Verificar se a transaÃ§Ã£o nÃ£o estÃ¡ cancelada ou concluÃ­da\n    if (['CANCELLED', 'COMPLETED'].includes(transaction.status)) {\n      return res.status(400).json({\n        success: false,\n        message: 'NÃ£o Ã© possÃ­vel enviar mensagens para transaÃ§Ãµes canceladas ou concluÃ­das'\n      });\n    }\n\n    // Se for a primeira mensagem e o status for PENDING, mudar para NEGOTIATING\n    if (transaction.status === 'PENDING') {\n      transaction.status = 'NEGOTIATING';\n      transaction.updatedBy = userId;\n      await transaction.save();\n    }\n\n    // Determinar destinatÃ¡rio\n    const toUserId =\n      transaction.buyerId.toString() === userId ? transaction.sellerId : transaction.buyerId;\n\n    // Criar mensagem\n    const newMessage = new TransactionMessage({\n      transactionId: id,\n      from: userId,\n      to: toUserId,\n      body: message,\n      type,\n      attachments: attachments || [],\n      metadata: metadata || {}\n    });\n\n    await newMessage.save();\n\n    // Marcar como entregue\n    await newMessage.markAsDelivered();\n\n    // Populate dados para resposta\n    await newMessage.populate([\n      { path: 'from', select: 'name email phone' },\n      { path: 'to', select: 'name email phone' }\n    ]);\n\n    res.json({\n      success: true,\n      message: 'Mensagem enviada com sucesso',\n      data: newMessage.getDisplayData(userId)\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao enviar mensagem:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /conversations - Buscar conversas ativas do usuÃ¡rio\nrouter.get('/conversations', async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { limit = 20 } = req.query;\n\n    // Buscar conversas ativas\n    const conversations = await TransactionMessage.findActiveConversations(\n      userId,\n      parseInt(limit, 10, 10)\n    );\n\n    res.json({\n      success: true,\n      conversations: conversations.map(conv => ({\n        transactionId: conv._id,\n        transaction: conv.transaction,\n        lastMessage: conv.lastMessage,\n        messageCount: conv.messageCount,\n        unreadCount: conv.unreadCount,\n        fromUser: conv.fromUser,\n        toUser: conv.toUser\n      }))\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar conversas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /stats - EstatÃ­sticas das transaÃ§Ãµes\nrouter.get('/stats', async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    // EstatÃ­sticas gerais\n    const totalTransactions = await Transaction.countDocuments({\n      $or: [{ buyerId: userId }, { sellerId: userId }]\n    });\n\n    const pendingTransactions = await Transaction.countDocuments({\n      $or: [{ buyerId: userId }, { sellerId: userId }],\n      status: 'PENDING'\n    });\n\n    const negotiatingTransactions = await Transaction.countDocuments({\n      $or: [{ buyerId: userId }, { sellerId: userId }],\n      status: 'NEGOTIATING'\n    });\n\n    const completedTransactions = await Transaction.countDocuments({\n      $or: [{ buyerId: userId }, { sellerId: userId }],\n      status: 'COMPLETED'\n    });\n\n    // Valor total das transaÃ§Ãµes\n    const totalValue = await Transaction.aggregate([\n      {\n        $match: {\n          $or: [{ buyerId: userId }, { sellerId: userId }],\n          status: { $in: ['COMPLETED', 'AGREED'] }\n        }\n      },\n      {\n        $group: {\n          _id: null,\n          total: { $sum: '$total' }\n        }\n      }\n    ]);\n\n    res.json({\n      success: true,\n      stats: {\n        total: totalTransactions,\n        pending: pendingTransactions,\n        negotiating: negotiatingTransactions,\n        completed: completedTransactions,\n        totalValue: totalValue[0]?.total || 0\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar estatÃ­sticas:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// ===== ROTAS ADMIN =====\n\n// GET /admin/all - Listar todas as transaÃ§Ãµes (admin only)\nrouter.get('/admin/all', requireRole('admin'), async (req, res) => {\n  try {\n    const { page = 1, limit = 50, status, type } = req.query;\n\n    const filters = {};\n    if (status) {\n      filters.status = status;\n    }\n    if (type) {\n      filters.type = type;\n    }\n\n    const skip = (page - 1) * limit;\n\n    const transactions = await Transaction.find(filters)\n      .populate('buyerId', 'name email phone')\n      .populate('sellerId', 'name email phone')\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10));\n\n    const total = await Transaction.countDocuments(filters);\n\n    res.json({\n      success: true,\n      data: {\n        transactions,\n        pagination: {\n          page: parseInt(page, 10, 10),\n          limit: parseInt(limit, 10, 10),\n          total,\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Console log removido:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// PATCH /admin/:id/status - Atualizar status como admin\nrouter.patch('/admin/:id/status', requireRole('admin'), async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { status, notes } = req.body;\n\n    const transaction = await Transaction.findById(id);\n\n    if (!transaction) {\n      return res.status(404).json({\n        success: false,\n        message: 'TransaÃ§Ã£o nÃ£o encontrada'\n      });\n    }\n\n    // Admin pode mudar para qualquer status\n    transaction.status = status;\n    transaction.notes.admin = notes || '';\n    transaction.updatedBy = req.user.userId;\n\n    await transaction.save();\n\n    await transaction.populate([\n      { path: 'buyerId', select: 'name email phone' },\n      { path: 'sellerId', select: 'name email phone' }\n    ]);\n\n    res.json({\n      success: true,\n      message: 'Status atualizado com sucesso (admin)',\n      transaction\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Console log removido:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\upload.js",
    "messages": [
      {
        "ruleId": "prefer-template",
        "severity": 2,
        "message": "Unexpected string concatenation.",
        "line": 25,
        "column": 26,
        "nodeType": "BinaryExpression",
        "messageId": "unexpectedStringConcatenation",
        "endLine": 25,
        "endColumn": 76,
        "fix": {
          "range": [696, 746],
          "text": "`${Date.now()  }-${  Math.round(Math.random() * 1e9)}`"
        }
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 44,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 44,
        "endColumn": 19
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 46,
        "column": 5,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 46,
        "endColumn": 93
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 51,
        "column": 3,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 51,
        "endColumn": 19,
        "fix": { "range": [1324, 1340], "text": "storage" }
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 55,
        "column": 3,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 55,
        "endColumn": 25,
        "fix": { "range": [1400, 1422], "text": "fileFilter" }
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 115,
        "column": 9,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 115,
        "endColumn": 27,
        "fix": { "range": [3138, 3156], "text": "localUrl" }
      },
      {
        "ruleId": "object-shorthand",
        "severity": 2,
        "message": "Expected property shorthand.",
        "line": 116,
        "column": 9,
        "nodeType": "Property",
        "messageId": "expectedPropertyShorthand",
        "endLine": 116,
        "endColumn": 37,
        "fix": { "range": [3166, 3194], "text": "cloudinaryUrl" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 5,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport multer from 'multer';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport fs from 'fs';\n\nimport logger from '../utils/logger.js';\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst router = express.Router();\n\n// Criar diretÃ³rio de uploads se nÃ£o existir\nconst uploadsDir = path.join(__dirname, '../../uploads');\nif (!fs.existsSync(uploadsDir)) {\n  fs.mkdirSync(uploadsDir, { recursive: true });\n}\n\n// ConfiguraÃ§Ã£o do Multer\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    cb(null, uploadsDir);\n  },\n  filename: (req, file, cb) => {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);\n    const ext = path.extname(file.originalname);\n    const name = path.basename(file.originalname, ext);\n    cb(null, `${name}-${uniqueSuffix}${ext}`);\n  }\n});\n\n// Filtro de tipos de arquivo\nconst fileFilter = (req, file, cb) => {\n  const allowedTypes = [\n    'image/jpeg',\n    'image/jpg',\n    'image/png',\n    'image/gif',\n    'image/webp',\n    'application/pdf'\n  ];\n\n  if (allowedTypes.includes(file.mimetype)) {\n    cb(null, true);\n  } else {\n    cb(new Error('Tipo de arquivo nÃ£o permitido. Use JPEG, PNG, GIF, WEBP ou PDF.'), false);\n  }\n};\n\nconst upload = multer({\n  storage: storage,\n  limits: {\n    fileSize: 10 * 1024 * 1024 // 10MB\n  },\n  fileFilter: fileFilter\n});\n\n// ===== ROTAS =====\n\n// Health check\nrouter.get('/', (_req, res) => {\n  res.json({\n    message: 'Upload service',\n    status: 'operational',\n    cloudinaryConfigured: !!process.env.CLOUDINARY_CLOUD_NAME\n  });\n});\n\n// Upload single file\nrouter.post('/single', upload.single('file'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhum arquivo enviado'\n      });\n    }\n\n    // Se Cloudinary estiver configurado, fazer upload para lÃ¡ tambÃ©m\n    let cloudinaryUrl = null;\n    if (process.env.CLOUDINARY_CLOUD_NAME && process.env.CLOUDINARY_API_KEY) {\n      try {\n        const cloudinary = require('cloudinary').v2;\n        cloudinary.config({\n          cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n          api_key: process.env.CLOUDINARY_API_KEY,\n          api_secret: process.env.CLOUDINARY_API_SECRET\n        });\n\n        const result = await cloudinary.uploader.upload(req.file.path, {\n          folder: 'agroisync',\n          resource_type: 'auto'\n        });\n\n        cloudinaryUrl = result.secure_url;\n      } catch (cloudinaryError) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('Erro ao fazer upload para Cloudinary:', cloudinaryError);\n        }\n        // Continuar mesmo se Cloudinary falhar\n      }\n    }\n\n    // Retornar URL local (sempre) e Cloudinary (se disponÃ­vel)\n    const localUrl = `/uploads/${req.file.filename}`;\n\n    res.json({\n      success: true,\n      message: 'Arquivo enviado com sucesso',\n      data: {\n        filename: req.file.filename,\n        originalName: req.file.originalname,\n        mimetype: req.file.mimetype,\n        size: req.file.size,\n        localUrl: localUrl,\n        cloudinaryUrl: cloudinaryUrl,\n        url: cloudinaryUrl || localUrl // Priorizar Cloudinary se disponÃ­vel\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no upload:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao fazer upload do arquivo',\n      error: error.message\n    });\n  }\n});\n\n// Upload multiple files\nrouter.post('/multiple', upload.array('files', 10), (req, res) => {\n  try {\n    if (!req.files || req.files.length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhum arquivo enviado'\n      });\n    }\n\n    const uploadedFiles = req.files.map(file => ({\n      filename: file.filename,\n      originalName: file.originalname,\n      mimetype: file.mimetype,\n      size: file.size,\n      url: `/uploads/${file.filename}`\n    }));\n\n    res.json({\n      success: true,\n      message: `${req.files.length} arquivo(s) enviado(s) com sucesso`,\n      data: uploadedFiles\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro no upload mÃºltiplo:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao fazer upload dos arquivos',\n      error: error.message\n    });\n  }\n});\n\n// Deletar arquivo\nrouter.delete('/:filename', (req, res) => {\n  try {\n    const { filename } = req.params;\n    const filePath = path.join(uploadsDir, filename);\n\n    if (!fs.existsSync(filePath)) {\n      return res.status(404).json({\n        success: false,\n        message: 'Arquivo nÃ£o encontrado'\n      });\n    }\n\n    fs.unlinkSync(filePath);\n\n    res.json({\n      success: true,\n      message: 'Arquivo deletado com sucesso'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao deletar arquivo:', error);\n    }\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao deletar arquivo',\n      error: error.message\n    });\n  }\n});\n\n// Servir arquivos estÃ¡ticos\nrouter.use('/files', express.static(uploadsDir));\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\userDashboard.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\users.js",
    "messages": [
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 16 spaces but found 18.",
        "line": 262,
        "column": 1,
        "nodeType": "Punctuator",
        "messageId": "wrongIndentation",
        "endLine": 262,
        "endColumn": 19,
        "fix": { "range": [7308, 7326], "text": "                " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 14 spaces but found 16.",
        "line": 263,
        "column": 1,
        "nodeType": "Punctuator",
        "messageId": "wrongIndentation",
        "endLine": 263,
        "endColumn": 17,
        "fix": { "range": [7408, 7424], "text": "              " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 16 spaces but found 18.",
        "line": 279,
        "column": 1,
        "nodeType": "Punctuator",
        "messageId": "wrongIndentation",
        "endLine": 279,
        "endColumn": 19,
        "fix": { "range": [8107, 8125], "text": "                " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 14 spaces but found 16.",
        "line": 281,
        "column": 1,
        "nodeType": "Punctuator",
        "messageId": "wrongIndentation",
        "endLine": 281,
        "endColumn": 17,
        "fix": { "range": [8229, 8245], "text": "              " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 4,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport User from '../models/User.js';\nimport SecurityLog from '../models/SecurityLog.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\nimport { getClientIP } from '../utils/ipUtils.js';\n\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// Helper function to create security log\nconst createSecurityLog = async (\n  eventType,\n  severity,\n  description,\n  req,\n  userId,\n  additionalData = {}\n) => {\n  try {\n    await SecurityLog.create({\n      eventType,\n      severity,\n      description,\n      userId,\n      ipAddress: getClientIP(req),\n      userAgent: req.get('User-Agent'),\n      requestMethod: req.method,\n      requestUrl: req.originalUrl,\n      requestHeaders: req.headers,\n      geolocation: {\n        country: req.headers['cf-ipcountry'] || 'Unknown',\n        region: req.headers['cf-ipregion'] || 'Unknown',\n        city: req.headers['cf-ipcity'] || 'Unknown'\n      },\n      cloudflare: {\n        rayId: req.headers['cf-ray'] || null,\n        country: req.headers['cf-ipcountry'] || null,\n        threatScore: parseInt(req.headers['cf-threat-score'], 10, 10) || 0,\n        botScore: parseInt(req.headers['cf-bot-score'], 10, 10) || 0\n      },\n      details: additionalData\n    });\n  } catch {\n    // Error creating security log\n  }\n};\n\n// GET /api/v1/users/profile - Get user profile\nrouter.get('/profile', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const user = await User.findById(userId).select('-password -securityLogs').lean();\n\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Create security log\n    await createSecurityLog('data_access', 'low', 'User profile accessed', req, userId);\n\n    res.json({\n      success: true,\n      data: {\n        user: {\n          id: user._id,\n          name: user.name,\n          email: user.email,\n          phone: user.phone,\n          userType: user.userType,\n          company: user.company,\n          isActive: user.isActive,\n          isVerified: user.isVerified,\n          subscriptions: user.subscriptions,\n          lastLogin: user.lastLogin,\n          createdAt: user.createdAt,\n          updatedAt: user.updatedAt\n        }\n      }\n    });\n  } catch (error) {\n    // Get profile error\n\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Get profile error: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter perfil'\n    });\n  }\n});\n\n// PUT /api/v1/users/profile - Update user profile\nrouter.put('/profile', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { name, phone, company } = req.body;\n\n    // Validate input\n    if (name && (name.length < 2 || name.length > 100)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nome deve ter entre 2 e 100 caracteres'\n      });\n    }\n\n    if (phone && !/^[+]?[1-9][\\d]{0,15}$/.test(phone)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Telefone invÃ¡lido'\n      });\n    }\n\n    // Update user profile\n    const updateData = {};\n    if (name) {\n      updateData.name = name.trim();\n    }\n    if (phone) {\n      updateData.phone = phone.trim();\n    }\n    if (company) {\n      if (company.name && company.name.length >= 2 && company.name.length <= 100) {\n        updateData['company.name'] = company.name.trim();\n      }\n      if (company.cnpj && /^\\d{14}$/.test(company.cnpj)) {\n        updateData['company.cnpj'] = company.cnpj.trim();\n      }\n      if (company.address) {\n        if (\n          company.address.street &&\n          company.address.street.length >= 5 &&\n          company.address.street.length <= 200\n        ) {\n          updateData['company.address.street'] = company.address.street.trim();\n        }\n        if (\n          company.address.city &&\n          company.address.city.length >= 2 &&\n          company.address.city.length <= 100\n        ) {\n          updateData['company.address.city'] = company.address.city.trim();\n        }\n        if (company.address.state && company.address.state.length === 2) {\n          updateData['company.address.state'] = company.address.state.trim();\n        }\n        if (company.address.zipCode && /^\\d{5}-?\\d{3}$/.test(company.address.zipCode)) {\n          updateData['company.address.zipCode'] = company.address.zipCode.trim();\n        }\n      }\n    }\n\n    if (Object.keys(updateData).length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhum dado vÃ¡lido para atualizar'\n      });\n    }\n\n    const user = await User.findByIdAndUpdate(\n      userId,\n      { $set: updateData },\n      { new: true, runValidators: true }\n    ).select('-password -securityLogs');\n\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Create security log\n    await createSecurityLog('data_modification', 'medium', 'User profile updated', req, userId, {\n      updatedFields: Object.keys(updateData)\n    });\n\n    res.json({\n      success: true,\n      message: 'Perfil atualizado com sucesso',\n      data: {\n        user: {\n          id: user._id,\n          name: user.name,\n          email: user.email,\n          phone: user.phone,\n          userType: user.userType,\n          company: user.company,\n          isActive: user.isActive,\n          isVerified: user.isVerified,\n          subscriptions: user.subscriptions,\n          lastLogin: user.lastLogin,\n          createdAt: user.createdAt,\n          updatedAt: user.updatedAt\n        }\n      }\n    });\n  } catch (error) {\n    // Update profile error\n\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Update profile error: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao atualizar perfil'\n    });\n  }\n});\n\n// GET /api/v1/users/subscriptions - Get user subscriptions\nrouter.get('/subscriptions', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n\n    const user = await User.findById(userId).select('subscriptions').lean();\n\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Create security log\n    await createSecurityLog('data_access', 'low', 'User subscriptions accessed', req, userId);\n\n    res.json({\n      success: true,\n      data: {\n        subscriptions: user.subscriptions,\n        summary: {\n          store: {\n            hasActivePlan: user.subscriptions.store.status === 'active',\n            planName: user.subscriptions.store.plan,\n            maxAds: user.subscriptions.store.maxAds,\n            currentAds: user.subscriptions.store.currentAds,\n            remainingAds: Math.max(\n              0,\n              user.subscriptions.store.maxAds - user.subscriptions.store.currentAds\n            ),\n            /* eslint-disable prettier/prettier */\n            daysRemaining: user.subscriptions.store.endDate\n              ? Math.ceil(\n                  (new Date(user.subscriptions.store.endDate) - new Date()) / (1000 * 60 * 60 * 24)\n                )\n              : 0\n            /* eslint-enable prettier/prettier */\n          },\n          freight: {\n            hasActivePlan: user.subscriptions.freight.status === 'active',\n            planName: user.subscriptions.freight.plan,\n            maxFreights: user.subscriptions.freight.maxFreights,\n            currentFreights: user.subscriptions.freight.currentFreights,\n            remainingFreights: Math.max(\n              0,\n              user.subscriptions.freight.maxFreights - user.subscriptions.freight.currentFreights\n            ),\n            /* eslint-disable prettier/prettier */\n            daysRemaining: user.subscriptions.freight.endDate\n              ? Math.ceil(\n                  (new Date(user.subscriptions.freight.endDate) - new Date()) /\n                    (1000 * 60 * 60 * 24)\n                )\n              : 0\n            /* eslint-enable prettier/prettier */\n          }\n        }\n      }\n    });\n  } catch (error) {\n    // Get subscriptions error\n\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Get subscriptions error: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao obter assinaturas'\n    });\n  }\n});\n\n// PUT /api/v1/users/subscriptions - Update subscription preferences\nrouter.put('/subscriptions', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { store, freight } = req.body;\n\n    const updateData = {};\n\n    // Update store subscription preferences\n    if (store) {\n      if (store.notifications !== undefined) {\n        updateData['subscriptions.store.notifications'] = store.notifications;\n      }\n      if (store.autoRenew !== undefined) {\n        updateData['subscriptions.store.autoRenew'] = store.autoRenew;\n      }\n    }\n\n    // Update freight subscription preferences\n    if (freight) {\n      if (freight.notifications !== undefined) {\n        updateData['subscriptions.freight.notifications'] = freight.notifications;\n      }\n      if (freight.autoRenew !== undefined) {\n        updateData['subscriptions.freight.autoRenew'] = freight.autoRenew;\n      }\n    }\n\n    if (Object.keys(updateData).length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nenhuma preferÃªncia vÃ¡lida para atualizar'\n      });\n    }\n\n    const user = await User.findByIdAndUpdate(\n      userId,\n      { $set: updateData },\n      { new: true, runValidators: true }\n    ).select('subscriptions');\n\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    // Create security log\n    await createSecurityLog(\n      'data_modification',\n      'low',\n      'User subscription preferences updated',\n      req,\n      userId,\n      { updatedFields: Object.keys(updateData) }\n    );\n\n    res.json({\n      success: true,\n      message: 'PreferÃªncias de assinatura atualizadas com sucesso',\n      data: {\n        subscriptions: user.subscriptions\n      }\n    });\n  } catch (error) {\n    // Update subscriptions error\n\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Update subscriptions error: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao atualizar preferÃªncias de assinatura'\n    });\n  }\n});\n\n// DELETE /api/v1/users/account - Delete user account\nrouter.delete('/account', authenticateToken, async (req, res) => {\n  try {\n    const { userId } = req.user;\n    const { password, reason } = req.body;\n\n    if (!password) {\n      return res.status(400).json({\n        success: false,\n        message: 'Senha Ã© obrigatÃ³ria para deletar a conta'\n      });\n    }\n\n    // Verify password\n    const user = await User.findById(userId);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'UsuÃ¡rio nÃ£o encontrado'\n      });\n    }\n\n    const isValidPassword = await user.comparePassword(password);\n    if (!isValidPassword) {\n      await createSecurityLog(\n        'suspicious_activity',\n        'medium',\n        'Failed account deletion attempt - invalid password',\n        req,\n        userId\n      );\n\n      return res.status(401).json({\n        success: false,\n        message: 'Senha incorreta'\n      });\n    }\n\n    // Soft delete - mark as inactive instead of actually deleting\n    user.isActive = false;\n    user.deletedAt = new Date();\n    user.deletionReason = reason || 'User requested deletion';\n    await user.save();\n\n    // Create security log\n    await createSecurityLog('data_modification', 'high', 'User account deactivated', req, userId, {\n      reason: reason || 'User requested deletion'\n    });\n\n    res.json({\n      success: true,\n      message:\n        'Conta desativada com sucesso. VocÃª pode reativÃ¡-la entrando em contato com o suporte.',\n      data: {\n        deactivatedAt: user.deletedAt,\n        reason: user.deletionReason\n      }\n    });\n  } catch (error) {\n    // Delete account error\n\n    await createSecurityLog(\n      'system_error',\n      'high',\n      `Delete account error: ${error.message}`,\n      req,\n      req.user?.userId\n    );\n\n    res.status(500).json({\n      success: false,\n      message: 'Erro ao deletar conta'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\validation.js",
    "messages": [
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 47,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 47,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [1134, 1134], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 52,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 52,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [1285, 1285], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 63,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 63,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [1565, 1565], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 68,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 68,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [1713, 1713], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 129,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 129,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [3104, 3104], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 135,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 135,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [3299, 3299], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 147,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 147,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [3597, 3597], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 153,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 153,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [3788, 3788], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport axios from 'axios';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// POST /api/validation/cpf - Validar CPF\nrouter.post('/cpf', (req, res) => {\n  try {\n    const { cpf } = req.body;\n\n    if (!cpf) {\n      return res.status(400).json({\n        success: false,\n        error: 'CPF Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Remove caracteres nÃ£o numÃ©ricos\n    const cleanCpf = cpf.replace(/[^\\d]/g, '');\n\n    // Verifica se tem 11 dÃ­gitos\n    if (cleanCpf.length !== 11) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CPF deve ter 11 dÃ­gitos'\n      });\n    }\n\n    // Verifica se todos os dÃ­gitos sÃ£o iguais\n    if (/^(\\d)\\1{10}$/.test(cleanCpf)) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CPF invÃ¡lido'\n      });\n    }\n\n    // ValidaÃ§Ã£o do primeiro dÃ­gito verificador\n    let sum = 0;\n    for (let i = 0; i < 9; i++) {\n      sum += parseInt(cleanCpf.charAt(i, 10, 10)) * (10 - i);\n    }\n    let remainder = 11 - (sum % 11);\n    const digit1 = remainder < 2 ? 0 : remainder;\n\n    if (parseInt(cleanCpf.charAt(9, 10, 10)) !== digit1) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CPF invÃ¡lido'\n      });\n    }\n\n    // ValidaÃ§Ã£o do segundo dÃ­gito verificador\n    sum = 0;\n    for (let i = 0; i < 10; i++) {\n      sum += parseInt(cleanCpf.charAt(i, 10, 10)) * (11 - i);\n    }\n    remainder = 11 - (sum % 11);\n    const digit2 = remainder < 2 ? 0 : remainder;\n\n    if (parseInt(cleanCpf.charAt(10, 10, 10)) !== digit2) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CPF invÃ¡lido'\n      });\n    }\n\n    res.json({\n      success: true,\n      valid: true,\n      message: 'CPF vÃ¡lido'\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao validar CPF:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/validation/cnpj - Validar CNPJ\nrouter.post('/cnpj', async (req, res) => {\n  try {\n    const { cnpj } = req.body;\n\n    if (!cnpj) {\n      return res.status(400).json({\n        success: false,\n        error: 'CNPJ Ã© obrigatÃ³rio'\n      });\n    }\n\n    // Remove caracteres nÃ£o numÃ©ricos\n    const cleanCnpj = cnpj.replace(/[^\\d]/g, '');\n\n    // Verifica se tem 14 dÃ­gitos\n    if (cleanCnpj.length !== 14) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CNPJ deve ter 14 dÃ­gitos'\n      });\n    }\n\n    // Verifica se todos os dÃ­gitos sÃ£o iguais\n    if (/^(\\d)\\1{13}$/.test(cleanCnpj)) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CNPJ invÃ¡lido'\n      });\n    }\n\n    // ValidaÃ§Ã£o do primeiro dÃ­gito verificador\n    let sum = 0;\n    let weight = 5;\n    for (let i = 0; i < 12; i++) {\n      sum += parseInt(cleanCnpj.charAt(i, 10, 10)) * weight;\n      weight = weight === 2 ? 9 : weight - 1;\n    }\n    let remainder = sum % 11;\n    const digit1 = remainder < 2 ? 0 : 11 - remainder;\n\n    if (parseInt(cleanCnpj.charAt(12, 10, 10)) !== digit1) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CNPJ invÃ¡lido'\n      });\n    }\n\n    // ValidaÃ§Ã£o do segundo dÃ­gito verificador\n    sum = 0;\n    weight = 6;\n    for (let i = 0; i < 13; i++) {\n      sum += parseInt(cleanCnpj.charAt(i, 10, 10)) * weight;\n      weight = weight === 2 ? 9 : weight - 1;\n    }\n    remainder = sum % 11;\n    const digit2 = remainder < 2 ? 0 : 11 - remainder;\n\n    if (parseInt(cleanCnpj.charAt(13, 10, 10)) !== digit2) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CNPJ invÃ¡lido'\n      });\n    }\n\n    // Buscar dados na Receita Federal\n    try {\n      const response = await axios.get(`https://www.receitaws.com.br/v1/cnpj/${cleanCnpj}`);\n      const { data } = response;\n\n      res.json({\n        success: true,\n        valid: true,\n        message: 'CNPJ vÃ¡lido',\n        data: {\n          company: data.nome,\n          fantasy: data.fantasia,\n          address: data.logradouro,\n          city: data.municipio,\n          state: data.uf,\n          zipCode: data.cep,\n          phone: data.telefone,\n          email: data.email,\n          status: data.status\n        }\n      });\n    } catch (apiError) {\n      // Se a API da Receita falhar, retorna apenas validaÃ§Ã£o bÃ¡sica\n      res.json({\n        success: true,\n        valid: true,\n        message: 'CNPJ vÃ¡lido (dados nÃ£o disponÃ­veis)'\n      });\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao validar CNPJ:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/validation/cep - Buscar CEP\nrouter.post('/cep', async (req, res) => {\n  try {\n    const { cep } = req.body;\n\n    if (!cep) {\n      return res.status(400).json({\n        success: false,\n        error: 'CEP Ã© obrigatÃ³rio'\n      });\n    }\n\n    const cleanCep = cep.replace(/[^\\d]/g, '');\n\n    if (cleanCep.length !== 8) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'CEP deve ter 8 dÃ­gitos'\n      });\n    }\n\n    try {\n      const response = await axios.get(`https://viacep.com.br/ws/${cleanCep}/json/`);\n      const { data } = response;\n\n      if (data.erro) {\n        return res.json({\n          success: false,\n          valid: false,\n          error: 'CEP nÃ£o encontrado'\n        });\n      }\n\n      res.json({\n        success: true,\n        valid: true,\n        data: {\n          zipCode: data.cep,\n          address: data.logradouro,\n          neighborhood: data.bairro,\n          city: data.localidade,\n          state: data.uf,\n          ibge: data.ibge,\n          gia: data.gia,\n          ddd: data.ddd,\n          siafi: data.siafi\n        }\n      });\n    } catch (apiError) {\n      res.json({\n        success: false,\n        valid: false,\n        error: 'Erro ao buscar CEP'\n      });\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar CEP:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/validation/plate - Validar placa de veÃ­culo\nrouter.post('/plate', (req, res) => {\n  try {\n    const { plate } = req.body;\n\n    if (!plate) {\n      return res.status(400).json({\n        success: false,\n        error: 'Placa Ã© obrigatÃ³ria'\n      });\n    }\n\n    const cleanPlate = plate.replace(/[^A-Z0-9]/g, '').toUpperCase();\n\n    // Validar formato antigo (ABC-1234) ou novo (ABC1D23)\n    const oldFormat = /^[A-Z]{3}[0-9]{4}$/;\n    const newFormat = /^[A-Z]{3}[0-9][A-Z][0-9]{2}$/;\n\n    if (!oldFormat.test(cleanPlate) && !newFormat.test(cleanPlate)) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'Formato de placa invÃ¡lido'\n      });\n    }\n\n    res.json({\n      success: true,\n      valid: true,\n      message: 'Placa vÃ¡lida',\n      data: {\n        plate: cleanPlate,\n        format: oldFormat.test(cleanPlate) ? 'antigo' : 'novo'\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao validar placa:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/validation/phone - Validar telefone\nrouter.post('/phone', (req, res) => {\n  try {\n    const { phone } = req.body;\n\n    if (!phone) {\n      return res.status(400).json({\n        success: false,\n        error: 'Telefone Ã© obrigatÃ³rio'\n      });\n    }\n\n    const cleanPhone = phone.replace(/[^\\d]/g, '');\n\n    // Validar formato brasileiro (10 ou 11 dÃ­gitos)\n    if (cleanPhone.length < 10 || cleanPhone.length > 11) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'Telefone deve ter 10 ou 11 dÃ­gitos'\n      });\n    }\n\n    // Verificar se comeÃ§a com DDD vÃ¡lido\n    const ddd = cleanPhone.substring(0, 2);\n    const validDdds = [\n      '11',\n      '12',\n      '13',\n      '14',\n      '15',\n      '16',\n      '17',\n      '18',\n      '19', // SP\n      '21',\n      '22',\n      '24', // RJ\n      '27',\n      '28', // ES\n      '31',\n      '32',\n      '33',\n      '34',\n      '35',\n      '37',\n      '38', // MG\n      '41',\n      '42',\n      '43',\n      '44',\n      '45',\n      '46', // PR\n      '47',\n      '48',\n      '49', // SC\n      '51',\n      '53',\n      '54',\n      '55', // RS\n      '61', // DF\n      '62',\n      '64', // GO\n      '63', // TO\n      '65',\n      '66', // MT\n      '67', // MS\n      '68', // AC\n      '69', // RO\n      '71',\n      '73',\n      '74',\n      '75',\n      '77', // BA\n      '79', // SE\n      '81',\n      '87', // PE\n      '82', // AL\n      '83', // PB\n      '84', // RN\n      '85',\n      '88', // CE\n      '86',\n      '89', // PI\n      '91',\n      '93',\n      '94', // PA\n      '92',\n      '97', // AM\n      '95', // RR\n      '96', // AP\n      '98',\n      '99' // MA\n    ];\n\n    if (!validDdds.includes(ddd)) {\n      return res.json({\n        success: false,\n        valid: false,\n        error: 'DDD invÃ¡lido'\n      });\n    }\n\n    res.json({\n      success: true,\n      valid: true,\n      message: 'Telefone vÃ¡lido',\n      data: {\n        phone: cleanPhone,\n        ddd,\n        type: cleanPhone.length === 11 ? 'celular' : 'fixo'\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao validar telefone:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\visibility.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'User' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import express from 'express';\nimport Product from '../models/Product.js';\nimport Freight from '../models/Freight.js';\nimport Payment from '../models/Payment.js';\nimport User from '../models/User.js';\nimport { authenticateToken } from '../middleware/auth.js';\nimport { apiLimiter } from '../middleware/rateLimiter.js';\n\nimport logger from '../utils/logger.js';\nconst router = express.Router();\n\n// Apply rate limiting\nrouter.use(apiLimiter);\n\n// GET /api/visibility/products/public - Listar produtos com dados pÃºblicos apenas\nrouter.get('/products/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, category, location } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = { status: 'active' };\n    if (category) {\n      query.category = category;\n    }\n    if (location) {\n      query.location = { $regex: location, $options: 'i' };\n    }\n\n    const products = await Product.find(query)\n      .select('name location category image createdAt')\n      .populate('owner', 'name company')\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .sort({ createdAt: -1 });\n\n    const total = await Product.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: products,\n      pagination: {\n        page: parseInt(page, 10, 10),\n        limit: parseInt(limit, 10, 10),\n        total,\n        pages: Math.ceil(total / parseInt(limit, 10, 10))\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar produtos pÃºblicos:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/visibility/freights/public - Listar fretes com dados pÃºblicos apenas\nrouter.get('/freights/public', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, origin, destination } = req.query;\n    const skip = (parseInt(page, 10, 10) - 1) * parseInt(limit, 10, 10);\n\n    const query = { status: 'active' };\n    if (origin) {\n      query.origin = { $regex: origin, $options: 'i' };\n    }\n    if (destination) {\n      query.destination = { $regex: destination, $options: 'i' };\n    }\n\n    const freights = await Freight.find(query)\n      .select('origin destination value vehicleType createdAt')\n      .populate('owner', 'name company')\n      .skip(skip)\n      .limit(parseInt(limit, 10, 10))\n      .sort({ createdAt: -1 });\n\n    const total = await Freight.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: freights,\n      pagination: {\n        page: parseInt(page, 10, 10),\n        limit: parseInt(limit, 10, 10),\n        total,\n        pages: Math.ceil(total / parseInt(limit, 10, 10))\n      }\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar fretes pÃºblicos:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/visibility/products/:id/full - Obter dados completos do produto (apÃ³s pagamento)\nrouter.get('/products/:id/full', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    // Verificar se o usuÃ¡rio pagou para ver os dados completos\n    const payment = await Payment.findOne({\n      userId,\n      itemId: id,\n      itemType: 'product',\n      status: 'completed'\n    });\n\n    if (!payment) {\n      return res.status(403).json({\n        success: false,\n        message: 'Pagamento necessÃ¡rio para acessar dados completos',\n        paymentRequired: true,\n        amount: 29.9 // PreÃ§o para liberar dados do produto\n      });\n    }\n\n    const product = await Product.findById(id).populate(\n      'owner',\n      'name email phone company cnpj ie address city state'\n    );\n\n    if (!product) {\n      return res.status(404).json({\n        success: false,\n        error: 'Produto nÃ£o encontrado'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: product\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar dados completos do produto:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// GET /api/visibility/freights/:id/full - Obter dados completos do frete (apÃ³s pagamento)\nrouter.get('/freights/:id/full', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { userId } = req.user;\n\n    // Verificar se o usuÃ¡rio pagou para ver os dados completos\n    const payment = await Payment.findOne({\n      userId,\n      itemId: id,\n      itemType: 'freight',\n      status: 'completed'\n    });\n\n    if (!payment) {\n      return res.status(403).json({\n        success: false,\n        message: 'Pagamento necessÃ¡rio para acessar dados completos',\n        paymentRequired: true,\n        amount: 19.9 // PreÃ§o para liberar dados do frete\n      });\n    }\n\n    const freight = await Freight.findById(id).populate(\n      'owner',\n      'name email phone company cnpj ie address city state'\n    );\n\n    if (!freight) {\n      return res.status(404).json({\n        success: false,\n        error: 'Frete nÃ£o encontrado'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: freight\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao buscar dados completos do frete:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\n// POST /api/visibility/unlock - Liberar dados apÃ³s pagamento\nrouter.post('/unlock', authenticateToken, async (req, res) => {\n  try {\n    const { itemId, itemType, paymentMethod } = req.body;\n    const { userId } = req.user;\n\n    // Verificar se jÃ¡ existe pagamento\n    const existingPayment = await Payment.findOne({\n      userId,\n      itemId,\n      itemType,\n      status: 'completed'\n    });\n\n    if (existingPayment) {\n      return res.json({\n        success: true,\n        message: 'Dados jÃ¡ liberados',\n        paymentId: existingPayment._id\n      });\n    }\n\n    // Criar novo pagamento\n    const amount = itemType === 'product' ? 29.9 : 19.9;\n\n    const payment = new Payment({\n      userId,\n      itemId,\n      itemType,\n      amount,\n      paymentMethod,\n      status: 'pending',\n      purpose: 'unlock_data'\n    });\n\n    await payment.save();\n\n    // Simular confirmaÃ§Ã£o de pagamento (em produÃ§Ã£o, seria confirmado pelo gateway)\n    payment.status = 'completed';\n    await payment.save();\n\n    res.json({\n      success: true,\n      message: 'Dados liberados com sucesso',\n      paymentId: payment._id\n    });\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Erro ao liberar dados:', error);\n    }\n    res.status(500).json({\n      success: false,\n      error: 'Erro interno do servidor'\n    });\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\routes\\weather.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\scripts\\create-admin-user.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\addressValidationService.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'state' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 168,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 168,
        "endColumn": 51
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿import axios from 'axios';\nimport logger from '../utils/logger.js';\n\nclass AddressValidationService {\n  constructor() {\n    this.apiKeys = {\n      correios: process.env.CORREIOS_API_KEY,\n      baidu: process.env.BAIDU_MAPS_API_KEY,\n      google: process.env.GOOGLE_PLACES_API_KEY\n    };\n  }\n\n  /**\n   * Validar endereÃ§o brasileiro usando API dos Correios\n   */\n  async validateBrazilianAddress(zipCode) {\n    try {\n      if (!zipCode || zipCode.length !== 8) {\n        throw new Error('CEP invÃ¡lido');\n      }\n\n      // API dos Correios (ViaCEP como fallback)\n      const response = await axios.get(`https://viacep.com.br/ws/${zipCode}/json/`, {\n        timeout: 5000\n      });\n\n      if (response.data.erro) {\n        throw new Error('CEP nÃ£o encontrado');\n      }\n\n      const address = response.data;\n\n      return {\n        isValid: true,\n        country: 'BR',\n        address: {\n          street: address.logradouro,\n          neighborhood: address.bairro,\n          city: address.localidade,\n          state: address.uf,\n          zipCode: address.cep,\n          country: 'Brasil',\n          coordinates: null // ViaCEP nÃ£o fornece coordenadas\n        },\n        source: 'viacep'\n      };\n    } catch (error) {\n      logger.error('Erro na validaÃ§Ã£o de endereÃ§o brasileiro:', error);\n      return {\n        isValid: false,\n        error: error.message,\n        country: 'BR'\n      };\n    }\n  }\n\n  /**\n   * Validar endereÃ§o chinÃªs usando Baidu Maps API\n   */\n  async validateChineseAddress(address, city, province) {\n    try {\n      if (!this.apiKeys.baidu) {\n        logger.warn('Baidu Maps API key nÃ£o configurada');\n        return this.mockChineseValidation(address, city, province);\n      }\n\n      // Geocoding com Baidu Maps\n      const query = `${address}, ${city}, ${province}, China`;\n      const response = await axios.get('https://api.map.baidu.com/geocoding/v2/', {\n        params: {\n          address: query,\n          output: 'json',\n          ak: this.apiKeys.baidu\n        },\n        timeout: 5000\n      });\n\n      if (response.data.status !== 0) {\n        throw new Error('EndereÃ§o nÃ£o encontrado');\n      }\n\n      const { result } = response.data;\n\n      return {\n        isValid: true,\n        country: 'CN',\n        address: {\n          street: address,\n          city,\n          province,\n          country: 'China',\n          coordinates: {\n            lat: result.location.lat,\n            lng: result.location.lng\n          }\n        },\n        source: 'baidu'\n      };\n    } catch (error) {\n      logger.error('Erro na validaÃ§Ã£o de endereÃ§o chinÃªs:', error);\n      return {\n        isValid: false,\n        error: error.message,\n        country: 'CN'\n      };\n    }\n  }\n\n  /**\n   * Validar endereÃ§o usando Google Places API (fallback internacional)\n   */\n  async validateInternationalAddress(address, country) {\n    try {\n      if (!this.apiKeys.google) {\n        logger.warn('Google Places API key nÃ£o configurada');\n        return this.mockInternationalValidation(address, country);\n      }\n\n      // Geocoding com Google Places\n      const response = await axios.get('https://maps.googleapis.com/maps/api/geocode/json', {\n        params: {\n          address: `${address}, ${country}`,\n          key: this.apiKeys.google\n        },\n        timeout: 5000\n      });\n\n      if (response.data.status !== 'OK' || !response.data.results.length) {\n        throw new Error('EndereÃ§o nÃ£o encontrado');\n      }\n\n      const result = response.data.results[0];\n      const components = result.address_components;\n\n      // Extrair componentes do endereÃ§o\n      const addressComponents = this.extractGoogleAddressComponents(components);\n\n      return {\n        isValid: true,\n        country,\n        address: {\n          street: addressComponents.street,\n          city: addressComponents.city,\n          state: addressComponents.state,\n          zipCode: addressComponents.zipCode,\n          country: addressComponents.country,\n          coordinates: {\n            lat: result.geometry.location.lat,\n            lng: result.geometry.location.lng\n          }\n        },\n        source: 'google'\n      };\n    } catch (error) {\n      logger.error('Erro na validaÃ§Ã£o de endereÃ§o internacional:', error);\n      return {\n        isValid: false,\n        error: error.message,\n        country\n      };\n    }\n  }\n\n  /**\n   * Validar endereÃ§o baseado no paÃ­s\n   */\n  async validateAddress(addressData) {\n    const { country, zipCode, address, city, state, province } = addressData;\n\n    switch (country.toUpperCase()) {\n      case 'BR':\n      case 'BRAZIL':\n      case 'BRASIL':\n        return await this.validateBrazilianAddress(zipCode);\n\n      case 'CN':\n      case 'CHINA':\n        return await this.validateChineseAddress(address, city, province);\n\n      default:\n        return await this.validateInternationalAddress(address, country);\n    }\n  }\n\n  /**\n   * Extrair componentes de endereÃ§o do Google Places\n   */\n  extractGoogleAddressComponents(components) {\n    const result = {\n      street: '',\n      city: '',\n      state: '',\n      zipCode: '',\n      country: ''\n    };\n\n    components.forEach(component => {\n      const { types } = component;\n\n      if (types.includes('street_number') || types.includes('route')) {\n        result.street = component.long_name;\n      } else if (types.includes('locality')) {\n        result.city = component.long_name;\n      } else if (types.includes('administrative_area_level_1')) {\n        result.state = component.long_name;\n      } else if (types.includes('postal_code')) {\n        result.zipCode = component.long_name;\n      } else if (types.includes('country')) {\n        result.country = component.long_name;\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Mock para validaÃ§Ã£o chinesa quando API nÃ£o estÃ¡ disponÃ­vel\n   */\n  mockChineseValidation(address, city, province) {\n    return {\n      isValid: true,\n      country: 'CN',\n      address: {\n        street: address,\n        city,\n        province,\n        country: 'China',\n        coordinates: null\n      },\n      source: 'mock'\n    };\n  }\n\n  /**\n   * Mock para validaÃ§Ã£o internacional quando API nÃ£o estÃ¡ disponÃ­vel\n   */\n  mockInternationalValidation(address, country) {\n    return {\n      isValid: true,\n      country,\n      address: {\n        street: address,\n        city: 'Unknown',\n        state: 'Unknown',\n        zipCode: 'Unknown',\n        country,\n        coordinates: null\n      },\n      source: 'mock'\n    };\n  }\n\n  /**\n   * Formatar endereÃ§o para exibiÃ§Ã£o\n   */\n  formatAddress(addressData) {\n    const { street, city, state, zipCode, country } = addressData;\n\n    switch (country.toUpperCase()) {\n      case 'BR':\n        return `${street}, ${city}, ${state}, ${zipCode}, Brasil`;\n      case 'CN':\n        return `${street}, ${city}, ${state}, China`;\n      default:\n        return `${street}, ${city}, ${state}, ${country}`;\n    }\n  }\n\n  /**\n   * Obter lista de paÃ­ses suportados\n   */\n  getSupportedCountries() {\n    return [\n      { code: 'BR', name: 'Brasil', flag: 'ðŸ‡§ðŸ‡·' },\n      { code: 'CN', name: 'China', flag: 'ðŸ‡¨ðŸ‡³' },\n      { code: 'US', name: 'Estados Unidos', flag: 'ðŸ‡ºðŸ‡¸' },\n      { code: 'AR', name: 'Argentina', flag: 'ðŸ‡¦ðŸ‡·' },\n      { code: 'UY', name: 'Uruguai', flag: 'ðŸ‡ºðŸ‡¾' },\n      { code: 'PY', name: 'Paraguai', flag: 'ðŸ‡µðŸ‡¾' },\n      { code: 'BO', name: 'BolÃ­via', flag: 'ðŸ‡§ðŸ‡´' },\n      { code: 'PE', name: 'Peru', flag: 'ðŸ‡µðŸ‡ª' },\n      { code: 'CL', name: 'Chile', flag: 'ðŸ‡¨ðŸ‡±' },\n      { code: 'CO', name: 'ColÃ´mbia', flag: 'ðŸ‡¨ðŸ‡´' },\n      { code: 'VE', name: 'Venezuela', flag: 'ðŸ‡»ðŸ‡ª' },\n      { code: 'EC', name: 'Equador', flag: 'ðŸ‡ªðŸ‡¨' },\n      { code: 'GY', name: 'Guiana', flag: 'ðŸ‡¬ðŸ‡¾' },\n      { code: 'SR', name: 'Suriname', flag: 'ðŸ‡¸ðŸ‡·' },\n      { code: 'GF', name: 'Guiana Francesa', flag: 'ðŸ‡¬ðŸ‡«' }\n    ];\n  }\n\n  /**\n   * Obter formato de endereÃ§o por paÃ­s\n   */\n  getAddressFormat(country) {\n    const formats = {\n      BR: {\n        fields: ['zipCode', 'street', 'number', 'neighborhood', 'city', 'state'],\n        labels: {\n          zipCode: 'CEP',\n          street: 'Rua/Avenida',\n          number: 'NÃºmero',\n          neighborhood: 'Bairro',\n          city: 'Cidade',\n          state: 'Estado'\n        },\n        required: ['zipCode', 'street', 'city', 'state']\n      },\n      CN: {\n        fields: ['province', 'city', 'district', 'street', 'number'],\n        labels: {\n          province: 'ProvÃ­ncia',\n          city: 'Cidade',\n          district: 'Distrito',\n          street: 'Rua',\n          number: 'NÃºmero'\n        },\n        required: ['province', 'city', 'street']\n      },\n      US: {\n        fields: ['street', 'number', 'city', 'state', 'zipCode'],\n        labels: {\n          street: 'Street',\n          number: 'Number',\n          city: 'City',\n          state: 'State',\n          zipCode: 'ZIP Code'\n        },\n        required: ['street', 'city', 'state', 'zipCode']\n      }\n    };\n\n    return formats[country] || formats['US'];\n  }\n}\n\nexport default new AddressValidationService();\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\apiFallbackService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\auditService.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'mongoose' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 4,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 16
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'createWriteStream' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 6,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 27
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'join' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 7,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 14
      },
      {
        "ruleId": "no-redeclare",
        "severity": 2,
        "message": "'logger' is already defined.",
        "line": 51,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "redeclared",
        "endLine": 51,
        "endColumn": 13
      },
      {
        "ruleId": "no-import-assign",
        "severity": 2,
        "message": "'logger' is read-only.",
        "line": 51,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "readonly",
        "endLine": 51,
        "endColumn": 13
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async method 'logPerformance' has no 'await' expression.",
        "line": 143,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 143,
        "endColumn": 23
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 595,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 595,
        "endColumn": 13
      },
      {
        "ruleId": "callback-return",
        "severity": 1,
        "message": "Expected return with your callback function.",
        "line": 598,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "missingReturn",
        "endLine": 598,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// Sistema de Logs e Auditoria Completo - AGROISYNC\n// Logging centralizado, auditoria de seguranÃ§a e monitoramento de atividades\n\nimport mongoose from 'mongoose';\nimport winston from 'winston';\nimport { createWriteStream } from 'fs';\nimport { join } from 'path';\nimport { AuditLog } from '../models/AuditLog.js';\nimport { SecurityLog } from '../models/SecurityLog.js';\n\nimport logger from '../utils/logger.js';\n// ===== CONFIGURAÃ‡ÃƒO DE LOGS =====\n\nconst logConfig = {\n  level: process.env.LOG_LEVEL || 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  transports: [\n    // Console transport\n    new winston.transports.Console({\n      format: winston.format.combine(winston.format.colorize(), winston.format.simple())\n    }),\n\n    // File transports\n    new winston.transports.File({\n      filename: 'logs/error.log',\n      level: 'error',\n      maxsize: 5242880, // 5MB\n      maxFiles: 5\n    }),\n\n    new winston.transports.File({\n      filename: 'logs/combined.log',\n      maxsize: 5242880, // 5MB\n      maxFiles: 10\n    }),\n\n    new winston.transports.File({\n      filename: 'logs/security.log',\n      level: 'warn',\n      maxsize: 5242880, // 5MB\n      maxFiles: 20\n    })\n  ]\n};\n\n// Criar logger principal\nconst logger = winston.createLogger(logConfig);\n\n// ===== SISTEMA DE AUDITORIA =====\n\nclass AuditSystem {\n  constructor() {\n    this.logger = logger;\n    this.securityLogger = winston.createLogger({\n      ...logConfig,\n      transports: [\n        new winston.transports.File({\n          filename: 'logs/security-audit.log',\n          maxsize: 5242880,\n          maxFiles: 30\n        })\n      ]\n    });\n  }\n\n  // Log de atividade do usuÃ¡rio\n  async logUserActivity(userId, action, resource, details = {}) {\n    try {\n      const auditEntry = {\n        userId,\n        userEmail: details.userEmail || 'unknown',\n        action,\n        resource,\n        resourceId: details.resourceId || null,\n        details: JSON.stringify(details),\n        ip: details.ip || 'unknown',\n        userAgent: details.userAgent || 'unknown',\n        timestamp: new Date(),\n        metadata: {\n          sessionId: details.sessionId,\n          requestId: details.requestId,\n          duration: details.duration\n        }\n      };\n\n      // Salvar no banco de dados\n      await AuditLog.create(auditEntry);\n\n      // Log no arquivo\n      this.logger.info('User Activity', auditEntry);\n\n      return auditEntry;\n    } catch (error) {\n      this.logger.error('Error logging user activity:', error);\n      throw error;\n    }\n  }\n\n  // Log de seguranÃ§a\n  async logSecurityEvent(eventType, severity, description, details = {}) {\n    try {\n      const securityEntry = {\n        eventType,\n        severity,\n        description,\n        userId: details.userId || null,\n        ipAddress: details.ip || 'unknown',\n        userAgent: details.userAgent || 'unknown',\n        requestMethod: details.method || null,\n        requestUrl: details.url || null,\n        requestHeaders: details.headers || {},\n        requestBody: details.body ? JSON.stringify(details.body).substring(0, 1000) : null,\n        details: JSON.stringify(details),\n        timestamp: new Date(),\n        threatLevel: details.threatLevel || 'low'\n      };\n\n      // Salvar no banco de dados\n      await SecurityLog.create(securityEntry);\n\n      // Log no arquivo de seguranÃ§a\n      this.securityLogger.warn('Security Event', securityEntry);\n\n      // Log no console se for crÃ­tico\n      if (severity === 'critical') {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('ðŸš¨ CRITICAL SECURITY EVENT:', securityEntry);\n        }\n      }\n\n      return securityEntry;\n    } catch (error) {\n      this.logger.error('Error logging security event:', error);\n      throw error;\n    }\n  }\n\n  // Log de performance\n  async logPerformance(operation, duration, details = {}) {\n    try {\n      const perfEntry = {\n        operation,\n        duration,\n        timestamp: new Date(),\n        details: JSON.stringify(details),\n        metadata: {\n          memoryUsage: process.memoryUsage(),\n          cpuUsage: process.cpuUsage(),\n          uptime: process.uptime()\n        }\n      };\n\n      // Log no arquivo\n      this.logger.info('Performance', perfEntry);\n\n      // Alertar se performance estiver ruim\n      if (duration > 5000) {\n        // 5 segundos\n        this.logger.warn('Slow Operation', perfEntry);\n      }\n\n      return perfEntry;\n    } catch (error) {\n      this.logger.error('Error logging performance:', error);\n      throw error;\n    }\n  }\n\n  // Log de erro\n  async logError(error, context = {}) {\n    try {\n      const errorEntry = {\n        message: error.message,\n        stack: error.stack,\n        timestamp: new Date(),\n        context: JSON.stringify(context),\n        metadata: {\n          url: context.url,\n          method: context.method,\n          userId: context.userId,\n          ip: context.ip,\n          userAgent: context.userAgent\n        }\n      };\n\n      // Log no arquivo de erro\n      this.logger.error('Application Error', errorEntry);\n\n      // Salvar no banco se for crÃ­tico\n      if (context.severity === 'critical') {\n        await SecurityLog.create({\n          eventType: 'system_error',\n          severity: 'critical',\n          description: `Critical error: ${error.message}`,\n          details: JSON.stringify(errorEntry),\n          timestamp: new Date()\n        });\n      }\n\n      return errorEntry;\n    } catch (logError) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Error logging error:', logError);\n      }\n      throw logError;\n    }\n  }\n\n  // Log de transaÃ§Ã£o financeira\n  async logFinancialTransaction(transactionId, type, amount, details = {}) {\n    try {\n      const transactionEntry = {\n        transactionId,\n        type,\n        amount,\n        currency: details.currency || 'BRL',\n        userId: details.userId,\n        userEmail: details.userEmail,\n        paymentMethod: details.paymentMethod,\n        status: details.status,\n        timestamp: new Date(),\n        details: JSON.stringify(details),\n        ip: details.ip,\n        userAgent: details.userAgent\n      };\n\n      // Salvar no banco\n      await AuditLog.create({\n        userId: details.userId,\n        userEmail: details.userEmail,\n        action: 'FINANCIAL_TRANSACTION',\n        resource: 'payment',\n        resourceId: transactionId,\n        details: JSON.stringify(transactionEntry),\n        ip: details.ip,\n        userAgent: details.userAgent,\n        timestamp: new Date()\n      });\n\n      // Log no arquivo\n      this.logger.info('Financial Transaction', transactionEntry);\n\n      return transactionEntry;\n    } catch (error) {\n      this.logger.error('Error logging financial transaction:', error);\n      throw error;\n    }\n  }\n\n  // Log de acesso a dados sensÃ­veis\n  async logDataAccess(userId, dataType, action, details = {}) {\n    try {\n      const accessEntry = {\n        userId,\n        userEmail: details.userEmail,\n        dataType,\n        action,\n        timestamp: new Date(),\n        details: JSON.stringify(details),\n        ip: details.ip,\n        userAgent: details.userAgent,\n        reason: details.reason || 'Business need'\n      };\n\n      // Salvar no banco\n      await AuditLog.create({\n        userId,\n        userEmail: details.userEmail,\n        action: 'DATA_ACCESS',\n        resource: dataType,\n        resourceId: details.resourceId,\n        details: JSON.stringify(accessEntry),\n        ip: details.ip,\n        userAgent: details.userAgent,\n        timestamp: new Date()\n      });\n\n      // Log no arquivo\n      this.logger.info('Data Access', accessEntry);\n\n      return accessEntry;\n    } catch (error) {\n      this.logger.error('Error logging data access:', error);\n      throw error;\n    }\n  }\n\n  // Log de mudanÃ§a de configuraÃ§Ã£o\n  async logConfigurationChange(userId, configKey, oldValue, newValue, details = {}) {\n    try {\n      const configEntry = {\n        userId,\n        userEmail: details.userEmail,\n        configKey,\n        oldValue: typeof oldValue === 'object' ? JSON.stringify(oldValue) : oldValue,\n        newValue: typeof newValue === 'object' ? JSON.stringify(newValue) : newValue,\n        timestamp: new Date(),\n        details: JSON.stringify(details),\n        ip: details.ip,\n        userAgent: details.userAgent\n      };\n\n      // Salvar no banco\n      await AuditLog.create({\n        userId,\n        userEmail: details.userEmail,\n        action: 'CONFIGURATION_CHANGE',\n        resource: 'system_config',\n        resourceId: configKey,\n        details: JSON.stringify(configEntry),\n        ip: details.ip,\n        userAgent: details.userAgent,\n        timestamp: new Date()\n      });\n\n      // Log no arquivo\n      this.logger.info('Configuration Change', configEntry);\n\n      return configEntry;\n    } catch (error) {\n      this.logger.error('Error logging configuration change:', error);\n      throw error;\n    }\n  }\n\n  // Obter logs de auditoria\n  async getAuditLogs(filters = {}) {\n    try {\n      const query = {};\n\n      if (filters.userId) {\n        query.userId = filters.userId;\n      }\n\n      if (filters.action) {\n        query.action = filters.action;\n      }\n\n      if (filters.resource) {\n        query.resource = filters.resource;\n      }\n\n      if (filters.startDate && filters.endDate) {\n        query.timestamp = {\n          $gte: new Date(filters.startDate),\n          $lte: new Date(filters.endDate)\n        };\n      }\n\n      const logs = await AuditLog.find(query)\n        .sort({ timestamp: -1 })\n        .limit(filters.limit || 100)\n        .skip(filters.skip || 0);\n\n      return logs;\n    } catch (error) {\n      this.logger.error('Error getting audit logs:', error);\n      throw error;\n    }\n  }\n\n  // Obter logs de seguranÃ§a\n  async getSecurityLogs(filters = {}) {\n    try {\n      const query = {};\n\n      if (filters.eventType) {\n        query.eventType = filters.eventType;\n      }\n\n      if (filters.severity) {\n        query.severity = filters.severity;\n      }\n\n      if (filters.userId) {\n        query.userId = filters.userId;\n      }\n\n      if (filters.startDate && filters.endDate) {\n        query.timestamp = {\n          $gte: new Date(filters.startDate),\n          $lte: new Date(filters.endDate)\n        };\n      }\n\n      const logs = await SecurityLog.find(query)\n        .sort({ timestamp: -1 })\n        .limit(filters.limit || 100)\n        .skip(filters.skip || 0);\n\n      return logs;\n    } catch (error) {\n      this.logger.error('Error getting security logs:', error);\n      throw error;\n    }\n  }\n\n  // Gerar relatÃ³rio de auditoria\n  async generateAuditReport(startDate, endDate, filters = {}) {\n    try {\n      const query = {\n        timestamp: {\n          $gte: new Date(startDate),\n          $lte: new Date(endDate)\n        }\n      };\n\n      if (filters.userId) {\n        query.userId = filters.userId;\n      }\n\n      if (filters.action) {\n        query.action = filters.action;\n      }\n\n      // AgregaÃ§Ã£o para estatÃ­sticas\n      const stats = await AuditLog.aggregate([\n        { $match: query },\n        {\n          $group: {\n            _id: '$action',\n            count: { $sum: 1 },\n            uniqueUsers: { $addToSet: '$userId' }\n          }\n        },\n        {\n          $project: {\n            action: '$_id',\n            count: 1,\n            uniqueUsers: { $size: '$uniqueUsers' }\n          }\n        }\n      ]);\n\n      // Logs detalhados\n      const logs = await AuditLog.find(query).sort({ timestamp: -1 }).limit(1000);\n\n      return {\n        period: { startDate, endDate },\n        statistics: stats,\n        logs,\n        totalLogs: logs.length,\n        generatedAt: new Date()\n      };\n    } catch (error) {\n      this.logger.error('Error generating audit report:', error);\n      throw error;\n    }\n  }\n\n  // Limpar logs antigos\n  async cleanupOldLogs(retentionDays = 90) {\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n      // Limpar logs de auditoria antigos\n      const auditResult = await AuditLog.deleteMany({\n        timestamp: { $lt: cutoffDate }\n      });\n\n      // Limpar logs de seguranÃ§a antigos\n      const securityResult = await SecurityLog.deleteMany({\n        timestamp: { $lt: cutoffDate }\n      });\n\n      this.logger.info('Log cleanup completed', {\n        auditLogsDeleted: auditResult.deletedCount,\n        securityLogsDeleted: securityResult.deletedCount,\n        cutoffDate\n      });\n\n      return {\n        auditLogsDeleted: auditResult.deletedCount,\n        securityLogsDeleted: securityResult.deletedCount\n      };\n    } catch (error) {\n      this.logger.error('Error cleaning up old logs:', error);\n      throw error;\n    }\n  }\n\n  // Exportar logs\n  async exportLogs(startDate, endDate, format = 'json') {\n    try {\n      const query = {\n        timestamp: {\n          $gte: new Date(startDate),\n          $lte: new Date(endDate)\n        }\n      };\n\n      const auditLogs = await AuditLog.find(query).sort({ timestamp: -1 });\n      const securityLogs = await SecurityLog.find(query).sort({ timestamp: -1 });\n\n      const exportData = {\n        auditLogs,\n        securityLogs,\n        exportedAt: new Date(),\n        period: { startDate, endDate }\n      };\n\n      if (format === 'csv') {\n        // Implementar exportaÃ§Ã£o CSV\n        return this.exportToCSV(exportData);\n      }\n\n      return exportData;\n    } catch (error) {\n      this.logger.error('Error exporting logs:', error);\n      throw error;\n    }\n  }\n\n  // Exportar para CSV\n  exportToCSV(data) {\n    // Implementar exportaÃ§Ã£o CSV\n    const csv = this.convertToCSV(data);\n    return csv;\n  }\n\n  // Converter para CSV\n  convertToCSV(data) {\n    // Implementar conversÃ£o para CSV\n    return JSON.stringify(data, null, 2);\n  }\n}\n\n// ===== MIDDLEWARE DE LOGGING =====\n\nexport const loggingMiddleware = (req, res, next) => {\n  const startTime = Date.now();\n  const requestId = Math.random().toString(36).substr(2, 9);\n\n  // Adicionar request ID ao request\n  req.requestId = requestId;\n\n  // Log da requisiÃ§Ã£o\n  logger.info('Request started', {\n    requestId,\n    method: req.method,\n    url: req.originalUrl,\n    ip: req.ip,\n    userAgent: req.get('User-Agent'),\n    userId: req.user?.id,\n    timestamp: new Date()\n  });\n\n  // Interceptar resposta\n  const originalSend = res.send;\n  res.send = function (data) {\n    const duration = Date.now() - startTime;\n\n    // Log da resposta\n    logger.info('Request completed', {\n      requestId,\n      method: req.method,\n      url: req.originalUrl,\n      statusCode: res.statusCode,\n      duration,\n      responseSize: data ? data.length : 0,\n      userId: req.user?.id\n    });\n\n    return originalSend.call(this, data);\n  };\n\n  next();\n};\n\n// ===== MIDDLEWARE DE AUDITORIA =====\n\nexport const auditMiddleware = (action, resource) => {\n  return async (req, res, next) => {\n    try {\n      const auditSystem = new AuditSystem();\n\n      // Log da aÃ§Ã£o\n      await auditSystem.logUserActivity(req.user?.id, action, resource, {\n        userEmail: req.user?.email,\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        method: req.method,\n        url: req.originalUrl,\n        requestId: req.requestId,\n        body: req.body,\n        params: req.params,\n        query: req.query\n      });\n\n      next();\n    } catch (error) {\n      logger.error('Error in audit middleware:', error);\n      next();\n    }\n  };\n};\n\n// ===== MIDDLEWARE DE SEGURANÃ‡A =====\n\nexport const securityLoggingMiddleware = (req, res, next) => {\n  const auditSystem = new AuditSystem();\n\n  // Detectar atividade suspeita\n  const suspiciousPatterns = [\n    /union\\s+select/i,\n    /<script/i,\n    /javascript:/i,\n    /\\.\\.\\//i,\n    /eval\\s*\\(/i\n  ];\n\n  const requestData = JSON.stringify({\n    url: req.originalUrl,\n    body: req.body,\n    query: req.query,\n    headers: req.headers\n  });\n\n  const isSuspicious = suspiciousPatterns.some(pattern => pattern.test(requestData));\n\n  if (isSuspicious) {\n    auditSystem.logSecurityEvent(\n      'suspicious_activity',\n      'high',\n      'Suspicious pattern detected in request',\n      {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        method: req.method,\n        url: req.originalUrl,\n        body: req.body,\n        query: req.query,\n        headers: req.headers,\n        threatLevel: 'high'\n      }\n    );\n  }\n\n  next();\n};\n\n// InstÃ¢ncia Ãºnica do sistema de auditoria\nconst auditSystem = new AuditSystem();\n\nexport default auditSystem;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\backupService.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'mongoose' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 4,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 16
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'SecurityLog' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 10,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 10,
        "endColumn": 21
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'manifest' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 86,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 86,
        "endColumn": 21
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'dbName' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 144,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 144,
        "endColumn": 19
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 329,
        "column": 23,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 329,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [10390, 10390], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 330,
        "column": 23,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 330,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [10447, 10447], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "require-await",
        "severity": 1,
        "message": "Async method 'sendNotification' has no 'await' expression.",
        "line": 545,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 545,
        "endColumn": 25
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'errorMessage' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 545,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 545,
        "endColumn": 54
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// Sistema de Backup e RecuperaÃ§Ã£o - AGROISYNC\n// Backup automÃ¡tico de dados crÃ­ticos e recuperaÃ§Ã£o de desastres\n\nimport mongoose from 'mongoose';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { AuditLog } from '../models/AuditLog.js';\nimport { SecurityLog } from '../models/SecurityLog.js';\nimport logger from '../utils/logger.js';\n\nconst execAsync = promisify(exec);\n\nclass BackupSystem {\n  constructor() {\n    this.backupConfig = {\n      // ConfiguraÃ§Ãµes de backup\n      enabled: process.env.BACKUP_ENABLED === 'true',\n      interval: parseInt(process.env.BACKUP_INTERVAL, 10, 10) || 24 * 60 * 60 * 1000, // 24 horas\n      retentionDays: parseInt(process.env.BACKUP_RETENTION_DAYS, 10, 10) || 30,\n      maxBackups: parseInt(process.env.BACKUP_MAX_COUNT, 10, 10) || 10,\n\n      // ConfiguraÃ§Ãµes de armazenamento\n      localPath: process.env.BACKUP_LOCAL_PATH || './backups',\n      s3Bucket: process.env.BACKUP_S3_BUCKET,\n      s3Region: process.env.BACKUP_S3_REGION || 'us-east-1',\n\n      // ConfiguraÃ§Ãµes de criptografia\n      encryptionKey: process.env.BACKUP_ENCRYPTION_KEY,\n      encryptBackups: process.env.BACKUP_ENCRYPT === 'true',\n\n      // ConfiguraÃ§Ãµes de notificaÃ§Ã£o\n      notifyOnSuccess: process.env.BACKUP_NOTIFY_SUCCESS === 'true',\n      notifyOnFailure: process.env.BACKUP_NOTIFY_FAILURE === 'true',\n      notificationEmail: process.env.BACKUP_NOTIFICATION_EMAIL\n    };\n\n    this.isRunning = false;\n    this.lastBackup = null;\n    this.backupHistory = [];\n\n    if (this.backupConfig.enabled) {\n      this.startScheduledBackups();\n    }\n  }\n\n  // Iniciar backups agendados\n  startScheduledBackups() {\n    logger.info('Sistema de backup iniciado');\n    // Executar backup inicial\n    this.performBackup();\n\n    // Agendar backups regulares\n    setInterval(() => {\n      this.performBackup();\n    }, this.backupConfig.interval);\n  }\n\n  // Executar backup completo\n  async performBackup() {\n    if (this.isRunning) {\n      logger.info('Backup já em execução, pulando...');\n      return;\n    }\n\n    this.isRunning = true;\n    const backupId = `backup_${Date.now()}`;\n    const startTime = new Date();\n\n    try {\n      logger.info(`Iniciando backup: ${backupId}`);\n      // Criar diretÃ³rio de backup\n      await this.createBackupDirectory();\n\n      // Executar backup do banco de dados\n      const dbBackup = await this.backupDatabase(backupId);\n\n      // Executar backup de arquivos\n      const filesBackup = await this.backupFiles(backupId);\n\n      // Executar backup de configuraÃ§Ãµes\n      const configBackup = await this.backupConfigurations(backupId);\n\n      // Criar arquivo de manifesto\n      const manifest = await this.createManifest(backupId, {\n        dbBackup,\n        filesBackup,\n        configBackup,\n        startTime,\n        endTime: new Date()\n      });\n\n      // Criptografar backup se necessÃ¡rio\n      if (this.backupConfig.encryptBackups) {\n        await this.encryptBackup(backupId);\n      }\n\n      // Upload para S3 se configurado\n      if (this.backupConfig.s3Bucket) {\n        await this.uploadToS3(backupId);\n      }\n\n      // Limpar backups antigos\n      await this.cleanupOldBackups();\n\n      // Registrar sucesso\n      await this.logBackupSuccess(backupId, startTime, new Date());\n\n      this.lastBackup = {\n        id: backupId,\n        timestamp: startTime,\n        status: 'success',\n        size: await this.getBackupSize(backupId)\n      };\n\n      logger.info(`Backup concluído: ${backupId}`);\n      // Notificar sucesso\n      if (this.backupConfig.notifyOnSuccess) {\n        await this.sendNotification('success', backupId);\n      }\n    } catch (error) {\n      logger.error(`Erro no backup ${backupId}:`, error);\n      // Registrar erro\n      await this.logBackupError(backupId, error);\n\n      // Notificar erro\n      if (this.backupConfig.notifyOnFailure) {\n        await this.sendNotification('error', backupId, error.message);\n      }\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  // Backup do banco de dados\n  async backupDatabase(backupId) {\n    const dbBackupPath = path.join(this.backupConfig.localPath, backupId, 'database');\n    await fs.mkdir(dbBackupPath, { recursive: true });\n\n    try {\n      // MongoDB dump\n      const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/agroisync';\n      const dbName = mongoUri.split('/').pop().split('?')[0];\n\n      const dumpCommand = `mongodump --uri=\"${mongoUri}\" --out=\"${dbBackupPath}\"`;\n      await execAsync(dumpCommand);\n\n      logger.info(`Backup do banco de dados concluído: ${dbBackupPath}`);\n      return {\n        type: 'database',\n        path: dbBackupPath,\n        size: await this.getDirectorySize(dbBackupPath),\n        collections: await this.getCollectionCount(dbBackupPath)\n      };\n    } catch (error) {\n      logger.error('Erro no backup do banco:', error);\n      throw error;\n    }\n  }\n\n  // Backup de arquivos\n  async backupFiles(backupId) {\n    const filesBackupPath = path.join(this.backupConfig.localPath, backupId, 'files');\n    await fs.mkdir(filesBackupPath, { recursive: true });\n\n    try {\n      // Backup de uploads\n      const uploadsPath = path.join(process.cwd(), 'uploads');\n      if (await this.pathExists(uploadsPath)) {\n        await this.copyDirectory(uploadsPath, path.join(filesBackupPath, 'uploads'));\n      }\n\n      // Backup de logs\n      const logsPath = path.join(process.cwd(), 'logs');\n      if (await this.pathExists(logsPath)) {\n        await this.copyDirectory(logsPath, path.join(filesBackupPath, 'logs'));\n      }\n\n      // Backup de configuraÃ§Ãµes\n      const configPath = path.join(process.cwd(), 'config');\n      if (await this.pathExists(configPath)) {\n        await this.copyDirectory(configPath, path.join(filesBackupPath, 'config'));\n      }\n\n      logger.info(`Backup de arquivos concluído: ${filesBackupPath}`);\n      return {\n        type: 'files',\n        path: filesBackupPath,\n        size: await this.getDirectorySize(filesBackupPath)\n      };\n    } catch (error) {\n      logger.error('Erro no backup de arquivos:', error);\n      throw error;\n    }\n  }\n\n  // Backup de configuraÃ§Ãµes\n  async backupConfigurations(backupId) {\n    const configBackupPath = path.join(this.backupConfig.localPath, backupId, 'configurations');\n    await fs.mkdir(configBackupPath, { recursive: true });\n\n    try {\n      // Backup de variÃ¡veis de ambiente (sem valores sensÃ­veis)\n      const envBackup = {};\n      for (const [key, value] of Object.entries(process.env)) {\n        if (key.startsWith('AGROISYNC_') || key.startsWith('BACKUP_')) {\n          // Mascarar valores sensÃ­veis\n          if (key.includes('PASSWORD') || key.includes('SECRET') || key.includes('KEY')) {\n            envBackup[key] = '***MASKED***';\n          } else {\n            envBackup[key] = value;\n          }\n        }\n      }\n\n      await fs.writeFile(\n        path.join(configBackupPath, 'environment.json'),\n        JSON.stringify(envBackup, null, 2)\n      );\n\n      // Backup de configuraÃ§Ãµes da aplicaÃ§Ã£o\n      const appConfig = {\n        version: process.env.npm_package_version || '1.0.0',\n        nodeVersion: process.version,\n        platform: process.platform,\n        arch: process.arch,\n        uptime: process.uptime(),\n        timestamp: new Date().toISOString()\n      };\n\n      await fs.writeFile(\n        path.join(configBackupPath, 'application.json'),\n        JSON.stringify(appConfig, null, 2)\n      );\n\n      logger.info(`Backup de configurações concluído: ${configBackupPath}`);\n      return {\n        type: 'configurations',\n        path: configBackupPath,\n        size: await this.getDirectorySize(configBackupPath)\n      };\n    } catch (error) {\n      logger.error('Erro no backup de configurações:', error);\n      throw error;\n    }\n  }\n\n  // Criar manifesto do backup\n  async createManifest(backupId, backupData) {\n    const manifest = {\n      id: backupId,\n      timestamp: new Date().toISOString(),\n      version: '1.0.0',\n      type: 'full',\n      components: backupData,\n      metadata: {\n        totalSize: 0,\n        fileCount: 0,\n        duration: backupData.endTime.getTime() - backupData.startTime.getTime()\n      }\n    };\n\n    // Calcular tamanho total\n    manifest.metadata.totalSize =\n      backupData.dbBackup.size + backupData.filesBackup.size + backupData.configBackup.size;\n\n    const manifestPath = path.join(this.backupConfig.localPath, backupId, 'manifest.json');\n    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));\n\n    return manifest;\n  }\n\n  // Criptografar backup\n  async encryptBackup(backupId) {\n    if (!this.backupConfig.encryptionKey) {\n      throw new Error('Chave de criptografia nÃ£o configurada');\n    }\n\n    const backupPath = path.join(this.backupConfig.localPath, backupId);\n    const encryptedPath = `${backupPath}.encrypted`;\n\n    try {\n      // Usar openssl para criptografar\n      const encryptCommand = `openssl enc -aes-256-cbc -salt -in \"${backupPath}\" -out \"${encryptedPath}\" -k \"${this.backupConfig.encryptionKey}\"`;\n      await execAsync(encryptCommand);\n\n      // Remover backup nÃ£o criptografado\n      await fs.rm(backupPath, { recursive: true, force: true });\n\n      logger.info(`Backup criptografado: ${encryptedPath}`);\n    } catch (error) {\n      logger.error('Erro na criptografia:', error);\n      throw error;\n    }\n  }\n\n  // Upload para S3\n  async uploadToS3(backupId) {\n    if (!this.backupConfig.s3Bucket) {\n      return;\n    }\n\n    try {\n      const backupPath = path.join(this.backupConfig.localPath, backupId);\n      const s3Key = `backups/${backupId}.tar.gz`;\n\n      // Criar arquivo tar.gz\n      const tarCommand = `tar -czf \"${backupPath}.tar.gz\" -C \"${this.backupConfig.localPath}\" \"${backupId}\"`;\n      await execAsync(tarCommand);\n\n      logger.info(`Upload para S3: ${s3Key}`);\n      // Remover arquivo local apÃ³s upload\n      await fs.rm(`${backupPath}.tar.gz`, { force: true });\n    } catch (error) {\n      logger.error('Erro no upload S3:', error);\n      throw error;\n    }\n  }\n\n  // Limpar backups antigos\n  async cleanupOldBackups() {\n    try {\n      const backups = await fs.readdir(this.backupConfig.localPath);\n      const backupDirs = backups.filter(dir => dir.startsWith('backup_'));\n\n      // Ordenar por data\n      backupDirs.sort((a, b) => {\n        const aTime = parseInt(a.split('_', 10, 10)[1]);\n        const bTime = parseInt(b.split('_', 10, 10)[1]);\n        return bTime - aTime;\n      });\n\n      // Remover backups antigos\n      if (backupDirs.length > this.backupConfig.maxBackups) {\n        const toRemove = backupDirs.slice(this.backupConfig.maxBackups);\n\n        for (const dir of toRemove) {\n          const dirPath = path.join(this.backupConfig.localPath, dir);\n          await fs.rm(dirPath, { recursive: true, force: true });\n          logger.info(`Backup antigo removido: ${dir}`);\n        }\n      }\n    } catch (error) {\n      logger.error('Erro na limpeza de backups:', error);\n    }\n  }\n\n  // Restaurar backup\n  async restoreBackup(backupId, options = {}) {\n    const { restoreDatabase = true, restoreFiles = true, restoreConfigurations = false } = options;\n\n    try {\n      logger.info(`Iniciando restauraÃ§Ã£o: ${backupId}`);\n      const backupPath = path.join(this.backupConfig.localPath, backupId);\n\n      // Verificar se backup existe\n      if (!(await this.pathExists(backupPath))) {\n        throw new Error(`Backup nÃ£o encontrado: ${backupId}`);\n      }\n\n      // Ler manifesto\n      const manifestPath = path.join(backupPath, 'manifest.json');\n      const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));\n\n      // Restaurar banco de dados\n      if (restoreDatabase && manifest.components.dbBackup) {\n        await this.restoreDatabase(backupId);\n      }\n\n      // Restaurar arquivos\n      if (restoreFiles && manifest.components.filesBackup) {\n        await this.restoreFiles(backupId);\n      }\n\n      // Restaurar configuraÃ§Ãµes\n      if (restoreConfigurations && manifest.components.configBackup) {\n        await this.restoreConfigurations(backupId);\n      }\n\n      logger.info(`RestauraÃ§Ã£o concluÃ­da: ${backupId}`);\n    } catch (error) {\n      logger.error(`Erro na restauraÃ§Ã£o ${backupId}:`, error);\n      throw error;\n    }\n  }\n\n  // Restaurar banco de dados\n  async restoreDatabase(backupId) {\n    const backupPath = path.join(this.backupConfig.localPath, backupId, 'database');\n    const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/agroisync';\n\n    try {\n      const restoreCommand = `mongorestore --uri=\"${mongoUri}\" --drop \"${backupPath}\"`;\n      await execAsync(restoreCommand);\n\n      logger.info(`Banco de dados restaurado: ${backupId}`);\n    } catch (error) {\n      logger.error('Erro na restauraÃ§Ã£o do banco:', error);\n      throw error;\n    }\n  }\n\n  // Restaurar arquivos\n  async restoreFiles(backupId) {\n    const backupPath = path.join(this.backupConfig.localPath, backupId, 'files');\n\n    try {\n      // Restaurar uploads\n      const uploadsBackup = path.join(backupPath, 'uploads');\n      if (await this.pathExists(uploadsBackup)) {\n        const uploadsPath = path.join(process.cwd(), 'uploads');\n        await this.copyDirectory(uploadsBackup, uploadsPath);\n      }\n\n      // Restaurar logs\n      const logsBackup = path.join(backupPath, 'logs');\n      if (await this.pathExists(logsBackup)) {\n        const logsPath = path.join(process.cwd(), 'logs');\n        await this.copyDirectory(logsBackup, logsPath);\n      }\n\n      logger.info(`Arquivos restaurados: ${backupId}`);\n    } catch (error) {\n      logger.error('Erro na restauraÃ§Ã£o de arquivos:', error);\n      throw error;\n    }\n  }\n\n  // Restaurar configuraÃ§Ãµes\n  async restoreConfigurations(backupId) {\n    const backupPath = path.join(this.backupConfig.localPath, backupId, 'configurations');\n\n    try {\n      const configBackup = path.join(backupPath, 'config');\n      if (await this.pathExists(configBackup)) {\n        const configPath = path.join(process.cwd(), 'config');\n        await this.copyDirectory(configBackup, configPath);\n      }\n\n      logger.info(`ConfiguraÃ§Ãµes restauradas: ${backupId}`);\n    } catch (error) {\n      logger.error('Erro na restauraÃ§Ã£o de configuraÃ§Ãµes:', error);\n      throw error;\n    }\n  }\n\n  // FunÃ§Ãµes auxiliares\n  async createBackupDirectory() {\n    await fs.mkdir(this.backupConfig.localPath, { recursive: true });\n  }\n\n  async pathExists(path) {\n    try {\n      await fs.access(path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async copyDirectory(src, dest) {\n    await fs.mkdir(dest, { recursive: true });\n    const entries = await fs.readdir(src, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const srcPath = path.join(src, entry.name);\n      const destPath = path.join(dest, entry.name);\n\n      if (entry.isDirectory()) {\n        await this.copyDirectory(srcPath, destPath);\n      } else {\n        await fs.copyFile(srcPath, destPath);\n      }\n    }\n  }\n\n  async getDirectorySize(dirPath) {\n    let size = 0;\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const entryPath = path.join(dirPath, entry.name);\n\n      if (entry.isDirectory()) {\n        size += await this.getDirectorySize(entryPath);\n      } else {\n        const stats = await fs.stat(entryPath);\n        size += stats.size;\n      }\n    }\n\n    return size;\n  }\n\n  async getBackupSize(backupId) {\n    const backupPath = path.join(this.backupConfig.localPath, backupId);\n    return await this.getDirectorySize(backupPath);\n  }\n\n  async getCollectionCount(backupPath) {\n    try {\n      const entries = await fs.readdir(backupPath, { withFileTypes: true });\n      return entries.filter(entry => entry.isDirectory()).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  async logBackupSuccess(backupId, startTime, endTime) {\n    await AuditLog.create({\n      userId: 'system',\n      userEmail: 'system@agroisync.com',\n      action: 'BACKUP_SUCCESS',\n      resource: 'backup_system',\n      resourceId: backupId,\n      details: `Backup concluÃ­do com sucesso: ${backupId}`,\n      ip: '127.0.0.1',\n      userAgent: 'BackupSystem',\n      metadata: {\n        startTime,\n        endTime,\n        duration: endTime.getTime() - startTime.getTime()\n      }\n    });\n  }\n\n  async logBackupError(backupId, error) {\n    await AuditLog.create({\n      userId: 'system',\n      userEmail: 'system@agroisync.com',\n      action: 'BACKUP_ERROR',\n      resource: 'backup_system',\n      resourceId: backupId,\n      details: `Erro no backup: ${backupId} - ${error.message}`,\n      ip: '127.0.0.1',\n      userAgent: 'BackupSystem',\n      error: {\n        message: error.message,\n        stack: error.stack\n      }\n    });\n  }\n\n  async sendNotification(type, backupId, errorMessage = null) {\n    // Implementar envio de notificaÃ§Ã£o por email\n    if (process.env.NODE_ENV !== 'production') {\n      logger.info(`ðŸ“§ NotificaÃ§Ã£o ${type}: ${backupId}`);\n    }\n  }\n\n  // Obter status do sistema\n  getStatus() {\n    return {\n      enabled: this.backupConfig.enabled,\n      isRunning: this.isRunning,\n      lastBackup: this.lastBackup,\n      nextBackup: this.lastBackup\n        ? new Date(this.lastBackup.timestamp.getTime() + this.backupConfig.interval)\n        : null,\n      config: {\n        interval: this.backupConfig.interval,\n        retentionDays: this.backupConfig.retentionDays,\n        maxBackups: this.backupConfig.maxBackups,\n        encryptBackups: this.backupConfig.encryptBackups,\n        s3Bucket: this.backupConfig.s3Bucket\n      }\n    };\n  }\n}\n\nexport default BackupSystem;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\cloudflareService.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'challenge_ts' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 36,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 36,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿const axios = require('axios');\nconst logger = require('../utils/logger');\n\nclass CloudflareService {\n  constructor() {\n    this.turnstileSecret = process.env.CLOUDFLARE_TURNSTILE_SECRET;\n    this.accessToken = process.env.CLOUDFLARE_ACCESS_TOKEN;\n    this.accountId = process.env.CLOUDFLARE_ACCOUNT_ID;\n    this.zoneId = process.env.CLOUDFLARE_ZONE_ID;\n  }\n\n  /**\n   * Verifica token Turnstile do Cloudflare\n   */\n  async verifyTurnstileToken(token, remoteip = null) {\n    try {\n      if (!this.turnstileSecret) {\n        logger.warn('CLOUDFLARE_TURNSTILE_SECRET nÃ£o configurado, pulando verificaÃ§Ã£o');\n        return true; // Em desenvolvimento, sempre retorna true\n      }\n\n      const response = await axios.post(\n        'https://challenges.cloudflare.com/turnstile/v0/siteverify',\n        {\n          secret: this.turnstileSecret,\n          response: token,\n          remoteip\n        },\n        {\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          }\n        }\n      );\n\n      const { success, error_codes, challenge_ts } = response.data;\n\n      if (!success) {\n        logger.warn(`Token Turnstile invÃ¡lido: ${error_codes?.join(', ') || 'erro desconhecido'}`);\n        return false;\n      }\n\n      logger.info(`Token Turnstile verificado com sucesso para IP: ${remoteip}`);\n      return true;\n    } catch (error) {\n      logger.error('Erro ao verificar token Turnstile:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Configura Cloudflare Access para proteger rotas admin\n   */\n  async setupAccessPolicy(route, allowedEmails = []) {\n    try {\n      if (!this.accessToken || !this.accountId) {\n        logger.warn('Cloudflare Access nÃ£o configurado');\n        return false;\n      }\n\n      const policy = {\n        name: `AgroSync Admin - ${route}`,\n        decision: {\n          type: 'allow'\n        },\n        include: [\n          {\n            email_domain: {\n              domain: 'agrotm.com.br'\n            }\n          }\n        ],\n        exclude: [],\n        require: [\n          {\n            email: {\n              email: allowedEmails\n            }\n          }\n        ]\n      };\n\n      const response = await axios.post(\n        `https://api.cloudflare.com/client/v4/accounts/${this.accountId}/access/apps`,\n        {\n          name: 'AgroSync Admin',\n          domain: `${process.env.DOMAIN || 'agroisync.com'}/admin`,\n          type: 'self_hosted',\n          policies: [policy]\n        },\n        {\n          headers: {\n            Authorization: `Bearer ${this.accessToken}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      logger.info('PolÃ­tica Cloudflare Access configurada com sucesso');\n      return response.data;\n    } catch (error) {\n      logger.error('Erro ao configurar Cloudflare Access:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Verifica se usuÃ¡rio tem acesso via Cloudflare Access\n   */\n  async verifyAccessToken(accessToken) {\n    try {\n      if (!this.accessToken || !this.accountId) {\n        return { valid: false, user: null };\n      }\n\n      const response = await axios.get(\n        `https://api.cloudflare.com/client/v4/accounts/${this.accountId}/access/apps`,\n        {\n          headers: {\n            Authorization: `Bearer ${this.accessToken}`,\n            'CF-Access-Token': accessToken\n          }\n        }\n      );\n\n      return {\n        valid: true,\n        user: response.data.user\n      };\n    } catch (error) {\n      logger.error('Erro ao verificar token Cloudflare Access:', error);\n      return { valid: false, user: null };\n    }\n  }\n\n  /**\n   * Configura Workers para autenticaÃ§Ã£o JWT\n   */\n  async deployAuthWorker() {\n    try {\n      if (!this.accessToken || !this.accountId) {\n        logger.warn('Cloudflare Workers nÃ£o configurado');\n        return false;\n      }\n\n      const workerScript = `\n        export default {\n          async fetch(request, env) {\n            const url = new URL(request.url);\n            \n            // Verificar se Ã© rota protegida\n            if (url.pathname.startsWith('/admin') || url.pathname.startsWith('/api/admin')) {\n              const token = request.headers.get('Authorization')?.replace('Bearer ', '');\n              \n              if (!token) {\n                return new Response('Unauthorized', { status: 401 });\n              }\n              \n              try {\n                // Verificar JWT\n                const payload = JSON.parse(atob(token.split('.')[1]));\n                \n                if (payload.exp < Date.now() / 1000) {\n                  return new Response('Token expired', { status: 401 });\n                }\n                \n                if (payload.role !== 'admin' && payload.role !== 'super-admin') {\n                  return new Response('Insufficient permissions', { status: 403 });\n                }\n                \n                // Adicionar headers de usuÃ¡rio\n                const modifiedRequest = new Request(request, {\n                  headers: {\n                    ...request.headers,\n                    'X-User-ID': payload.id,\n                    'X-User-Email': payload.email,\n                    'X-User-Role': payload.role\n                  }\n                });\n                \n                return fetch(modifiedRequest);\n              } catch (error) {\n                return new Response('Invalid token', { status: 401 });\n              }\n            }\n            \n            return fetch(request);\n          }\n        }\n      `;\n\n      const response = await axios.put(\n        `https://api.cloudflare.com/client/v4/accounts/${this.accountId}/workers/scripts/agroisync-auth`,\n        workerScript,\n        {\n          headers: {\n            Authorization: `Bearer ${this.accessToken}`,\n            'Content-Type': 'application/javascript'\n          }\n        }\n      );\n\n      logger.info('Worker de autenticaÃ§Ã£o Cloudflare implantado com sucesso');\n      return response.data;\n    } catch (error) {\n      logger.error('Erro ao implantar Worker Cloudflare:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Configura cache para APIs\n   */\n  async setupCacheRules() {\n    try {\n      if (!this.accessToken || !this.zoneId) {\n        logger.warn('Cloudflare Cache nÃ£o configurado');\n        return false;\n      }\n\n      const cacheRules = [\n        {\n          name: 'API Cache',\n          expression: 'http.host eq \"api.agroisync.com\"',\n          action: 'cache',\n          cache_ttl: 300 // 5 minutos\n        },\n        {\n          name: 'Static Assets',\n          expression:\n            'http.host eq \"agroisync.com\" and http.request.uri.path matches \"^/static/.*\"',\n          action: 'cache',\n          cache_ttl: 86400 // 24 horas\n        }\n      ];\n\n      for (const rule of cacheRules) {\n        await axios.post(\n          `https://api.cloudflare.com/client/v4/zones/${this.zoneId}/rulesets`,\n          {\n            name: rule.name,\n            kind: 'zone',\n            phase: 'http_request_cache',\n            rules: [\n              {\n                expression: rule.expression,\n                action: rule.action,\n                action_parameters: {\n                  cache_ttl: rule.cache_ttl\n                }\n              }\n            ]\n          },\n          {\n            headers: {\n              Authorization: `Bearer ${this.accessToken}`,\n              'Content-Type': 'application/json'\n            }\n          }\n        );\n      }\n\n      logger.info('Regras de cache Cloudflare configuradas com sucesso');\n      return true;\n    } catch (error) {\n      logger.error('Erro ao configurar cache Cloudflare:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Configura proteÃ§Ã£o DDoS\n   */\n  async setupDDoSProtection() {\n    try {\n      if (!this.accessToken || !this.zoneId) {\n        logger.warn('ProteÃ§Ã£o DDoS Cloudflare nÃ£o configurada');\n        return false;\n      }\n\n      const response = await axios.patch(\n        `https://api.cloudflare.com/client/v4/zones/${this.zoneId}/settings/security_level`,\n        {\n          value: 'high'\n        },\n        {\n          headers: {\n            Authorization: `Bearer ${this.accessToken}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      logger.info('ProteÃ§Ã£o DDoS Cloudflare ativada');\n      return response.data;\n    } catch (error) {\n      logger.error('Erro ao configurar proteÃ§Ã£o DDoS:', error);\n      return false;\n    }\n  }\n\n  /**\n   * ObtÃ©m estatÃ­sticas de seguranÃ§a\n   */\n  async getSecurityStats(startDate, endDate) {\n    try {\n      if (!this.accessToken || !this.zoneId) {\n        return null;\n      }\n\n      const response = await axios.get(\n        `https://api.cloudflare.com/client/v4/zones/${this.zoneId}/analytics/dashboard`,\n        {\n          params: {\n            since: startDate,\n            until: endDate\n          },\n          headers: {\n            Authorization: `Bearer ${this.accessToken}`\n          }\n        }\n      );\n\n      return response.data;\n    } catch (error) {\n      logger.error('Erro ao obter estatÃ­sticas de seguranÃ§a:', error);\n      return null;\n    }\n  }\n\n  /**\n   * ConfiguraÃ§Ã£o inicial completa do Cloudflare\n   */\n  async initializeCloudflare() {\n    try {\n      logger.info('Inicializando configuraÃ§Ãµes do Cloudflare...');\n\n      const results = {\n        turnstile: !!this.turnstileSecret,\n        access: await this.setupAccessPolicy('/admin', [process.env.ADMIN_EMAIL]),\n        worker: await this.deployAuthWorker(),\n        cache: await this.setupCacheRules(),\n        ddos: await this.setupDDoSProtection()\n      };\n\n      logger.info('ConfiguraÃ§Ãµes Cloudflare inicializadas:', results);\n      return results;\n    } catch (error) {\n      logger.error('Erro na inicializaÃ§Ã£o do Cloudflare:', error);\n      return false;\n    }\n  }\n}\n\nmodule.exports = new CloudflareService();\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\emailService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\externalAPIs.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\loggingService.js",
    "messages": [
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 10 spaces but found 12.",
        "line": 69,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 69,
        "endColumn": 13,
        "fix": { "range": [1635, 1647], "text": "          " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 10 spaces but found 12.",
        "line": 70,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 70,
        "endColumn": 13,
        "fix": { "range": [1671, 1683], "text": "          " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 10 spaces but found 12.",
        "line": 71,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 71,
        "endColumn": 13,
        "fix": { "range": [1703, 1715], "text": "          " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 8 spaces but found 10.",
        "line": 72,
        "column": 1,
        "nodeType": "Punctuator",
        "messageId": "wrongIndentation",
        "endLine": 72,
        "endColumn": 11,
        "fix": { "range": [1732, 1742], "text": "        " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 4,
    "fixableWarningCount": 0,
    "source": "﻿import winston from 'winston';\nimport { AuditLog } from '../models/AuditLog.js';\n\n// ConfiguraÃ§Ã£o do Winston Logger\nconst logger = winston.createLogger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: winston.format.combine(\n    winston.format.timestamp({\n      format: 'YYYY-MM-DD HH:mm:ss'\n    }),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  defaultMeta: { service: 'agroisync-backend' },\n  transports: [\n    // Console transport\n    new winston.transports.Console({\n      format: winston.format.combine(winston.format.colorize(), winston.format.simple())\n    }),\n\n    // File transports\n    new winston.transports.File({\n      filename: 'logs/error.log',\n      level: 'error',\n      maxsize: 5242880, // 5MB\n      maxFiles: 5\n    }),\n    new winston.transports.File({\n      filename: 'logs/combined.log',\n      maxsize: 5242880, // 5MB\n      maxFiles: 5\n    })\n  ]\n});\n\n// Adicionar transport para MongoDB em produÃ§Ã£o\nif (process.env.NODE_ENV === 'production') {\n  const MongoDBTransport = require('winston-mongodb').MongoDB;\n\n  logger.add(\n    new MongoDBTransport({\n      db: process.env.MONGODB_URI,\n      collection: 'logs',\n      options: {\n        useUnifiedTopology: true\n      },\n      level: 'info'\n    })\n  );\n}\n\nexport class LoggingService {\n  // Log de informaÃ§Ãµes gerais\n  static info(message, meta = {}) {\n    logger.info(message, meta);\n  }\n\n  // Log de avisos\n  static warn(message, meta = {}) {\n    logger.warn(message, meta);\n  }\n\n  // Log de erros\n  static error(message, error = null, meta = {}) {\n    const errorMeta = {\n      ...meta,\n      error: error\n        ? {\n            message: error.message,\n            stack: error.stack,\n            name: error.name\n          }\n        : null\n    };\n    logger.error(message, errorMeta);\n  }\n\n  // Log de debug\n  static debug(message, meta = {}) {\n    logger.debug(message, meta);\n  }\n\n  // Log de requisiÃ§Ãµes HTTP\n  static logRequest(req, res, responseTime) {\n    const logData = {\n      method: req.method,\n      url: req.originalUrl,\n      statusCode: res.statusCode,\n      responseTime: `${responseTime}ms`,\n      userAgent: req.get('User-Agent'),\n      ip: req.ip,\n      userId: req.user?.userId || null,\n      userEmail: req.user?.email || null\n    };\n\n    if (res.statusCode >= 400) {\n      this.warn('HTTP Request Error', logData);\n    } else {\n      this.info('HTTP Request', logData);\n    }\n  }\n\n  // Log de autenticaÃ§Ã£o\n  static logAuth(action, userId, email, success, details = {}) {\n    const logData = {\n      action,\n      userId,\n      email,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success) {\n      this.info(`Auth Success: ${action}`, logData);\n    } else {\n      this.warn(`Auth Failed: ${action}`, logData);\n    }\n\n    // Salvar no banco de dados\n    AuditLog.logAction({\n      userId: userId || 'anonymous',\n      userEmail: email,\n      action: `AUTH_${action.toUpperCase()}`,\n      resource: '/api/auth',\n      details: JSON.stringify(details),\n      ip: details.ip || 'unknown',\n      userAgent: details.userAgent || 'unknown',\n      isSuspicious: !success,\n      riskLevel: success ? 'LOW' : 'MEDIUM'\n    }).catch(err => {\n      this.error('Failed to save auth log to database', err);\n    });\n  }\n\n  // Log de pagamentos\n  static logPayment(action, userId, amount, currency, success, details = {}) {\n    const logData = {\n      action,\n      userId,\n      amount,\n      currency,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success) {\n      this.info(`Payment Success: ${action}`, logData);\n    } else {\n      this.error(`Payment Failed: ${action}`, null, logData);\n    }\n\n    // Salvar no banco de dados\n    AuditLog.logAction({\n      userId: userId || 'system',\n      userEmail: details.userEmail,\n      action: `PAYMENT_${action.toUpperCase()}`,\n      resource: '/api/payments',\n      details: JSON.stringify(details),\n      ip: details.ip || 'system',\n      userAgent: details.userAgent || 'system',\n      isSuspicious: !success,\n      riskLevel: success ? 'LOW' : 'HIGH'\n    }).catch(err => {\n      this.error('Failed to save payment log to database', err);\n    });\n  }\n\n  // Log de transaÃ§Ãµes de escrow\n  static logEscrow(action, transactionId, userId, amount, success, details = {}) {\n    const logData = {\n      action,\n      transactionId,\n      userId,\n      amount,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success) {\n      this.info(`Escrow Success: ${action}`, logData);\n    } else {\n      this.error(`Escrow Failed: ${action}`, null, logData);\n    }\n\n    // Salvar no banco de dados\n    AuditLog.logAction({\n      userId: userId || 'system',\n      userEmail: details.userEmail,\n      action: `ESCROW_${action.toUpperCase()}`,\n      resource: '/api/escrow',\n      details: JSON.stringify(details),\n      ip: details.ip || 'system',\n      userAgent: details.userAgent || 'system',\n      isSuspicious: !success,\n      riskLevel: success ? 'LOW' : 'HIGH'\n    }).catch(err => {\n      this.error('Failed to save escrow log to database', err);\n    });\n  }\n\n  // Log de mensageria\n  static logMessaging(action, fromUserId, toUserId, messageId, success, details = {}) {\n    const logData = {\n      action,\n      fromUserId,\n      toUserId,\n      messageId,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success) {\n      this.info(`Messaging Success: ${action}`, logData);\n    } else {\n      this.warn(`Messaging Failed: ${action}`, logData);\n    }\n\n    // Salvar no banco de dados\n    AuditLog.logAction({\n      userId: fromUserId || 'system',\n      userEmail: details.fromEmail,\n      action: `MESSAGING_${action.toUpperCase()}`,\n      resource: '/api/messaging',\n      details: JSON.stringify(details),\n      ip: details.ip || 'system',\n      userAgent: details.userAgent || 'system',\n      isSuspicious: false,\n      riskLevel: 'LOW'\n    }).catch(err => {\n      this.error('Failed to save messaging log to database', err);\n    });\n  }\n\n  // Log de sistema\n  static logSystem(action, component, success, details = {}) {\n    const logData = {\n      action,\n      component,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success) {\n      this.info(`System Success: ${action}`, logData);\n    } else {\n      this.error(`System Error: ${action}`, null, logData);\n    }\n\n    // Salvar no banco de dados\n    AuditLog.logAction({\n      userId: 'system',\n      userEmail: 'system@agroisync.com',\n      action: `SYSTEM_${action.toUpperCase()}`,\n      resource: `/system/${component}`,\n      details: JSON.stringify(details),\n      ip: 'system',\n      userAgent: 'system',\n      isSuspicious: false,\n      riskLevel: success ? 'LOW' : 'HIGH'\n    }).catch(err => {\n      this.error('Failed to save system log to database', err);\n    });\n  }\n\n  // Log de performance\n  static logPerformance(operation, duration, success, details = {}) {\n    const logData = {\n      operation,\n      duration: `${duration}ms`,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success && duration < 1000) {\n      this.info(`Performance: ${operation}`, logData);\n    } else if (success && duration >= 1000) {\n      this.warn(`Slow Operation: ${operation}`, logData);\n    } else {\n      this.error(`Performance Error: ${operation}`, null, logData);\n    }\n  }\n\n  // Log de seguranÃ§a\n  static logSecurity(action, userId, ip, userAgent, riskLevel, details = {}) {\n    const logData = {\n      action,\n      userId,\n      ip,\n      userAgent,\n      riskLevel,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (riskLevel === 'HIGH') {\n      this.error(`Security Alert: ${action}`, null, logData);\n    } else if (riskLevel === 'MEDIUM') {\n      this.warn(`Security Warning: ${action}`, logData);\n    } else {\n      this.info(`Security Event: ${action}`, logData);\n    }\n\n    // Salvar no banco de dados\n    AuditLog.logAction({\n      userId: userId || 'anonymous',\n      userEmail: details.userEmail,\n      action: `SECURITY_${action.toUpperCase()}`,\n      resource: details.resource || '/api/security',\n      details: JSON.stringify(details),\n      ip,\n      userAgent,\n      isSuspicious: riskLevel !== 'LOW',\n      riskLevel\n    }).catch(err => {\n      this.error('Failed to save security log to database', err);\n    });\n  }\n\n  // Log de API externa\n  static logExternalApi(\n    service,\n    endpoint,\n    method,\n    statusCode,\n    responseTime,\n    success,\n    details = {}\n  ) {\n    const logData = {\n      service,\n      endpoint,\n      method,\n      statusCode,\n      responseTime: `${responseTime}ms`,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success) {\n      this.info(`External API Success: ${service}`, logData);\n    } else {\n      this.error(`External API Error: ${service}`, null, logData);\n    }\n  }\n\n  // Log de email\n  static logEmail(action, to, template, success, details = {}) {\n    const logData = {\n      action,\n      to,\n      template,\n      success,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success) {\n      this.info(`Email Success: ${action}`, logData);\n    } else {\n      this.error(`Email Failed: ${action}`, null, logData);\n    }\n  }\n\n  // Log de banco de dados\n  static logDatabase(operation, collection, success, duration, details = {}) {\n    const logData = {\n      operation,\n      collection,\n      success,\n      duration: `${duration}ms`,\n      timestamp: new Date(),\n      ...details\n    };\n\n    if (success && duration < 100) {\n      this.debug(`Database Success: ${operation}`, logData);\n    } else if (success && duration >= 100) {\n      this.warn(`Slow Database Operation: ${operation}`, logData);\n    } else {\n      this.error(`Database Error: ${operation}`, null, logData);\n    }\n  }\n\n  // MÃ©todo para obter logs por perÃ­odo\n  static async getLogsByPeriod(startDate, endDate, level = null, limit = 100) {\n    try {\n      const query = {\n        timestamp: {\n          $gte: startDate,\n          $lte: endDate\n        }\n      };\n\n      if (level) {\n        query.level = level;\n      }\n\n      const logs = await AuditLog.find(query).sort({ timestamp: -1 }).limit(limit).lean();\n\n      return logs;\n    } catch (error) {\n      this.error('Failed to retrieve logs from database', error);\n      throw error;\n    }\n  }\n\n  // MÃ©todo para obter estatÃ­sticas de logs\n  static async getLogStatistics(startDate, endDate) {\n    try {\n      const pipeline = [\n        {\n          $match: {\n            timestamp: {\n              $gte: startDate,\n              $lte: endDate\n            }\n          }\n        },\n        {\n          $group: {\n            _id: {\n              action: '$action',\n              riskLevel: '$riskLevel'\n            },\n            count: { $sum: 1 }\n          }\n        },\n        {\n          $group: {\n            _id: '$_id.action',\n            total: { $sum: '$count' },\n            byRiskLevel: {\n              $push: {\n                riskLevel: '$_id.riskLevel',\n                count: '$count'\n              }\n            }\n          }\n        }\n      ];\n\n      const stats = await AuditLog.aggregate(pipeline);\n      return stats;\n    } catch (error) {\n      this.error('Failed to get log statistics', error);\n      throw error;\n    }\n  }\n}\n\nexport default LoggingService;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\notificationService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\openaiService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\performanceMonitor.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'oneHourAgo' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 339,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 339,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// Sistema de Monitoramento de Performance - AGROISYNC\n// Monitoramento em tempo real de performance, recursos e mÃ©tricas\n\nimport { performance } from 'perf_hooks';\nimport { SecurityLog } from '../models/SecurityLog.js';\nimport { AuditLog } from '../models/AuditLog.js';\n\nimport logger from '../utils/logger.js';\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = {\n      requests: new Map(),\n      responses: new Map(),\n      errors: new Map(),\n      resources: new Map()\n    };\n\n    this.thresholds = {\n      responseTime: 2000, // 2 segundos\n      memoryUsage: 0.8, // 80%\n      cpuUsage: 0.8, // 80%\n      errorRate: 0.05, // 5%\n      throughput: 1000 // requests per minute\n    };\n\n    this.alerts = [];\n    this.isMonitoring = false;\n\n    this.startMonitoring();\n  }\n\n  // Iniciar monitoramento\n  startMonitoring() {\n    if (this.isMonitoring) {\n      return;\n    }\n\n    this.isMonitoring = true;\n\n    // Monitorar recursos do sistema\n    setInterval(() => {\n      this.monitorSystemResources();\n    }, 30000); // A cada 30 segundos\n\n    // Monitorar performance da aplicaÃ§Ã£o\n    setInterval(() => {\n      this.monitorApplicationPerformance();\n    }, 60000); // A cada minuto\n\n    // Limpar mÃ©tricas antigas\n    setInterval(() => {\n      this.cleanupOldMetrics();\n    }, 300000); // A cada 5 minutos\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.info('ðŸ“Š Sistema de monitoramento de performance iniciado');\n    }\n  }\n\n  // Monitorar recursos do sistema\n  monitorSystemResources() {\n    const memUsage = process.memoryUsage();\n    const cpuUsage = process.cpuUsage();\n\n    const metrics = {\n      memory: {\n        rss: memUsage.rss,\n        heapTotal: memUsage.heapTotal,\n        heapUsed: memUsage.heapUsed,\n        external: memUsage.external,\n        usage: memUsage.heapUsed / memUsage.heapTotal\n      },\n      cpu: {\n        user: cpuUsage.user,\n        system: cpuUsage.system\n      },\n      uptime: process.uptime(),\n      timestamp: new Date()\n    };\n\n    // Verificar limites\n    if (metrics.memory.usage > this.thresholds.memoryUsage) {\n      this.createAlert('HIGH_MEMORY_USAGE', 'warning', {\n        usage: metrics.memory.usage,\n        threshold: this.thresholds.memoryUsage,\n        details: metrics\n      });\n    }\n\n    // Armazenar mÃ©tricas\n    this.metrics.resources.set(Date.now(), metrics);\n\n    // Log de performance\n    this.logPerformanceMetric('SYSTEM_RESOURCES', metrics);\n  }\n\n  // Monitorar performance da aplicaÃ§Ã£o\n  monitorApplicationPerformance() {\n    const now = Date.now();\n    const oneMinuteAgo = now - 60000;\n\n    // Calcular mÃ©tricas de requisiÃ§Ãµes\n    const recentRequests = Array.from(this.metrics.requests.values()).filter(\n      req => req.timestamp > oneMinuteAgo\n    );\n\n    const recentResponses = Array.from(this.metrics.responses.values()).filter(\n      res => res.timestamp > oneMinuteAgo\n    );\n\n    const recentErrors = Array.from(this.metrics.errors.values()).filter(\n      err => err.timestamp > oneMinuteAgo\n    );\n\n    const metrics = {\n      requestsPerMinute: recentRequests.length,\n      averageResponseTime: this.calculateAverageResponseTime(recentResponses),\n      errorRate: recentErrors.length / Math.max(recentRequests.length, 1),\n      throughput: recentRequests.length,\n      timestamp: new Date()\n    };\n\n    // Verificar limites\n    if (metrics.averageResponseTime > this.thresholds.responseTime) {\n      this.createAlert('SLOW_RESPONSE_TIME', 'warning', {\n        responseTime: metrics.averageResponseTime,\n        threshold: this.thresholds.responseTime,\n        details: metrics\n      });\n    }\n\n    if (metrics.errorRate > this.thresholds.errorRate) {\n      this.createAlert('HIGH_ERROR_RATE', 'critical', {\n        errorRate: metrics.errorRate,\n        threshold: this.thresholds.errorRate,\n        details: metrics\n      });\n    }\n\n    if (metrics.throughput > this.thresholds.throughput) {\n      this.createAlert('HIGH_THROUGHPUT', 'info', {\n        throughput: metrics.throughput,\n        threshold: this.thresholds.throughput,\n        details: metrics\n      });\n    }\n\n    // Armazenar mÃ©tricas\n    this.metrics.responses.set(now, metrics);\n\n    // Log de performance\n    this.logPerformanceMetric('APPLICATION_PERFORMANCE', metrics);\n  }\n\n  // Registrar requisiÃ§Ã£o\n  recordRequest(req, res, next) {\n    const startTime = performance.now();\n    const requestId = Math.random().toString(36).substr(2, 9);\n\n    // Adicionar request ID ao request\n    req.requestId = requestId;\n    req.startTime = startTime;\n\n    // Registrar requisiÃ§Ã£o\n    this.metrics.requests.set(requestId, {\n      id: requestId,\n      method: req.method,\n      url: req.originalUrl,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      timestamp: Date.now(),\n      userId: req.user?.id\n    });\n\n    // Interceptar resposta\n    const originalSend = res.send;\n    res.send = function (data) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n\n      // Registrar resposta\n      this.metrics.responses.set(requestId, {\n        id: requestId,\n        statusCode: res.statusCode,\n        duration,\n        responseSize: data ? data.length : 0,\n        timestamp: Date.now()\n      });\n\n      // Verificar se Ã© erro\n      if (res.statusCode >= 400) {\n        this.metrics.errors.set(requestId, {\n          id: requestId,\n          statusCode: res.statusCode,\n          error: data,\n          duration,\n          timestamp: Date.now()\n        });\n      }\n\n      return originalSend.call(this, data);\n    }.bind(this);\n\n    next();\n  }\n\n  // Calcular tempo mÃ©dio de resposta\n  calculateAverageResponseTime(responses) {\n    if (responses.length === 0) {\n      return 0;\n    }\n\n    const totalTime = responses.reduce((sum, res) => sum + res.duration, 0);\n    return totalTime / responses.length;\n  }\n\n  // Criar alerta\n  createAlert(type, severity, details) {\n    const alert = {\n      id: Math.random().toString(36).substr(2, 9),\n      type,\n      severity,\n      message: this.getAlertMessage(type, details),\n      details,\n      timestamp: new Date(),\n      acknowledged: false\n    };\n\n    this.alerts.push(alert);\n\n    // Log de seguranÃ§a\n    this.logSecurityEvent('PERFORMANCE_ALERT', severity, {\n      alertType: type,\n      details\n    });\n\n    // Log no console\n    if (process.env.NODE_ENV !== 'production') {\n      // Console log removido}]: ${alert.message}`);\n    }\n    return alert;\n  }\n\n  // Obter mensagem do alerta\n  getAlertMessage(type, details) {\n    const messages = {\n      HIGH_MEMORY_USAGE: `Uso de memÃ³ria alto: ${(details.usage * 100).toFixed(1)}%`,\n      SLOW_RESPONSE_TIME: `Tempo de resposta lento: ${details.responseTime.toFixed(2)}ms`,\n      HIGH_ERROR_RATE: `Taxa de erro alta: ${(details.errorRate * 100).toFixed(2)}%`,\n      HIGH_THROUGHPUT: `Throughput alto: ${details.throughput} req/min`,\n      LOW_THROUGHPUT: `Throughput baixo: ${details.throughput} req/min`,\n      HIGH_CPU_USAGE: `Uso de CPU alto: ${(details.cpuUsage * 100).toFixed(1)}%`\n    };\n\n    return messages[type] || 'Alerta de performance desconhecido';\n  }\n\n  // Log de mÃ©trica de performance\n  async logPerformanceMetric(type, metrics) {\n    try {\n      await AuditLog.create({\n        userId: 'system',\n        userEmail: 'system@agroisync.com',\n        action: 'PERFORMANCE_METRIC',\n        resource: 'performance_monitor',\n        resourceId: type,\n        details: JSON.stringify(metrics),\n        ip: '127.0.0.1',\n        userAgent: 'PerformanceMonitor',\n        timestamp: new Date()\n      });\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao registrar mÃ©trica de performance:', error);\n      }\n    }\n  }\n\n  // Log de evento de seguranÃ§a\n  async logSecurityEvent(eventType, severity, details) {\n    try {\n      await SecurityLog.create({\n        eventType,\n        severity,\n        description: `Performance alert: ${eventType}`,\n        details: JSON.stringify(details),\n        timestamp: new Date(),\n        ipAddress: '127.0.0.1',\n        userAgent: 'PerformanceMonitor'\n      });\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Erro ao registrar evento de seguranÃ§a:', error);\n      }\n    }\n  }\n\n  // Limpar mÃ©tricas antigas\n  cleanupOldMetrics() {\n    const now = Date.now();\n    const oneHourAgo = now - 3600000;\n\n    // Limpar requisiÃ§Ãµes antigas\n    for (const [key, data] of this.metrics.requests.entries()) {\n      if (data.timestamp < oneHourAgo) {\n        this.metrics.requests.delete(key);\n      }\n    }\n\n    // Limpar respostas antigas\n    for (const [key, data] of this.metrics.responses.entries()) {\n      if (data.timestamp < oneHourAgo) {\n        this.metrics.responses.delete(key);\n      }\n    }\n\n    // Limpar erros antigos\n    for (const [key, data] of this.metrics.errors.entries()) {\n      if (data.timestamp < oneHourAgo) {\n        this.metrics.errors.delete(key);\n      }\n    }\n\n    // Limpar recursos antigos\n    for (const [key, data] of this.metrics.resources.entries()) {\n      if (data.timestamp < oneHourAgo) {\n        this.metrics.resources.delete(key);\n      }\n    }\n\n    // Limpar alertas antigos\n    this.alerts = this.alerts.filter(alert => alert.timestamp.getTime() > oneHourAgo);\n  }\n\n  // Obter estatÃ­sticas\n  getStats() {\n    const now = Date.now();\n    const oneMinuteAgo = now - 60000;\n    const oneHourAgo = now - 3600000;\n\n    const recentRequests = Array.from(this.metrics.requests.values()).filter(\n      req => req.timestamp > oneMinuteAgo\n    );\n\n    const recentResponses = Array.from(this.metrics.responses.values()).filter(\n      res => res.timestamp > oneMinuteAgo\n    );\n\n    const recentErrors = Array.from(this.metrics.errors.values()).filter(\n      err => err.timestamp > oneMinuteAgo\n    );\n\n    const recentResources = Array.from(this.metrics.resources.values()).filter(\n      res => res.timestamp > oneMinuteAgo\n    );\n\n    return {\n      requests: {\n        total: this.metrics.requests.size,\n        recent: recentRequests.length,\n        perMinute: recentRequests.length\n      },\n      responses: {\n        total: this.metrics.responses.size,\n        recent: recentResponses.length,\n        averageTime: this.calculateAverageResponseTime(recentResponses)\n      },\n      errors: {\n        total: this.metrics.errors.size,\n        recent: recentErrors.length,\n        rate: recentErrors.length / Math.max(recentRequests.length, 1)\n      },\n      resources: {\n        total: this.metrics.resources.size,\n        recent: recentResources.length,\n        averageMemoryUsage:\n          recentResources.length > 0\n            ? recentResources.reduce((sum, res) => sum + res.memory.usage, 0) /\n              recentResources.length\n            : 0\n      },\n      alerts: {\n        total: this.alerts.length,\n        unacknowledged: this.alerts.filter(alert => !alert.acknowledged).length\n      },\n      thresholds: this.thresholds\n    };\n  }\n\n  // Obter mÃ©tricas detalhadas\n  getDetailedMetrics() {\n    return {\n      requests: Object.fromEntries(this.metrics.requests),\n      responses: Object.fromEntries(this.metrics.responses),\n      errors: Object.fromEntries(this.metrics.errors),\n      resources: Object.fromEntries(this.metrics.resources),\n      alerts: this.alerts\n    };\n  }\n\n  // Configurar limites\n  setThresholds(newThresholds) {\n    this.thresholds = { ...this.thresholds, ...newThresholds };\n    if (process.env.NODE_ENV !== 'production') {\n      logger.info('ðŸ“Š Limites de performance atualizados:', this.thresholds);\n    }\n  }\n\n  // Parar monitoramento\n  stopMonitoring() {\n    this.isMonitoring = false;\n    if (process.env.NODE_ENV !== 'production') {\n      logger.info('ðŸ“Š Sistema de monitoramento de performance parado');\n    }\n  }\n}\n\n// InstÃ¢ncia Ãºnica\nconst performanceMonitor = new PerformanceMonitor();\n\nexport default performanceMonitor;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\secureURLService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\services\\tokenService.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\swagger\\swagger.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\configValidator.js",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'logger' is not defined.",
        "line": 192,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 192,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// Sistema de ValidaÃ§Ã£o de ConfiguraÃ§Ã£o - AGROISYNC\n// ValidaÃ§Ã£o rigorosa de todas as configuraÃ§Ãµes crÃ­ticas\n\nimport crypto from 'crypto';\n\nclass ConfigurationValidator {\n  constructor() {\n    this.criticalConfigs = [\n      'JWT_SECRET',\n      'MONGODB_URI',\n      'STRIPE_SECRET_KEY',\n      'STRIPE_WEBHOOK_SECRET',\n      'SMTP_USER',\n      'SMTP_PASS'\n    ];\n\n    this.warningConfigs = [\n      'REDIS_URL',\n      'TWILIO_ACCOUNT_SID',\n      'TWILIO_AUTH_TOKEN',\n      'CLOUDINARY_CLOUD_NAME',\n      'AWS_ACCESS_KEY_ID'\n    ];\n  }\n\n  // Validar todas as configuraÃ§Ãµes\n  validateAll() {\n    const errors = [];\n    const warnings = [];\n\n    // Validar configuraÃ§Ãµes crÃ­ticas\n    this.criticalConfigs.forEach(config => {\n      const value = process.env[config];\n      if (!value || this.isDefaultValue(value)) {\n        errors.push(`âŒ ${config} nÃ£o configurado ou usando valor padrÃ£o`);\n      } else if (!this.isValidValue(config, value)) {\n        errors.push(`âŒ ${config} tem formato invÃ¡lido`);\n      }\n    });\n\n    // Validar configuraÃ§Ãµes de aviso\n    this.warningConfigs.forEach(config => {\n      const value = process.env[config];\n      if (!value || this.isDefaultValue(value)) {\n        warnings.push(`âš ï¸ ${config} nÃ£o configurado - funcionalidade pode nÃ£o funcionar`);\n      }\n    });\n\n    // Validar configuraÃ§Ãµes especÃ­ficas\n    this.validateJWTSecret();\n    this.validateMongoURI();\n    this.validateStripeKeys();\n    this.validateEmailConfig();\n    this.validateSecurityConfig();\n\n    return { errors, warnings };\n  }\n\n  // Verificar se Ã© valor padrÃ£o\n  isDefaultValue(value) {\n    const defaultValues = [\n      'your-super-secret-jwt-key-change-in-production',\n      'mongodb://localhost:27017/agrosync',\n      'sk_test_DEFAULT_KEY_NOT_SET',\n      'pk_test_DEFAULT_KEY_NOT_SET',\n      'whsec_DEFAULT_WEBHOOK_SECRET_NOT_SET',\n      'noreply@agrosync.com',\n      'your-email@gmail.com',\n      'your-app-password'\n    ];\n\n    return defaultValues.includes(value);\n  }\n\n  // Validar valor especÃ­fico\n  isValidValue(config, value) {\n    switch (config) {\n      case 'JWT_SECRET':\n        return value.length >= 32 && !this.isDefaultValue(value);\n\n      case 'MONGODB_URI':\n        return value.startsWith('mongodb://') || value.startsWith('mongodb+srv://');\n\n      case 'STRIPE_SECRET_KEY':\n        return value.startsWith('sk_') && !this.isDefaultValue(value);\n\n      case 'STRIPE_WEBHOOK_SECRET':\n        return value.startsWith('whsec_') && !this.isDefaultValue(value);\n\n      case 'SMTP_USER':\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n\n      default:\n        return true;\n    }\n  }\n\n  // Validar JWT Secret\n  validateJWTSecret() {\n    const secret = process.env.JWT_SECRET;\n    if (!secret || this.isDefaultValue(secret)) {\n      throw new Error(\n        'âŒ JWT_SECRET Ã© obrigatÃ³rio e deve ser uma string segura de pelo menos 32 caracteres'\n      );\n    }\n\n    if (secret.length < 32) {\n      throw new Error('âŒ JWT_SECRET deve ter pelo menos 32 caracteres para seguranÃ§a');\n    }\n\n    // Verificar se nÃ£o Ã© uma string comum\n    const commonSecrets = [\n      'secret',\n      'password',\n      '123456',\n      'admin',\n      'test',\n      'your-super-secret-jwt-key-change-in-production'\n    ];\n\n    if (commonSecrets.includes(secret.toLowerCase())) {\n      throw new Error('âŒ JWT_SECRET nÃ£o pode ser uma string comum ou padrÃ£o');\n    }\n  }\n\n  // Validar MongoDB URI\n  validateMongoURI() {\n    const uri = process.env.MONGODB_URI;\n    if (!uri || this.isDefaultValue(uri)) {\n      throw new Error('âŒ MONGODB_URI Ã© obrigatÃ³rio');\n    }\n\n    if (!uri.startsWith('mongodb://') && !uri.startsWith('mongodb+srv://')) {\n      throw new Error('âŒ MONGODB_URI deve comeÃ§ar com mongodb:// ou mongodb+srv://');\n    }\n\n    // Verificar se nÃ£o Ã© localhost em produÃ§Ã£o\n    if (process.env.NODE_ENV === 'production' && uri.includes('localhost')) {\n      throw new Error('âŒ MONGODB_URI nÃ£o pode usar localhost em produÃ§Ã£o');\n    }\n  }\n\n  // Validar chaves Stripe\n  validateStripeKeys() {\n    const secretKey = process.env.STRIPE_SECRET_KEY;\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n    if (!secretKey || this.isDefaultValue(secretKey)) {\n      throw new Error('âŒ STRIPE_SECRET_KEY Ã© obrigatÃ³rio');\n    }\n\n    if (!webhookSecret || this.isDefaultValue(webhookSecret)) {\n      throw new Error('âŒ STRIPE_WEBHOOK_SECRET Ã© obrigatÃ³rio');\n    }\n\n    // Verificar se as chaves sÃ£o vÃ¡lidas\n    if (!secretKey.startsWith('sk_')) {\n      throw new Error('âŒ STRIPE_SECRET_KEY deve comeÃ§ar com sk_');\n    }\n\n    if (!webhookSecret.startsWith('whsec_')) {\n      throw new Error('âŒ STRIPE_WEBHOOK_SECRET deve comeÃ§ar com whsec_');\n    }\n  }\n\n  // Validar configuraÃ§Ã£o de email\n  validateEmailConfig() {\n    const smtpUser = process.env.SMTP_USER;\n    const smtpPass = process.env.SMTP_PASS;\n\n    if (!smtpUser || this.isDefaultValue(smtpUser)) {\n      throw new Error('âŒ SMTP_USER Ã© obrigatÃ³rio');\n    }\n\n    if (!smtpPass || this.isDefaultValue(smtpPass)) {\n      throw new Error('âŒ SMTP_PASS Ã© obrigatÃ³rio');\n    }\n\n    // Validar formato do email\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(smtpUser)) {\n      throw new Error('âŒ SMTP_USER deve ser um email vÃ¡lido');\n    }\n  }\n\n  // Validar configuraÃ§Ãµes de seguranÃ§a\n  validateSecurityConfig() {\n    // Verificar se estÃ¡ em produÃ§Ã£o\n    if (process.env.NODE_ENV === 'production') {\n      // Verificar HTTPS\n      if (process.env.FRONTEND_URL && !process.env.FRONTEND_URL.startsWith('https://')) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('âš ï¸ FRONTEND_URL deve usar HTTPS em produÃ§Ã£o');\n        }\n      }\n\n      // Verificar CORS\n      if (process.env.CORS_ORIGIN && process.env.CORS_ORIGIN === '*') {\n        throw new Error('âŒ CORS_ORIGIN nÃ£o pode ser * em produÃ§Ã£o');\n      }\n\n      // Verificar se nÃ£o estÃ¡ usando localhost\n      if (process.env.FRONTEND_URL && process.env.FRONTEND_URL.includes('localhost')) {\n        throw new Error('âŒ FRONTEND_URL nÃ£o pode usar localhost em produÃ§Ã£o');\n      }\n    }\n  }\n\n  // Gerar configuraÃ§Ãµes seguras\n  generateSecureConfig() {\n    return {\n      JWT_SECRET: crypto.randomBytes(64).toString('hex'),\n      SESSION_SECRET: crypto.randomBytes(32).toString('hex'),\n      ENCRYPTION_KEY: crypto.randomBytes(32).toString('hex'),\n      API_KEY: crypto.randomBytes(32).toString('hex')\n    };\n  }\n\n  // Validar arquivo .env\n  validateEnvFile() {\n    const fs = require('fs');\n    import logger from './logger.js';\n    const path = require('path');\n\n    const envPath = path.join(process.cwd(), '.env');\n\n    if (!fs.existsSync(envPath)) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn('âš ï¸ Arquivo .env nÃ£o encontrado');\n      }\n      return false;\n    }\n\n    const envContent = fs.readFileSync(envPath, 'utf8');\n    const lines = envContent.split('\\n');\n\n    const issues = [];\n\n    lines.forEach((line, index) => {\n      const lineNum = index + 1;\n\n      // Verificar se hÃ¡ comentÃ¡rios desnecessÃ¡rios\n      if (line.includes('# TODO') || line.includes('# FIXME')) {\n        issues.push(`Linha ${lineNum}: ComentÃ¡rio TODO/FIXME encontrado`);\n      }\n\n      // Verificar se hÃ¡ valores vazios\n      if (line.includes('=') && line.split('=')[1].trim() === '') {\n        issues.push(`Linha ${lineNum}: Valor vazio encontrado`);\n      }\n\n      // Verificar se hÃ¡ espaÃ§os em branco desnecessÃ¡rios\n      if (line.trim() !== line && line.trim() !== '') {\n        issues.push(`Linha ${lineNum}: EspaÃ§os em branco desnecessÃ¡rios`);\n      }\n    });\n\n    return issues;\n  }\n\n  // Criar arquivo .env seguro\n  createSecureEnvFile() {\n    const secureConfig = this.generateSecureConfig();\n\n    const envContent = `# ConfiguraÃ§Ãµes Seguras - AgroSync\n# Gerado automaticamente em ${new Date().toISOString()}\n\n# Servidor\nNODE_ENV=production\nPORT=5000\nAPI_URL=https://api.agroisync.com\nFRONTEND_URL=https://agroisync.com\n\n# Banco de Dados\nMONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/agroisync\n\n# JWT\nJWT_SECRET=${secureConfig.JWT_SECRET}\nJWT_EXPIRE=7d\nJWT_REFRESH_SECRET=${secureConfig.SESSION_SECRET}\nJWT_REFRESH_EXPIRE=30d\n\n# Stripe\nSTRIPE_SECRET_KEY=sk_live_your_stripe_secret_key_here\nSTRIPE_PUBLISHABLE_KEY=pk_live_your_stripe_publishable_key_here\nSTRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\n\n# Email\nSMTP_HOST=smtp.gmail.com\nSMTP_PORT=587\nSMTP_USER=your-email@gmail.com\nSMTP_PASS=your-app-password\nFROM_EMAIL=noreply@agroisync.com\nFROM_NAME=AgroSync\n\n# SMS\nTWILIO_ACCOUNT_SID=your_twilio_account_sid\nTWILIO_AUTH_TOKEN=your_twilio_auth_token\nTWILIO_PHONE_NUMBER=+1234567890\n\n# Upload\nCLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name\nCLOUDINARY_API_KEY=your_cloudinary_api_key\nCLOUDINARY_API_SECRET=your_cloudinary_api_secret\n\n# AWS\nAWS_ACCESS_KEY_ID=your_aws_access_key_id\nAWS_SECRET_ACCESS_KEY=your_aws_secret_access_key\nAWS_REGION=us-east-1\nAWS_S3_BUCKET=agroisync-storage\n\n# SeguranÃ§a\nBCRYPT_ROUNDS=12\nSESSION_SECRET=${secureConfig.SESSION_SECRET}\nCORS_ORIGIN=https://agroisync.com\nENCRYPTION_KEY=${secureConfig.ENCRYPTION_KEY}\n\n# Rate Limiting\nRATE_LIMIT_WINDOW_MS=900000\nRATE_LIMIT_MAX_REQUESTS=100\n\n# Logs\nLOG_LEVEL=info\nLOG_FILE_PATH=./logs\n\n# Feature Flags\nENABLE_2FA=true\nENABLE_CRYPTO=true\nENABLE_STRIPE=true\nENABLE_EMAIL_VERIFICATION=true\n`;\n\n    return envContent;\n  }\n}\n\n// InstÃ¢ncia Ãºnica\nconst configValidator = new ConfigurationValidator();\n\nexport default configValidator;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\cors.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\criticalDataValidator.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'crypto' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 4,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 14
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\+.",
        "line": 42,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 42,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [1061, 1062], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [1061, 1061], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\(.",
        "line": 42,
        "column": 33,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 42,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [1073, 1074], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [1073, 1073], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\).",
        "line": 42,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 42,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [1075, 1076], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [1075, 1075], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\[.",
        "line": 51,
        "column": 71,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 51,
        "endColumn": 72,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [1326, 1327], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [1326, 1326], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\/.",
        "line": 51,
        "column": 88,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 51,
        "endColumn": 89,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [1343, 1344], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [1343, 1343], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 167,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 167,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [4380, 4380], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 172,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 172,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [4529, 4529], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 178,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 178,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [4703, 4703], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 183,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 183,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [4849, 4849], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 213,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 213,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [5624, 5624], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 219,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 219,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [5819, 5819], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 227,
        "column": 14,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 227,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [6054, 6054], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "radix",
        "severity": 1,
        "message": "Missing radix parameter.",
        "line": 233,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "missingRadix",
        "endLine": 233,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "addRadixParameter10",
            "fix": { "range": [6245, 6245], "text": ", 10" },
            "desc": "Add radix parameter `10` for parsing decimal numbers."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\[.",
        "line": 326,
        "column": 27,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 326,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [8684, 8685], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [8684, 8684], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\/.",
        "line": 326,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 326,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [8701, 8702], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [8701, 8701], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// Sistema de ValidaÃ§Ã£o de Dados CrÃ­ticos - AGROISYNC\n// ValidaÃ§Ã£o rigorosa de todos os dados sensÃ­veis e crÃ­ticos\n\nimport crypto from 'crypto';\nimport validator from 'validator';\n\nclass CriticalDataValidator {\n  constructor() {\n    this.validationRules = {\n      // ValidaÃ§Ã£o de CPF\n      cpf: {\n        required: true,\n        minLength: 11,\n        maxLength: 14,\n        pattern: /^\\d{3}\\.?\\d{3}\\.?\\d{3}-?\\d{2}$/,\n        customValidation: this.validateCPF\n      },\n\n      // ValidaÃ§Ã£o de CNPJ\n      cnpj: {\n        required: true,\n        minLength: 14,\n        maxLength: 18,\n        pattern: /^\\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}-?\\d{2}$/,\n        customValidation: this.validateCNPJ\n      },\n\n      // ValidaÃ§Ã£o de email\n      email: {\n        required: true,\n        minLength: 5,\n        maxLength: 254,\n        pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n        customValidation: this.validateEmail\n      },\n\n      // ValidaÃ§Ã£o de telefone\n      phone: {\n        required: true,\n        minLength: 10,\n        maxLength: 15,\n        pattern: /^[\\+]?[0-9\\s\\-\\(\\)]+$/,\n        customValidation: this.validatePhone\n      },\n\n      // ValidaÃ§Ã£o de senha\n      password: {\n        required: true,\n        minLength: 8,\n        maxLength: 128,\n        pattern: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]).{8,}$/,\n        customValidation: this.validatePassword\n      },\n\n      // ValidaÃ§Ã£o de CEP\n      cep: {\n        required: true,\n        minLength: 8,\n        maxLength: 9,\n        pattern: /^\\d{5}-?\\d{3}$/,\n        customValidation: this.validateCEP\n      },\n\n      // ValidaÃ§Ã£o de placa\n      plate: {\n        required: true,\n        minLength: 7,\n        maxLength: 8,\n        pattern: /^[A-Z]{3}\\d[A-Z]\\d{2}$|^[A-Z]{3}\\d{2}[A-Z]\\d$/,\n        customValidation: this.validatePlate\n      }\n    };\n\n    this.sensitiveFields = [\n      'password',\n      'token',\n      'secret',\n      'key',\n      'creditCard',\n      'ssn',\n      'cpf',\n      'cnpj',\n      'bankAccount',\n      'routingNumber',\n      'pin',\n      'otp',\n      'verificationCode'\n    ];\n  }\n\n  // Validar dados crÃ­ticos\n  validateCriticalData(data, rules = {}) {\n    const errors = [];\n    const warnings = [];\n\n    for (const [field, value] of Object.entries(data)) {\n      const fieldRules = rules[field] || this.validationRules[field];\n\n      if (!fieldRules) {\n        continue; // Campo nÃ£o tem regras de validaÃ§Ã£o\n      }\n\n      // Verificar se Ã© obrigatÃ³rio\n      if (fieldRules.required && (!value || value.toString().trim() === '')) {\n        errors.push(`${field} Ã© obrigatÃ³rio`);\n        continue;\n      }\n\n      // Verificar comprimento mÃ­nimo\n      if (fieldRules.minLength && value.toString().length < fieldRules.minLength) {\n        errors.push(`${field} deve ter pelo menos ${fieldRules.minLength} caracteres`);\n      }\n\n      // Verificar comprimento mÃ¡ximo\n      if (fieldRules.maxLength && value.toString().length > fieldRules.maxLength) {\n        errors.push(`${field} deve ter no mÃ¡ximo ${fieldRules.maxLength} caracteres`);\n      }\n\n      // Verificar padrÃ£o\n      if (fieldRules.pattern && !fieldRules.pattern.test(value.toString())) {\n        errors.push(`${field} tem formato invÃ¡lido`);\n      }\n\n      // ValidaÃ§Ã£o customizada\n      if (fieldRules.customValidation) {\n        const customResult = fieldRules.customValidation(value);\n        if (!customResult.valid) {\n          errors.push(`${field}: ${customResult.error}`);\n        }\n      }\n\n      // Verificar se Ã© campo sensÃ­vel\n      if (this.sensitiveFields.includes(field)) {\n        warnings.push(`${field} Ã© um campo sensÃ­vel`);\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  // Validar CPF\n  validateCPF(cpf) {\n    if (!cpf) {\n      return { valid: false, error: 'CPF Ã© obrigatÃ³rio' };\n    }\n\n    // Remover formataÃ§Ã£o\n    const cleanCPF = cpf.replace(/[^\\d]/g, '');\n\n    // Verificar se tem 11 dÃ­gitos\n    if (cleanCPF.length !== 11) {\n      return { valid: false, error: 'CPF deve ter 11 dÃ­gitos' };\n    }\n\n    // Verificar se nÃ£o sÃ£o todos iguais\n    if (/^(\\d)\\1{10}$/.test(cleanCPF)) {\n      return { valid: false, error: 'CPF invÃ¡lido' };\n    }\n\n    // Validar dÃ­gitos verificadores\n    let sum = 0;\n    for (let i = 0; i < 9; i++) {\n      sum += parseInt(cleanCPF.charAt(i, 10, 10)) * (10 - i);\n    }\n    let remainder = sum % 11;\n    const digit1 = remainder < 2 ? 0 : 11 - remainder;\n\n    if (parseInt(cleanCPF.charAt(9, 10, 10)) !== digit1) {\n      return { valid: false, error: 'CPF invÃ¡lido' };\n    }\n\n    sum = 0;\n    for (let i = 0; i < 10; i++) {\n      sum += parseInt(cleanCPF.charAt(i, 10, 10)) * (11 - i);\n    }\n    remainder = sum % 11;\n    const digit2 = remainder < 2 ? 0 : 11 - remainder;\n\n    if (parseInt(cleanCPF.charAt(10, 10, 10)) !== digit2) {\n      return { valid: false, error: 'CPF invÃ¡lido' };\n    }\n\n    return { valid: true };\n  }\n\n  // Validar CNPJ\n  validateCNPJ(cnpj) {\n    if (!cnpj) {\n      return { valid: false, error: 'CNPJ Ã© obrigatÃ³rio' };\n    }\n\n    // Remover formataÃ§Ã£o\n    const cleanCNPJ = cnpj.replace(/[^\\d]/g, '');\n\n    // Verificar se tem 14 dÃ­gitos\n    if (cleanCNPJ.length !== 14) {\n      return { valid: false, error: 'CNPJ deve ter 14 dÃ­gitos' };\n    }\n\n    // Verificar se nÃ£o sÃ£o todos iguais\n    if (/^(\\d)\\1{13}$/.test(cleanCNPJ)) {\n      return { valid: false, error: 'CNPJ invÃ¡lido' };\n    }\n\n    // Validar primeiro dÃ­gito verificador\n    let sum = 0;\n    let weight = 5;\n    for (let i = 0; i < 12; i++) {\n      sum += parseInt(cleanCNPJ.charAt(i, 10, 10)) * weight;\n      weight = weight === 2 ? 9 : weight - 1;\n    }\n    let remainder = sum % 11;\n    const digit1 = remainder < 2 ? 0 : 11 - remainder;\n\n    if (parseInt(cleanCNPJ.charAt(12, 10, 10)) !== digit1) {\n      return { valid: false, error: 'CNPJ invÃ¡lido' };\n    }\n\n    // Validar segundo dÃ­gito verificador\n    sum = 0;\n    weight = 6;\n    for (let i = 0; i < 13; i++) {\n      sum += parseInt(cleanCNPJ.charAt(i, 10, 10)) * weight;\n      weight = weight === 2 ? 9 : weight - 1;\n    }\n    remainder = sum % 11;\n    const digit2 = remainder < 2 ? 0 : 11 - remainder;\n\n    if (parseInt(cleanCNPJ.charAt(13, 10, 10)) !== digit2) {\n      return { valid: false, error: 'CNPJ invÃ¡lido' };\n    }\n\n    return { valid: true };\n  }\n\n  // Validar email\n  validateEmail(email) {\n    if (!email) {\n      return { valid: false, error: 'Email Ã© obrigatÃ³rio' };\n    }\n\n    if (!validator.isEmail(email)) {\n      return { valid: false, error: 'Email invÃ¡lido' };\n    }\n\n    // Verificar domÃ­nios suspeitos\n    const suspiciousDomains = [\n      'localhost',\n      '127.0.0.1',\n      'test.com',\n      'example.com',\n      'tempmail.com',\n      '10minutemail.com',\n      'guerrillamail.com'\n    ];\n\n    const domain = email.split('@')[1];\n    if (suspiciousDomains.includes(domain)) {\n      return { valid: false, error: 'DomÃ­nio de email nÃ£o permitido' };\n    }\n\n    return { valid: true };\n  }\n\n  // Validar telefone\n  validatePhone(phone) {\n    if (!phone) {\n      return { valid: false, error: 'Telefone Ã© obrigatÃ³rio' };\n    }\n\n    // Remover formataÃ§Ã£o\n    const cleanPhone = phone.replace(/[^\\d]/g, '');\n\n    // Verificar se tem pelo menos 10 dÃ­gitos\n    if (cleanPhone.length < 10) {\n      return { valid: false, error: 'Telefone deve ter pelo menos 10 dÃ­gitos' };\n    }\n\n    // Verificar se tem no mÃ¡ximo 15 dÃ­gitos\n    if (cleanPhone.length > 15) {\n      return { valid: false, error: 'Telefone deve ter no mÃ¡ximo 15 dÃ­gitos' };\n    }\n\n    // Verificar se Ã© um nÃºmero vÃ¡lido\n    if (!/^\\d+$/.test(cleanPhone)) {\n      return { valid: false, error: 'Telefone deve conter apenas nÃºmeros' };\n    }\n\n    return { valid: true };\n  }\n\n  // Validar senha\n  validatePassword(password) {\n    if (!password) {\n      return { valid: false, error: 'Senha Ã© obrigatÃ³ria' };\n    }\n\n    if (password.length < 8) {\n      return { valid: false, error: 'Senha deve ter pelo menos 8 caracteres' };\n    }\n\n    if (password.length > 128) {\n      return { valid: false, error: 'Senha deve ter no mÃ¡ximo 128 caracteres' };\n    }\n\n    // Verificar maiÃºscula\n    if (!/[A-Z]/.test(password)) {\n      return { valid: false, error: 'Senha deve conter pelo menos uma letra maiÃºscula' };\n    }\n\n    // Verificar minÃºscula\n    if (!/[a-z]/.test(password)) {\n      return { valid: false, error: 'Senha deve conter pelo menos uma letra minÃºscula' };\n    }\n\n    // Verificar nÃºmero\n    if (!/\\d/.test(password)) {\n      return { valid: false, error: 'Senha deve conter pelo menos um nÃºmero' };\n    }\n\n    // Verificar caractere especial\n    if (!/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n      return { valid: false, error: 'Senha deve conter pelo menos um caractere especial' };\n    }\n\n    // Verificar senhas comuns\n    const commonPasswords = [\n      '123456',\n      'password',\n      'qwerty',\n      'abc123',\n      'admin',\n      'letmein',\n      'welcome',\n      'monkey',\n      '1234567890'\n    ];\n\n    if (commonPasswords.includes(password.toLowerCase())) {\n      return { valid: false, error: 'Senha muito comum, escolha uma mais segura' };\n    }\n\n    return { valid: true };\n  }\n\n  // Validar CEP\n  validateCEP(cep) {\n    if (!cep) {\n      return { valid: false, error: 'CEP Ã© obrigatÃ³rio' };\n    }\n\n    // Remover formataÃ§Ã£o\n    const cleanCEP = cep.replace(/[^\\d]/g, '');\n\n    // Verificar se tem 8 dÃ­gitos\n    if (cleanCEP.length !== 8) {\n      return { valid: false, error: 'CEP deve ter 8 dÃ­gitos' };\n    }\n\n    // Verificar se Ã© um nÃºmero vÃ¡lido\n    if (!/^\\d{8}$/.test(cleanCEP)) {\n      return { valid: false, error: 'CEP deve conter apenas nÃºmeros' };\n    }\n\n    return { valid: true };\n  }\n\n  // Validar placa\n  validatePlate(plate) {\n    if (!plate) {\n      return { valid: false, error: 'Placa Ã© obrigatÃ³ria' };\n    }\n\n    // Converter para maiÃºsculo\n    const cleanPlate = plate.toUpperCase().replace(/[^\\w]/g, '');\n\n    // Verificar padrÃ£o Mercosul (carro)\n    const mercosulCarPattern = /^[A-Z]{3}\\d[A-Z]\\d{2}$/;\n\n    // Verificar padrÃ£o Mercosul (moto)\n    const mercosulMotoPattern = /^[A-Z]{3}\\d{2}[A-Z]\\d$/;\n\n    // Verificar padrÃ£o antigo\n    const oldPattern = /^[A-Z]{3}\\d{4}$/;\n\n    if (\n      !mercosulCarPattern.test(cleanPlate) &&\n      !mercosulMotoPattern.test(cleanPlate) &&\n      !oldPattern.test(cleanPlate)\n    ) {\n      return { valid: false, error: 'Placa invÃ¡lida' };\n    }\n\n    return { valid: true };\n  }\n\n  // Sanitizar dados sensÃ­veis\n  sanitizeSensitiveData(data) {\n    const sanitized = { ...data };\n\n    for (const field of this.sensitiveFields) {\n      if (sanitized[field]) {\n        // Mascarar dados sensÃ­veis para logs\n        sanitized[field] = this.maskSensitiveData(sanitized[field]);\n      }\n    }\n\n    return sanitized;\n  }\n\n  // Mascarar dados sensÃ­veis\n  maskSensitiveData(value) {\n    if (!value) {\n      return value;\n    }\n\n    const str = value.toString();\n\n    if (str.length <= 4) {\n      return '*'.repeat(str.length);\n    }\n\n    if (str.length <= 8) {\n      return str.substring(0, 2) + '*'.repeat(str.length - 4) + str.substring(str.length - 2);\n    }\n\n    return str.substring(0, 3) + '*'.repeat(str.length - 6) + str.substring(str.length - 3);\n  }\n\n  // Validar dados de pagamento\n  validatePaymentData(paymentData) {\n    const errors = [];\n\n    // Validar valor\n    if (!paymentData.amount || paymentData.amount <= 0) {\n      errors.push('Valor deve ser maior que zero');\n    }\n\n    // Validar moeda\n    if (!paymentData.currency || !['BRL', 'USD', 'EUR'].includes(paymentData.currency)) {\n      errors.push('Moeda invÃ¡lida');\n    }\n\n    // Validar mÃ©todo de pagamento\n    if (!paymentData.method || !['stripe', 'metamask', 'pix'].includes(paymentData.method)) {\n      errors.push('MÃ©todo de pagamento invÃ¡lido');\n    }\n\n    // Validar dados especÃ­ficos do mÃ©todo\n    if (paymentData.method === 'stripe') {\n      if (!paymentData.stripeToken) {\n        errors.push('Token Stripe Ã© obrigatÃ³rio');\n      }\n    }\n\n    if (paymentData.method === 'metamask') {\n      if (!paymentData.walletAddress) {\n        errors.push('EndereÃ§o da carteira Ã© obrigatÃ³rio');\n      }\n    }\n\n    if (paymentData.method === 'pix') {\n      if (!paymentData.pixKey) {\n        errors.push('Chave PIX Ã© obrigatÃ³ria');\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  // Validar dados de produto\n  validateProductData(productData) {\n    const errors = [];\n\n    // Validar nome\n    if (!productData.name || productData.name.trim().length < 3) {\n      errors.push('Nome do produto deve ter pelo menos 3 caracteres');\n    }\n\n    // Validar preÃ§o\n    if (!productData.price || productData.price <= 0) {\n      errors.push('PreÃ§o deve ser maior que zero');\n    }\n\n    // Validar categoria\n    if (!productData.category) {\n      errors.push('Categoria Ã© obrigatÃ³ria');\n    }\n\n    // Validar descriÃ§Ã£o\n    if (!productData.description || productData.description.trim().length < 10) {\n      errors.push('DescriÃ§Ã£o deve ter pelo menos 10 caracteres');\n    }\n\n    // Validar estoque\n    if (productData.stock !== undefined && productData.stock < 0) {\n      errors.push('Estoque deve ser maior ou igual a zero');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  // Validar dados de frete\n  validateFreightData(freightData) {\n    const errors = [];\n\n    // Validar origem\n    if (!freightData.origin || freightData.origin.trim().length < 2) {\n      errors.push('Origem Ã© obrigatÃ³ria');\n    }\n\n    // Validar destino\n    if (!freightData.destination || freightData.destination.trim().length < 2) {\n      errors.push('Destino Ã© obrigatÃ³rio');\n    }\n\n    // Validar peso\n    if (!freightData.weight || freightData.weight <= 0) {\n      errors.push('Peso deve ser maior que zero');\n    }\n\n    // Validar volume\n    if (!freightData.volume || freightData.volume <= 0) {\n      errors.push('Volume deve ser maior que zero');\n    }\n\n    // Validar preÃ§o\n    if (!freightData.price || freightData.price <= 0) {\n      errors.push('PreÃ§o deve ser maior que zero');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  // Obter regras de validaÃ§Ã£o\n  getValidationRules() {\n    return this.validationRules;\n  }\n\n  // Adicionar regra de validaÃ§Ã£o\n  addValidationRule(field, rules) {\n    this.validationRules[field] = rules;\n  }\n\n  // Remover regra de validaÃ§Ã£o\n  removeValidationRule(field) {\n    delete this.validationRules[field];\n  }\n}\n\n// InstÃ¢ncia Ãºnica\nconst criticalDataValidator = new CriticalDataValidator();\n\nexport default criticalDataValidator;\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\d1-helper.js",
    "messages": [
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Parsing error: 'await' is only allowed within async functions and at the top levels of modules.",
        "line": 102,
        "column": 27,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿// ===== D1 DATABASE HELPER =====\n// UtilitÃ¡rios para trabalhar com Cloudflare D1 Database\n// Substitui MongoDB com queries SQL otimizadas\n\nimport { v4 as uuidv4 } from 'uuid';\nimport bcrypt from 'bcryptjs';\n\n/**\n * Gerar ID Ãºnico para registros\n */\nexport const generateId = (prefix = '') => {\n  const id = uuidv4();\n  return prefix ? `${prefix}-${id}` : id;\n};\n\n/**\n * Timestamp Unix atual\n */\nexport const now = () => Math.floor(Date.now() / 1000);\n\n/**\n * Executar query D1 com tratamento de erro\n */\nexport const executeD1Query = async (db, query, params = []) => {\n  try {\n    const result = await db\n      .prepare(query)\n      .bind(...params)\n      .all();\n    return {\n      success: true,\n      results: result.results || [],\n      meta: result.meta || {}\n    };\n  } catch (error) {\n    const logger = require('./logger');\n    logger.error('D1 Query Error:', error);\n    return {\n      success: false,\n      error: error.message,\n      results: []\n    };\n  }\n};\n\n/**\n * Executar query e retornar primeiro resultado\n */\nexport const executeD1QueryFirst = async (db, query, params = []) => {\n  try {\n    const result = await db\n      .prepare(query)\n      .bind(...params)\n      .first();\n    return {\n      success: true,\n      result: result || null\n    };\n  } catch (error) {\n    const logger = require('./logger');\n    logger.error('D1 Query Error:', error);\n    return {\n      success: false,\n      error: error.message,\n      result: null\n    };\n  }\n};\n\n/**\n * Executar query de escrita (INSERT, UPDATE, DELETE)\n */\nexport const executeD1Write = async (db, query, params = []) => {\n  try {\n    const result = await db\n      .prepare(query)\n      .bind(...params)\n      .run();\n    return {\n      success: true,\n      meta: result.meta || {},\n      changes: result.meta?.changes || 0\n    };\n  } catch (error) {\n    const logger = require('./logger');\n    logger.error('D1 Write Error:', error);\n    return {\n      success: false,\n      error: error.message,\n      changes: 0\n    };\n  }\n};\n\n/**\n * Criar usuÃ¡rio no D1\n */\nexport const createUser = (db, userData) => {\n  const { email, name, password, phone = null, businessType = 'user', role = 'user' } = userData;\n\n  const id = generateId('user');\n  const hashedPassword = await bcrypt.hash(password, 12);\n  const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();\n  const codeExpires = now() + 600; // 10 minutos\n\n  const query = `\n    INSERT INTO users (\n      id, email, name, password, phone, businessType, role,\n      verificationCode, codeExpires, createdAt, updatedAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  const result = await executeD1Write(db, query, [\n    id,\n    email.toLowerCase(),\n    name,\n    hashedPassword,\n    phone,\n    businessType,\n    role,\n    verificationCode,\n    codeExpires,\n    now(),\n    now()\n  ]);\n\n  if (result.success) {\n    return {\n      success: true,\n      userId: id,\n      verificationCode\n    };\n  }\n\n  return result;\n};\n\n/**\n * Buscar usuÃ¡rio por email\n */\nexport const findUserByEmail = (db, email) => {\n  const query = 'SELECT * FROM users WHERE email = ? LIMIT 1';\n  return executeD1QueryFirst(db, query, [email.toLowerCase()]);\n};\n\n/**\n * Buscar usuÃ¡rio por ID\n */\nexport const findUserById = (db, userId) => {\n  const query = 'SELECT * FROM users WHERE id = ? LIMIT 1';\n  return executeD1QueryFirst(db, query, [userId]);\n};\n\n/**\n * Atualizar usuÃ¡rio\n */\nexport const updateUser = (db, userId, updates) => {\n  const fields = [];\n  const values = [];\n\n  Object.keys(updates).forEach(key => {\n    if (updates[key] !== undefined) {\n      fields.push(`${key} = ?`);\n      values.push(updates[key]);\n    }\n  });\n\n  // Adicionar updatedAt\n  fields.push('updatedAt = ?');\n  values.push(now());\n\n  // Adicionar userId no final\n  values.push(userId);\n\n  const query = `UPDATE users SET ${fields.join(', ')} WHERE id = ?`;\n  return executeD1Write(db, query, values);\n};\n\n/**\n * Verificar senha\n */\nexport const verifyPassword = (plainPassword, hashedPassword) => {\n  return bcrypt.compare(plainPassword, hashedPassword);\n};\n\n/**\n * Criar produto\n */\nexport const createProduct = (db, userId, productData) => {\n  const {\n    title,\n    description = '',\n    category,\n    price,\n    stock = 0,\n    images = [],\n    city = '',\n    state = ''\n  } = productData;\n\n  const id = generateId('prod');\n  const slug = title\n    .toLowerCase()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/\\s+/g, '-');\n\n  const query = `\n    INSERT INTO products (\n      id, userId, title, description, category, price, stock,\n      images, city, state, slug, status, createdAt, updatedAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  const result = await executeD1Write(db, query, [\n    id,\n    userId,\n    title,\n    description,\n    category,\n    price,\n    stock,\n    JSON.stringify(images),\n    city,\n    state,\n    slug,\n    'active',\n    now(),\n    now()\n  ]);\n\n  if (result.success) {\n    return {\n      success: true,\n      productId: id\n    };\n  }\n\n  return result;\n};\n\n/**\n * Buscar produtos com filtros\n */\nexport const findProducts = (db, filters = {}) => {\n  let query = \"SELECT * FROM products WHERE status = 'active'\";\n  const params = [];\n\n  if (filters.category) {\n    query += ' AND category = ?';\n    params.push(filters.category);\n  }\n\n  if (filters.state) {\n    query += ' AND state = ?';\n    params.push(filters.state);\n  }\n\n  if (filters.search) {\n    query += ' AND (title LIKE ? OR description LIKE ?)';\n    const searchTerm = `%${filters.search}%`;\n    params.push(searchTerm, searchTerm);\n  }\n\n  query += ' ORDER BY createdAt DESC';\n\n  if (filters.limit) {\n    query += ' LIMIT ?';\n    params.push(parseInt(filters.limit, 10, 10));\n  }\n\n  return executeD1Query(db, query, params);\n};\n\n/**\n * Criar frete\n */\nexport const createFreight = (db, userId, freightData) => {\n  const { originCity, originState, destinationCity, destinationState, loadType, price } =\n    freightData;\n\n  const id = generateId('freight');\n  const trackingCode = `AGR${Date.now().toString(36).toUpperCase()}`;\n\n  const query = `\n    INSERT INTO freights (\n      id, userId, originCity, originState, destinationCity, destinationState,\n      loadType, price, trackingCode, status, createdAt, updatedAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  const result = await executeD1Write(db, query, [\n    id,\n    userId,\n    originCity,\n    originState,\n    destinationCity,\n    destinationState,\n    loadType,\n    price,\n    trackingCode,\n    'available',\n    now(),\n    now()\n  ]);\n\n  if (result.success) {\n    return {\n      success: true,\n      freightId: id,\n      trackingCode\n    };\n  }\n\n  return result;\n};\n\n/**\n * Buscar fretes\n */\nexport const findFreights = (db, filters = {}) => {\n  let query = \"SELECT * FROM freights WHERE status = 'available'\";\n  const params = [];\n\n  if (filters.originState) {\n    query += ' AND originState = ?';\n    params.push(filters.originState);\n  }\n\n  if (filters.destinationState) {\n    query += ' AND destinationState = ?';\n    params.push(filters.destinationState);\n  }\n\n  query += ' ORDER BY createdAt DESC';\n\n  if (filters.limit) {\n    query += ' LIMIT ?';\n    params.push(parseInt(filters.limit, 10, 10));\n  }\n\n  return executeD1Query(db, query, params);\n};\n\n/**\n * Criar mensagem\n */\nexport const createMessage = (db, messageData) => {\n  const { conversationId, senderId, receiverId, content, type = 'text' } = messageData;\n\n  const id = generateId('msg');\n\n  const query = `\n    INSERT INTO messages (\n      id, conversationId, senderId, receiverId, content, type, createdAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  return executeD1Write(db, query, [\n    id,\n    conversationId,\n    senderId,\n    receiverId,\n    content,\n    type,\n    now()\n  ]);\n};\n\n/**\n * Buscar mensagens de uma conversa\n */\nexport const findMessages = (db, conversationId, limit = 50) => {\n  const query = `\n    SELECT * FROM messages \n    WHERE conversationId = ? AND isDeleted = 0\n    ORDER BY createdAt DESC\n    LIMIT ?\n  `;\n\n  return executeD1Query(db, query, [conversationId, limit]);\n};\n\n/**\n * Criar transaÃ§Ã£o\n */\nexport const createTransaction = (db, transactionData) => {\n  const { userId, type, amount, paymentMethod, description } = transactionData;\n\n  const id = generateId('txn');\n\n  const query = `\n    INSERT INTO transactions (\n      id, userId, type, amount, paymentMethod, paymentStatus, description, createdAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  return executeD1Write(db, query, [\n    id,\n    userId,\n    type,\n    amount,\n    paymentMethod,\n    'pending',\n    description,\n    now()\n  ]);\n};\n\n/**\n * Criar log de auditoria\n */\nexport const createAuditLog = (db, logData) => {\n  const { userId, action, entity, entityId, ipAddress, userAgent } = logData;\n\n  const id = generateId('log');\n\n  const query = `\n    INSERT INTO audit_logs (\n      id, userId, action, entity, entityId, ipAddress, userAgent, createdAt\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n  `;\n\n  return executeD1Write(db, query, [\n    id,\n    userId,\n    action,\n    entity,\n    entityId,\n    ipAddress,\n    userAgent,\n    now()\n  ]);\n};\n\n/**\n * Sanitizar dados para JSON\n */\nexport const sanitizeForJSON = data => {\n  if (!data) {\n    return null;\n  }\n\n  const sanitized = { ...data };\n\n  // Converter integers para boolean\n  ['isAdmin', 'isActive', 'isBlocked', 'isEmailVerified', 'isPaid', 'twoFactorEnabled'].forEach(\n    field => {\n      if (field in sanitized) {\n        sanitized[field] = Boolean(sanitized[field]);\n      }\n    }\n  );\n\n  // Parsear JSON strings\n  ['images', 'tags', 'certifications', 'dimensions'].forEach(field => {\n    if (sanitized[field] && typeof sanitized[field] === 'string') {\n      try {\n        sanitized[field] = JSON.parse(sanitized[field]);\n      } catch (e) {\n        // Manter como string se nÃ£o for JSON vÃ¡lido\n      }\n    }\n  });\n\n  // Remover senha\n  delete sanitized.password;\n  delete sanitized.twoFactorSecret;\n\n  return sanitized;\n};\n\nexport default {\n  generateId,\n  now,\n  executeD1Query,\n  executeD1QueryFirst,\n  executeD1Write,\n  createUser,\n  findUserByEmail,\n  findUserById,\n  updateUser,\n  verifyPassword,\n  createProduct,\n  findProducts,\n  createFreight,\n  findFreights,\n  createMessage,\n  findMessages,\n  createTransaction,\n  createAuditLog,\n  sanitizeForJSON\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\finalVerification.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\ipUtils.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\logger.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\responseFormatter.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'next' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 272,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 272,
        "endColumn": 55
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "﻿/**\n * AGROISYNC - Response Formatter\n *\n * Padroniza todas as respostas da API para manter consistÃªncia\n * entre frontend e backend.\n *\n * Formato padrÃ£o:\n * {\n *   success: boolean,\n *   message: string,\n *   data: object | array | null,\n *   error: string | object | null,\n *   timestamp: number,\n *   requestId: string (opcional)\n * }\n */\n\nimport { v4 as uuidv4 } from 'uuid';\n\nimport logger from './logger.js';\n/**\n * Cria uma resposta de sucesso padronizada\n *\n * @param {*} data - Dados a serem retornados\n * @param {string} message - Mensagem de sucesso (opcional)\n * @param {number} statusCode - CÃ³digo HTTP (opcional)\n * @returns {object} Resposta formatada\n */\nexport const successResponse = (data = null, message = 'Success', statusCode = 200) => {\n  return {\n    success: true,\n    message,\n    data,\n    error: null,\n    timestamp: Date.now(),\n    statusCode\n  };\n};\n\n/**\n * Cria uma resposta de erro padronizada\n *\n * @param {string} message - Mensagem de erro\n * @param {*} error - Objeto de erro detalhado (opcional)\n * @param {number} statusCode - CÃ³digo HTTP (opcional)\n * @returns {object} Resposta formatada\n */\nexport const errorResponse = (message = 'Error', error = null, statusCode = 400) => {\n  // Em produÃ§Ã£o, nÃ£o expor detalhes do erro\n  const errorDetails = process.env.NODE_ENV === 'production' ? null : error?.message || error;\n\n  return {\n    success: false,\n    message,\n    data: null,\n    error: errorDetails,\n    timestamp: Date.now(),\n    statusCode\n  };\n};\n\n/**\n * Cria uma resposta de validaÃ§Ã£o com erros detalhados\n *\n * @param {array} errors - Array de erros de validaÃ§Ã£o\n * @param {string} message - Mensagem geral (opcional)\n * @returns {object} Resposta formatada\n */\nexport const validationErrorResponse = (errors = [], message = 'Validation failed') => {\n  return {\n    success: false,\n    message,\n    data: null,\n    error: {\n      type: 'validation',\n      errors: Array.isArray(errors) ? errors : [errors]\n    },\n    timestamp: Date.now(),\n    statusCode: 422\n  };\n};\n\n/**\n * Cria uma resposta de erro de autenticaÃ§Ã£o\n *\n * @param {string} message - Mensagem de erro\n * @returns {object} Resposta formatada\n */\nexport const authErrorResponse = (message = 'Authentication failed') => {\n  return {\n    success: false,\n    message,\n    data: null,\n    error: {\n      type: 'authentication',\n      message\n    },\n    timestamp: Date.now(),\n    statusCode: 401\n  };\n};\n\n/**\n * Cria uma resposta de erro de autorizaÃ§Ã£o\n *\n * @param {string} message - Mensagem de erro\n * @returns {object} Resposta formatada\n */\nexport const forbiddenResponse = (message = 'Access forbidden') => {\n  return {\n    success: false,\n    message,\n    data: null,\n    error: {\n      type: 'authorization',\n      message\n    },\n    timestamp: Date.now(),\n    statusCode: 403\n  };\n};\n\n/**\n * Cria uma resposta de recurso nÃ£o encontrado\n *\n * @param {string} resource - Nome do recurso\n * @returns {object} Resposta formatada\n */\nexport const notFoundResponse = (resource = 'Resource') => {\n  return {\n    success: false,\n    message: `${resource} not found`,\n    data: null,\n    error: {\n      type: 'not_found',\n      resource\n    },\n    timestamp: Date.now(),\n    statusCode: 404\n  };\n};\n\n/**\n * Cria uma resposta de erro do servidor\n *\n * @param {string} message - Mensagem de erro\n * @param {*} error - Objeto de erro (opcional)\n * @returns {object} Resposta formatada\n */\nexport const serverErrorResponse = (message = 'Internal server error', error = null) => {\n  // Log do erro para monitoramento\n  if (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Server Error:', error);\n    }\n  }\n\n  return {\n    success: false,\n    message,\n    data: null,\n    error: process.env.NODE_ENV === 'production' ? null : error?.message || error?.stack || error,\n    timestamp: Date.now(),\n    statusCode: 500\n  };\n};\n\n/**\n * Cria uma resposta de lista paginada\n *\n * @param {array} items - Array de itens\n * @param {number} page - PÃ¡gina atual\n * @param {number} limit - Itens por pÃ¡gina\n * @param {number} total - Total de itens\n * @param {string} message - Mensagem (opcional)\n * @returns {object} Resposta formatada\n */\nexport const paginatedResponse = (\n  items = [],\n  page = 1,\n  limit = 10,\n  total = 0,\n  message = 'Success'\n) => {\n  const totalPages = Math.ceil(total / limit);\n  const hasNextPage = page < totalPages;\n  const hasPrevPage = page > 1;\n\n  return {\n    success: true,\n    message,\n    data: {\n      items,\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages,\n        hasNextPage,\n        hasPrevPage,\n        nextPage: hasNextPage ? page + 1 : null,\n        prevPage: hasPrevPage ? page - 1 : null\n      }\n    },\n    error: null,\n    timestamp: Date.now(),\n    statusCode: 200\n  };\n};\n\n/**\n * Cria uma resposta com metadados adicionais\n *\n * @param {*} data - Dados principais\n * @param {object} meta - Metadados adicionais\n * @param {string} message - Mensagem (opcional)\n * @returns {object} Resposta formatada\n */\nexport const responseWithMeta = (data = null, meta = {}, message = 'Success') => {\n  return {\n    success: true,\n    message,\n    data,\n    meta,\n    error: null,\n    timestamp: Date.now(),\n    statusCode: 200\n  };\n};\n\n/**\n * Middleware para adicionar requestId a todas as requisiÃ§Ãµes\n * Ãštil para rastreamento e debugging\n */\nexport const requestIdMiddleware = (req, res, next) => {\n  req.id = uuidv4();\n  res.setHeader('X-Request-Id', req.id);\n  next();\n};\n\n/**\n * Wrapper para enviar resposta formatada via Express\n *\n * @param {object} res - Objeto response do Express\n * @param {object} responseData - Dados da resposta formatada\n */\nexport const sendResponse = (res, responseData) => {\n  const statusCode = responseData.statusCode || 200;\n  delete responseData.statusCode; // Remover antes de enviar\n\n  return res.status(statusCode).json(responseData);\n};\n\n/**\n * Helper para converter erros do Express Validator\n *\n * @param {array} validationErrors - Erros do express-validator\n * @returns {array} Array formatado de erros\n */\nexport const formatValidationErrors = validationErrors => {\n  return validationErrors.map(err => ({\n    field: err.param || err.path,\n    message: err.msg,\n    value: err.value\n  }));\n};\n\n/**\n * Middleware global de tratamento de erros\n * Deve ser o Ãºltimo middleware da aplicaÃ§Ã£o\n */\nexport const globalErrorHandler = (err, req, res, next) => {\n  // Log do erro\n  logger.error('Global Error Handler:', {\n    requestId: req.id,\n    error: err.message,\n    stack: process.env.NODE_ENV !== 'production' ? err.stack : undefined,\n    path: req.path,\n    method: req.method\n  });\n\n  // Determinar tipo de erro e responder apropriadamente\n  let response;\n\n  if (err.name === 'ValidationError') {\n    // Erro de validaÃ§Ã£o do Mongoose\n    response = validationErrorResponse(\n      Object.values(err.errors).map(e => e.message),\n      'Validation failed'\n    );\n  } else if (err.name === 'UnauthorizedError' || err.name === 'JsonWebTokenError') {\n    // Erro de autenticaÃ§Ã£o JWT\n    response = authErrorResponse('Invalid or expired token');\n  } else if (err.name === 'CastError') {\n    // Erro de cast do Mongoose (ID invÃ¡lido, etc)\n    response = errorResponse('Invalid data format', err.message, 400);\n  } else if (err.statusCode) {\n    // Erro customizado com statusCode\n    response = errorResponse(err.message, err, err.statusCode);\n  } else {\n    // Erro genÃ©rico do servidor\n    response = serverErrorResponse('Internal server error', err);\n  }\n\n  // Adicionar requestId se disponÃ­vel\n  if (req.id) {\n    response.requestId = req.id;\n  }\n\n  return sendResponse(res, response);\n};\n\n// Exportar tudo como default tambÃ©m\nexport default {\n  successResponse,\n  errorResponse,\n  validationErrorResponse,\n  authErrorResponse,\n  forbiddenResponse,\n  notFoundResponse,\n  serverErrorResponse,\n  paginatedResponse,\n  responseWithMeta,\n  sendResponse,\n  formatValidationErrors,\n  requestIdMiddleware,\n  globalErrorHandler\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\sanitizer.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\securityLogger.js",
    "messages": [
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 8 spaces but found 10.",
        "line": 45,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 45,
        "endColumn": 11,
        "fix": { "range": [1324, 1334], "text": "        " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 8 spaces but found 10.",
        "line": 46,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 46,
        "endColumn": 11,
        "fix": { "range": [1354, 1364], "text": "        " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 8 spaces but found 10.",
        "line": 47,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 47,
        "endColumn": 11,
        "fix": { "range": [1386, 1396], "text": "        " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 8 spaces but found 10.",
        "line": 48,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 48,
        "endColumn": 11,
        "fix": { "range": [1435, 1445], "text": "        " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 8 spaces but found 10.",
        "line": 49,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 49,
        "endColumn": 11,
        "fix": { "range": [1479, 1489], "text": "        " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 8 spaces but found 10.",
        "line": 50,
        "column": 1,
        "nodeType": "Identifier",
        "messageId": "wrongIndentation",
        "endLine": 50,
        "endColumn": 11,
        "fix": { "range": [1518, 1528], "text": "        " }
      },
      {
        "ruleId": "indent",
        "severity": 2,
        "message": "Expected indentation of 6 spaces but found 8.",
        "line": 51,
        "column": 1,
        "nodeType": "Punctuator",
        "messageId": "wrongIndentation",
        "endLine": 51,
        "endColumn": 9,
        "fix": { "range": [1550, 1558], "text": "      " }
      },
      {
        "ruleId": "curly",
        "severity": 2,
        "message": "Expected { after 'if' condition.",
        "line": 87,
        "column": 35,
        "nodeType": "IfStatement",
        "messageId": "missingCurlyAfterCondition",
        "endLine": 87,
        "endColumn": 81,
        "fix": {
          "range": [2792, 2838],
          "text": "{logger.error('Error message:', error.message);}"
        }
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Parsing error: 'await' is only allowed within async functions and at the top levels of modules.",
        "line": 247,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 9,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 8,
    "fixableWarningCount": 0,
    "source": "﻿import SecurityLog from '../models/SecurityLog.js';\nimport { getClientIP } from './ipUtils.js';\nimport logger from './logger.js';\n\n// ===== LOGGER DE SEGURANÃ‡A =====\n\n/**\n * Criar log de seguranÃ§a\n * @param {string} eventType - Tipo do evento\n * @param {string} severity - Severidade (low, medium, high, critical)\n * @param {string} description - DescriÃ§Ã£o do evento\n * @param {Object} req - Objeto de requisiÃ§Ã£o Express\n * @param {string} userId - ID do usuÃ¡rio (opcional)\n * @param {Object} additionalData - Dados adicionais (opcional)\n */\nexport const createSecurityLog = async (\n  eventType,\n  severity,\n  description,\n  req,\n  userId = null,\n  additionalData = {}\n) => {\n  try {\n    // Validar parÃ¢metros\n    if (!eventType || !severity || !description) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Security log: ParÃ¢metros invÃ¡lidos', { eventType, severity, description });\n      }\n      return;\n    }\n\n    // Validar severidade\n    const validSeverities = ['low', 'medium', 'high', 'critical'];\n    if (!validSeverities.includes(severity)) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Security log: Severidade invÃ¡lida', { severity });\n      }\n      return;\n    }\n\n    // Obter informaÃ§Ãµes da requisiÃ§Ã£o\n    const requestInfo = req\n      ? {\n          method: req.method,\n          url: req.originalUrl,\n          headers: sanitizeHeaders(req.headers),\n          userAgent: req.get('User-Agent'),\n          ipAddress: getClientIP(req),\n          timestamp: new Date()\n        }\n      : null;\n\n    // Criar log de seguranÃ§a\n    const securityLog = new SecurityLog({\n      eventType,\n      severity,\n      description,\n      userId,\n      ipAddress: requestInfo?.ipAddress || 'unknown',\n      userAgent: requestInfo?.userAgent || 'unknown',\n      requestMethod: requestInfo?.method || 'unknown',\n      requestUrl: requestInfo?.url || 'unknown',\n      requestHeaders: requestInfo?.headers || {},\n      geolocation: requestInfo ? getGeolocation(req) : {},\n      cloudflare: requestInfo ? getCloudflareInfo(req) : {},\n      details: {\n        ...additionalData,\n        timestamp: requestInfo?.timestamp || new Date()\n      }\n    });\n\n    await securityLog.save();\n\n    // Log no console para desenvolvimento\n    if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      logger.info(`[SecurityLog] ${eventType} - ${description}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating security log:', error);\n    }\n    // Fallback: log no console se não conseguir salvar no banco\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Additional data:', additionalData);\n      if (error && error.message) logger.error('Error message:', error.message);\n    }\n  }\n};\n\n/**\n * Criar log de seguranÃ§a sem requisiÃ§Ã£o (para eventos do sistema)\n * @param {string} eventType - Tipo do evento\n * @param {string} severity - Severidade\n * @param {string} description - DescriÃ§Ã£o do evento\n * @param {Object} additionalData - Dados adicionais\n */\nexport const createSystemSecurityLog = async (\n  eventType,\n  severity,\n  description,\n  additionalData = {}\n) => {\n  try {\n    const securityLog = new SecurityLog({\n      eventType,\n      severity,\n      description,\n      ipAddress: 'system',\n      userAgent: 'system',\n      requestMethod: 'SYSTEM',\n      requestUrl: 'SYSTEM',\n      requestHeaders: {},\n      geolocation: {},\n      cloudflare: {},\n      details: {\n        ...additionalData,\n        timestamp: new Date(),\n        source: 'system'\n      }\n    });\n\n    await securityLog.save();\n\n    if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      logger.info(`[SystemSecurityLog] ${eventType} - ${description}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating system security log:', error);\n    }\n    // fallback handled\n  }\n};\n\n/**\n * Criar log de auditoria\n * @param {string} action - AÃ§Ã£o realizada\n * @param {string} resource - Recurso afetado\n * @param {Object} req - Objeto de requisiÃ§Ã£o\n * @param {string} userId - ID do usuÃ¡rio\n * @param {Object} changes - MudanÃ§as realizadas\n */\nexport const createAuditLog = async (action, resource, req, userId, changes = {}) => {\n  try {\n    const auditLog = new SecurityLog({\n      eventType: 'audit',\n      severity: 'low',\n      description: `${action} em ${resource}`,\n      userId,\n      ipAddress: getClientIP(req),\n      userAgent: req.get('User-Agent'),\n      requestMethod: req.method,\n      requestUrl: req.originalUrl,\n      requestHeaders: sanitizeHeaders(req.headers),\n      geolocation: getGeolocation(req),\n      cloudflare: getCloudflareInfo(req),\n      details: {\n        action,\n        resource,\n        changes,\n        timestamp: new Date()\n      }\n    });\n\n    await auditLog.save();\n\n    if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      logger.info(`Audit Log: ${action} em ${resource} por usuário ${userId}`);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating audit log:', error);\n    }\n  }\n};\n\n/**\n * Criar log de acesso\n * @param {string} resource - Recurso acessado\n * @param {Object} req - Objeto de requisiÃ§Ã£o\n * @param {string} userId - ID do usuÃ¡rio\n * @param {Object} metadata - Metadados adicionais\n */\nexport const createAccessLog = async (resource, req, userId, metadata = {}) => {\n  try {\n    const accessLog = new SecurityLog({\n      eventType: 'data_access',\n      severity: 'low',\n      description: `Acesso a ${resource}`,\n      userId,\n      ipAddress: getClientIP(req),\n      userAgent: req.get('User-Agent'),\n      requestMethod: req.method,\n      requestUrl: req.originalUrl,\n      requestHeaders: sanitizeHeaders(req.headers),\n      geolocation: getGeolocation(req),\n      cloudflare: getCloudflareInfo(req),\n      details: {\n        resource,\n        ...metadata,\n        timestamp: new Date()\n      }\n    });\n\n    await accessLog.save();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating access log:', error);\n    }\n  }\n};\n\n/**\n * Criar log de modificaÃ§Ã£o de dados\n * @param {string} resource - Recurso modificado\n * @param {string} action - AÃ§Ã£o realizada\n * @param {Object} req - Objeto de requisiÃ§Ã£o\n * @param {string} userId - ID do usuÃ¡rio\n * @param {Object} changes - MudanÃ§as realizadas\n */\nexport const createDataModificationLog = (resource, action, req, userId, changes = {}) => {\n  try {\n    const modificationLog = new SecurityLog({\n      eventType: 'data_modification',\n      severity: 'medium',\n      description: `${action} em ${resource}`,\n      userId,\n      ipAddress: getClientIP(req),\n      userAgent: req.get('User-Agent'),\n      requestMethod: req.method,\n      requestUrl: req.originalUrl,\n      requestHeaders: sanitizeHeaders(req.headers),\n      geolocation: getGeolocation(req),\n      cloudflare: getCloudflareInfo(req),\n      details: {\n        resource,\n        action,\n        changes,\n        timestamp: new Date()\n      }\n    });\n\n    await modificationLog.save();\n\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.info(`âœï¸ Data Modification Log: ${action} em ${resource} por usuÃ¡rio ${userId}`);\n      }\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error creating data modification log:', error);\n    }\n  }\n};\n\n// ===== FUNÃ‡Ã•ES AUXILIARES =====\n\n/**\n * Sanitizar headers da requisiÃ§Ã£o (remover dados sensÃ­veis)\n * @param {Object} headers - Headers da requisiÃ§Ã£o\n * @returns {Object} Headers sanitizados\n */\nconst sanitizeHeaders = headers => {\n  const sanitized = { ...headers };\n\n  // Remover headers sensÃ­veis\n  const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key', 'x-auth-token', 'x-csrf-token'];\n\n  sensitiveHeaders.forEach(header => {\n    if (sanitized[header]) {\n      sanitized[header] = '[REDACTED]';\n    }\n  });\n\n  return sanitized;\n};\n\n/**\n * Obter informaÃ§Ãµes de geolocalizaÃ§Ã£o\n * @param {Object} req - Objeto de requisiÃ§Ã£o\n * @returns {Object} InformaÃ§Ãµes de geolocalizaÃ§Ã£o\n */\nconst getGeolocation = req => {\n  return {\n    country: req.headers['cf-ipcountry'] || req.headers['x-forwarded-country'] || 'Unknown',\n    region: req.headers['cf-ipregion'] || req.headers['x-forwarded-region'] || 'Unknown',\n    city: req.headers['cf-ipcity'] || req.headers['x-forwarded-city'] || 'Unknown',\n    timezone: req.headers['cf-timezone'] || 'Unknown'\n  };\n};\n\n/**\n * Obter informaÃ§Ãµes do Cloudflare\n * @param {Object} req - Objeto de requisiÃ§Ã£o\n * @returns {Object} InformaÃ§Ãµes do Cloudflare\n */\nconst getCloudflareInfo = req => {\n  return {\n    rayId: req.headers['cf-ray'] || null,\n    country: req.headers['cf-ipcountry'] || null,\n    threatScore: parseInt(req.headers['cf-threat-score'], 10, 10) || 0,\n    botScore: parseInt(req.headers['cf-bot-score'], 10, 10) || 0,\n    visitor: req.headers['cf-visitor'] || null,\n    cacheStatus: req.headers['cf-cache-status'] || null\n  };\n};\n\n/**\n * Obter estatÃ­sticas de logs de seguranÃ§a\n * @param {Object} filters - Filtros para as estatÃ­sticas\n * @returns {Object} EstatÃ­sticas dos logs\n */\nexport const getSecurityLogStats = async (filters = {}) => {\n  try {\n    const matchStage = {};\n\n    if (filters.eventType) {\n      matchStage.eventType = filters.eventType;\n    }\n    if (filters.severity) {\n      matchStage.severity = filters.severity;\n    }\n    if (filters.userId) {\n      matchStage.userId = filters.userId;\n    }\n    if (filters.startDate) {\n      matchStage.createdAt = { $gte: new Date(filters.startDate) };\n    }\n    if (filters.endDate) {\n      if (matchStage.createdAt) {\n        matchStage.createdAt.$lte = new Date(filters.endDate);\n      } else {\n        matchStage.createdAt = { $lte: new Date(filters.endDate) };\n      }\n    }\n\n    const stats = await SecurityLog.aggregate([\n      { $match: matchStage },\n      {\n        $group: {\n          _id: '$eventType',\n          count: { $sum: 1 },\n          bySeverity: {\n            $push: {\n              severity: '$severity',\n              description: '$description',\n              timestamp: '$createdAt'\n            }\n          }\n        }\n      },\n      {\n        $project: {\n          eventType: '$_id',\n          count: 1,\n          bySeverity: 1,\n          criticalCount: {\n            $size: {\n              $filter: {\n                input: '$bySeverity',\n                cond: { $eq: ['$$this.severity', 'critical'] }\n              }\n            }\n          },\n          highCount: {\n            $size: {\n              $filter: {\n                input: '$bySeverity',\n                cond: { $eq: ['$$this.severity', 'high'] }\n              }\n            }\n          }\n        }\n      },\n      { $sort: { count: -1 } }\n    ]);\n\n    return stats;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error getting security log stats:', error);\n    }\n    return [];\n  }\n};\n\n/**\n * Limpar logs antigos (manutenÃ§Ã£o)\n * @param {number} daysToKeep - NÃºmero de dias para manter\n * @returns {number} NÃºmero de logs removidos\n */\nexport const cleanupOldLogs = async (daysToKeep = 90) => {\n  try {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);\n\n    const result = await SecurityLog.deleteMany({\n      createdAt: { $lt: cutoffDate },\n      severity: { $in: ['low', 'medium'] } // Manter logs crÃ­ticos e de alta severidade\n    });\n\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.info(`ðŸ§¹ Cleaned up ${result.deletedCount} old security logs`);\n      }\n    }\n\n    return result.deletedCount;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error('Error cleaning up old logs:', error);\n    }\n    return 0;\n  }\n};\n\nexport default {\n  createSecurityLog,\n  createSystemSecurityLog,\n  createAuditLog,\n  createAccessLog,\n  createDataModificationLog,\n  getSecurityLogStats,\n  cleanupOldLogs\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\luisp\\OneDrive\\Área de Trabalho\\agroisync\\backend\\src\\utils\\verifyTurnstile.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "indent", "replacedBy": [] },
      { "ruleId": "quotes", "replacedBy": [] },
      { "ruleId": "semi", "replacedBy": [] },
      { "ruleId": "comma-dangle", "replacedBy": [] },
      { "ruleId": "object-curly-spacing", "replacedBy": [] },
      { "ruleId": "array-bracket-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] },
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "callback-return", "replacedBy": [] },
      { "ruleId": "handle-callback-err", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-process-exit", "replacedBy": [] }
    ]
  }
]

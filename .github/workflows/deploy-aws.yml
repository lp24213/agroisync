name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: agrotm-solana
  ECS_CLUSTER: agrotm-cluster
  ECS_SERVICE: agrotm-service
  ECS_TASK_DEFINITION: agrotm-task

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        
    - name: Download task definition
      run: |
        aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} \
        --query taskDefinition > task-definition.json
        
    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v2
      with:
        task-definition: task-definition.json
        container-name: agrotm-app
        image: ${{ steps.build-image.outputs.image }}
        
    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true
        
    - name: Update CloudFront distribution
      run: |
        # Invalidate CloudFront cache
        aws cloudfront create-invalidation \
          --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
          --paths "/*"
          
    - name: Update Route 53 DNS
      run: |
        # Update DNS records if needed
        aws route53 change-resource-record-sets \
          --hosted-zone-id ${{ secrets.ROUTE53_HOSTED_ZONE_ID }} \
          --change-batch file://dns-update.json
      if: ${{ github.event.inputs.environment == 'production' }}
      
    - name: Run health checks
      run: |
        # Wait for application to be healthy
        sleep 30
        
        # Run health checks
        curl -f ${{ secrets.HEALTH_CHECK_URL }} || exit 1
        
        # Run smoke tests
        npm run test:smoke
        
    - name: Scale up application
      run: |
        # Scale up the service
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE }} \
          --desired-count 3
          
    - name: Monitor deployment
      run: |
        # Monitor deployment for 5 minutes
        for i in {1..30}; do
          echo "Checking deployment status... ($i/30)"
          
          # Check service status
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].status' \
            --output text)
            
          if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            echo "Service is active and healthy"
            break
          fi
          
          sleep 10
        done
        
        if [ "$SERVICE_STATUS" != "ACTIVE" ]; then
          echo "Service failed to become active"
          exit 1
        fi
        
    - name: Run post-deployment tests
      run: |
        # Run integration tests
        npm run test:integration
        
        # Run performance tests
        npm run test:performance
        
        # Run security tests
        npm run test:security
        
    - name: Update deployment status
      run: |
        # Update deployment status in database
        curl -X POST ${{ secrets.DEPLOYMENT_WEBHOOK_URL }} \
          -H "Content-Type: application/json" \
          -d "{\"status\": \"success\", \"environment\": \"${{ github.event.inputs.environment || 'production' }}\", \"commit\": \"${{ github.sha }}\", \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}"
          
    - name: Create deployment record
      run: |
        # Create deployment record in monitoring system
        aws logs put-log-events \
          --log-group-name "/aws/ecs/agrotm-deployments" \
          --log-stream-name "$(date +%Y-%m-%d)" \
          --log-events timestamp=$(date +%s)000,message="Deployment successful: ${{ github.sha }} to ${{ github.event.inputs.environment || 'production' }}"
          
    - name: Notify deployment success
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
        text: |
          ✅ Deployment successful!
          Environment: ${{ github.event.inputs.environment || 'production' }}
          Commit: ${{ github.sha }}
          URL: ${{ secrets.APP_URL }}
      if: success()
      
    - name: Notify deployment failure
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
        text: |
          ❌ Deployment failed!
          Environment: ${{ github.event.inputs.environment || 'production' }}
          Commit: ${{ github.sha }}
          Check the logs for details.
      if: failure()
      
    - name: Rollback on failure
      run: |
        # Rollback to previous version if deployment fails
        PREVIOUS_TASK_DEF=$(aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
          
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE }} \
          --task-definition $PREVIOUS_TASK_DEF
          
        echo "Rolled back to previous version"
      if: failure()
      
    - name: Clean up old images
      run: |
        # Keep only last 10 images
        aws ecr describe-images \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --query 'imageDetails[?imagePushedAt<`'$(date -d '7 days ago' -u +%Y-%m-%dT%H:%M:%SZ)'`].imageDigest' \
          --output text | \
        xargs -I {} aws ecr batch-delete-image \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageDigest={} 